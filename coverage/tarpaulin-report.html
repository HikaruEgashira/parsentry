<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","build.rs"],"content":"use std::path::PathBuf;\n\nfn main() {\n    let dir = PathBuf::from(std::env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n    let out_dir = PathBuf::from(std::env::var(\"OUT_DIR\").unwrap());\n\n    // Get tree-sitter include path from the tree-sitter crate\n    let tree_sitter_dir = PathBuf::from(\n        std::env::var(\"DEP_TREE_SITTER_RUNTIME_INCLUDE\").unwrap_or_else(|_| {\n            // Fallback to a common location if the env var is not set\n            format!(\"{}/target/debug/build/tree-sitter-*/out\", dir.display())\n        }),\n    );\n\n    // Compile tree-sitter parsers\n    println!(\"cargo:rerun-if-changed=build.rs\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-go/src/parser.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-go\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-java/src/parser.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-java\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-javascript/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-javascript/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-javascript\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-python/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-python/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-python\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-rust/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-rust/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-rust\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .include(dir.join(\"tree-sitter-typescript/typescript/src\"))\n        .include(dir.join(\"tree-sitter-typescript/common\"))\n        .file(dir.join(\"tree-sitter-typescript/typescript/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-typescript/typescript/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-typescript\");\n\n    // Add build step for TSX parser\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .include(dir.join(\"tree-sitter-typescript/tsx/src\"))\n        .include(dir.join(\"tree-sitter-typescript/common\"))\n        .file(dir.join(\"tree-sitter-typescript/tsx/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-typescript/tsx/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-tsx\");\n\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-ruby/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-ruby/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-ruby\");\n\n\n    // Add library search path\n    println!(\"cargo:rustc-link-search=native={}\", out_dir.display());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","example","rust-vulnerable-app","src","main.rs"],"content":"use actix_web::{get, web, App, HttpResponse, HttpServer, Responder};\nuse rusqlite::{Connection, Result as SqliteResult};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::process::Command;\n\n// Vulnerable database initialization\nfn init_db() -\u003e SqliteResult\u003c()\u003e {\n    let conn = Connection::open(\"users.db\")?;\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS users ( \\\n            id INTEGER PRIMARY KEY, \\\n            username TEXT NOT NULL, \\\n            password TEXT NOT NULL \\\n        )\",\n        [],\n    )?;\n\n    // Insert default user if not exists\n    conn.execute(\n        \"INSERT OR IGNORE INTO users (id, username, password) VALUES (1, 'admin', 'admin123')\",\n        [],\n    )?;\n\n    Ok(())\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct User {\n    id: i32,\n    username: String,\n    password: String,\n}\n\n// Vulnerability 1: SQL Injection\n#[get(\"/sqli\")]\nasync fn sql_injection(query: web::Query\u003cHashMap\u003cString, String\u003e\u003e) -\u003e impl Responder {\n    let username = query\n        .get(\"username\")\n        .cloned()\n        .unwrap_or_else(|| String::from(\"\"));\n\n    // Vulnerable SQL query - DO NOT USE IN PRODUCTION\n    let query_str = format!(\"SELECT * FROM users WHERE username = '{}'\", username);\n\n    let conn = Connection::open(\"users.db\").unwrap();\n    let mut stmt = conn.prepare(\u0026query_str).unwrap();\n\n    let users: Vec\u003cUser\u003e = stmt\n        .query_map([], |row| {\n            Ok(User {\n                id: row.get(0)?,\n                username: row.get(1)?,\n                password: row.get(2)?,\n            })\n        })\n        .unwrap()\n        .filter_map(|u| u.ok())\n        .collect();\n\n    HttpResponse::Ok().json(users)\n}\n\n// Vulnerability 2: Command Injection\n#[get(\"/cmdi\")]\nasync fn command_injection(query: web::Query\u003cHashMap\u003cString, String\u003e\u003e) -\u003e impl Responder {\n    let hostname = query\n        .get(\"hostname\")\n        .cloned()\n        .unwrap_or_else(|| String::from(\"localhost\"));\n\n    // Vulnerable command execution - DO NOT USE IN PRODUCTION\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(format!(\"ping -c 1 {}\", hostname))\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let result = String::from_utf8_lossy(\u0026output.stdout);\n\n    HttpResponse::Ok().body(result.to_string())\n}\n\n// Vulnerability 3: Path Traversal\n#[get(\"/file\")]\nasync fn file_read(query: web::Query\u003cHashMap\u003cString, String\u003e\u003e) -\u003e impl Responder {\n    let filename = query\n        .get(\"name\")\n        .cloned()\n        .unwrap_or_else(|| String::from(\"default.txt\"));\n\n    // Vulnerable file read - DO NOT USE IN PRODUCTION\n    match std::fs::read_to_string(\u0026filename) {\n        Ok(content) =\u003e HttpResponse::Ok().body(content),\n        Err(e) =\u003e HttpResponse::InternalServerError().body(e.to_string()),\n    }\n}\n\n#[actix_web::main]\nasync fn main() -\u003e std::io::Result\u003c()\u003e {\n    // Initialize database\n    init_db().expect(\"Failed to initialize database\");\n\n    println!(\"Starting server at http://127.0.0.1:8080\");\n\n    HttpServer::new(|| {\n        App::new()\n            .service(sql_injection)\n            .service(command_injection)\n            .service(file_read)\n            .route(\n                \"/\",\n                web::get().to(|| async {\n                    HttpResponse::Ok().body(\n                        r#\"\n                    \u003ch1\u003eVulnerable Rust Application\u003c/h1\u003e\n                    \u003cul\u003e\n                        \u003cli\u003e\u003ca href=\"/sqli?username=admin\"\u003eSQL Injection\u003c/a\u003e\u003c/li\u003e\n                        \u003cli\u003e\u003ca href=\"/cmdi?hostname=localhost\"\u003eCommand Injection\u003c/a\u003e\u003c/li\u003e\n                        \u003cli\u003e\u003ca href=\"/file?name=README.md\"\u003ePath Traversal\u003c/a\u003e\u003c/li\u003e\n                    \u003c/ul\u003e\n                    \"#,\n                    )\n                }),\n            )\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","analyzer.rs"],"content":"use anyhow::{Error, Result};\nuse genai::chat::{ChatMessage, ChatOptions, ChatRequest, JsonSpec};\nuse genai::{Client, ClientConfig};\nuse log::{debug, error, info, warn};\nuse regex::escape;\nuse serde::de::DeserializeOwned;\nuse std::path::PathBuf;\n\nuse crate::parser::CodeParser;\nuse crate::prompts::{self, vuln_specific};\nuse crate::response::{response_json_schema, Response};\nuse crate::security_patterns::{SecurityRiskPatterns, PatternType, Language};\n\nfn create_api_client() -\u003e Client {\n    let client_config = ClientConfig::default().with_chat_options(\n        ChatOptions::default()\n            .with_response_format(JsonSpec::new(\"json_object\", response_json_schema())),\n    );\n    Client::builder().with_config(client_config).build()\n}\n\nasync fn execute_chat_request(\n    client: \u0026Client,\n    model: \u0026str,\n    chat_req: ChatRequest,\n) -\u003e Result\u003cString\u003e {\n    let chat_res = client.exec_chat(model, chat_req, None).await?;\n    match chat_res.content_text_as_str() {\n        Some(content) =\u003e Ok(content.to_string()),\n        None =\u003e {\n            error!(\"Failed to get content text from chat response\");\n            Err(anyhow::anyhow!(\n                \"Failed to get content text from chat response\"\n            ))\n        }\n    }\n}\n\nfn parse_json_response\u003cT: DeserializeOwned\u003e(chat_content: \u0026str) -\u003e Result\u003cT\u003e {\n    match serde_json::from_str(chat_content) {\n        Ok(response) =\u003e Ok(response),\n        Err(e) =\u003e {\n            debug!(\"Failed to parse JSON response: {}\", e);\n            debug!(\"Response content: {}\", chat_content);\n            Err(anyhow::anyhow!(\"Failed to parse JSON response: {}\", e))\n        }\n    }\n}\n\npub async fn analyze_file(\n    file_path: \u0026PathBuf,\n    model: \u0026str,\n    files: \u0026[PathBuf],\n    verbosity: u8,\n    context: \u0026crate::parser::Context,\n    min_confidence: i32,\n) -\u003e Result\u003cResponse, Error\u003e {\n    info!(\"Performing initial analysis of {}\", file_path.display());\n\n    let mut parser = CodeParser::new()?;\n\n    for file in files {\n        if let Err(e) = parser.add_file(file) {\n            warn!(\n                \"Failed to add file to parser {}: {}. Skipping file.\",\n                file.display(),\n                e\n            );\n        }\n    }\n\n    let content = std::fs::read_to_string(file_path)?;\n    if content.is_empty() {\n        return Ok(Response {\n            scratchpad: String::new(),\n            analysis: String::new(),\n            poc: String::new(),\n            confidence_score: 0,\n            vulnerability_types: vec![],\n            context_code: vec![],\n        });\n    }\n\n    let mut context_text = String::new();\n    if !context.definitions.is_empty() {\n        context_text.push_str(\"\\nContext Definitions:\\n\");\n        for def in \u0026context.definitions {\n            context_text.push_str(\u0026format!(\n                \"\\nFunction/Definition: {}\\nCode:\\n{}\\n\",\n                def.name, def.source\n            ));\n        }\n    }\n\n    let prompt = format!(\n        \"File: {}\\n\\nContent:\\n{}\\n{}\\n\\n{}\\n{}\\n{}\",\n        file_path.display(),\n        content,\n        context_text,\n        prompts::INITIAL_ANALYSIS_PROMPT_TEMPLATE,\n        prompts::ANALYSIS_APPROACH_TEMPLATE,\n        prompts::GUIDELINES_TEMPLATE,\n    );\n    debug!(\"[PROMPT]\\n{}\", prompt);\n\n    let chat_req = ChatRequest::new(vec![\n        ChatMessage::system(\"You are a security vulnerability analyzer. You must reply with exactly one JSON object that matches this schema: { \\\"scratchpad\\\": string, \\\"analysis\\\": string, \\\"poc\\\": string, \\\"confidence_score\\\": integer, \\\"vulnerability_types\\\": array of strings, \\\"context_code\\\": array of objects with { \\\"name\\\": string, \\\"reason\\\": string, \\\"code_line\\\": string } }. Do not include any explanatory text outside the JSON object.\"),\n        ChatMessage::user(\u0026prompt),\n    ]);\n\n    let json_client = create_api_client();\n    let chat_content = execute_chat_request(\u0026json_client, model, chat_req).await?;\n    debug!(\"[LLM Response]\\n{}\", chat_content);\n    let mut response: Response = parse_json_response(\u0026chat_content)?;\n    \n    response.confidence_score = crate::response::Response::normalize_confidence_score(response.confidence_score);\n\n    info!(\"Initial analysis complete\");\n\n    if response.confidence_score \u003e= min_confidence \u0026\u0026 !response.vulnerability_types.is_empty() {\n        let vuln_info_map = vuln_specific::get_vuln_specific_info();\n\n        for vuln_type in response.vulnerability_types.clone() {\n            let vuln_info = vuln_info_map.get(\u0026vuln_type).unwrap();\n\n            let mut stored_code_definitions: Vec\u003c(PathBuf, crate::parser::Definition)\u003e = Vec::new();\n            let previous_analysis = String::new();\n\n            {\n                info!(\n                    \"Performing vuln-specific analysis for {:?}\",\n                    vuln_type\n                );\n                if verbosity \u003e 0 {\n                    println!(\n                        \"🔎 [{}] 脆弱性タイプ: {:?} の詳細解析\",\n                        file_path.display(),\n                        vuln_type\n                    );\n                    if !stored_code_definitions.is_empty() {\n                        println!(\"  解析コンテキスト関数:\");\n                        for (_, def) in \u0026stored_code_definitions {\n                            println!(\"    - {} ({}行)\", def.name, def.source.lines().count());\n                        }\n                    }\n                    println!(\"  考慮バイパス: {}\", vuln_info.bypasses.join(\", \"));\n                    println!(\n                        \"  追加プロンプト: {}\",\n                        \u0026vuln_info.prompt.chars().take(40).collect::\u003cString\u003e()\n                    );\n                }\n\n                let mut context_code = String::new();\n                for (_, def) in \u0026stored_code_definitions {\n                    context_code.push_str(\u0026format!(\n                        \"\\nFunction: {}\\nSource:\\n{}\\n\",\n                        def.name, def.source\n                    ));\n                }\n\n                let prompt = format!(\n                    \"File: {}\\n\\nContent:\\n{}\\n\\nContext Code:\\n{}\\n\\nVulnerability Type: {:?}\\n\\nBypasses to Consider:\\n{}\\n\\n{}\\n{}\\n{}\\nPrevious Analysis:\\n{}\",\n                    file_path.display(),\n                    content,\n                    context_code,\n                    vuln_type,\n                    vuln_info.bypasses.join(\"\\n\"),\n                    vuln_info.prompt,\n                    prompts::ANALYSIS_APPROACH_TEMPLATE,\n                    prompts::GUIDELINES_TEMPLATE,\n                    previous_analysis,\n                );\n\n                let chat_req = ChatRequest::new(vec![\n                    ChatMessage::system(\n                        \"You are a security vulnerability analyzer. You must reply with exactly one JSON object that matches this schema: { \\\"scratchpad\\\": string, \\\"analysis\\\": string, \\\"poc\\\": string, \\\"confidence_score\\\": integer, \\\"vulnerability_types\\\": array of strings, \\\"context_code\\\": array of objects with { \\\"name\\\": string, \\\"reason\\\": string, \\\"code_line\\\": string } }. Do not include any explanatory text outside the JSON object.\",\n                    ),\n                    ChatMessage::user(\u0026prompt),\n                ]);\n\n                let json_client = create_api_client();\n                let chat_content = execute_chat_request(\u0026json_client, model, chat_req).await?;\n                debug!(\"[LLM Response]\\n{}\", chat_content);\n                let mut vuln_response: Response = parse_json_response(\u0026chat_content)?;\n                \n                vuln_response.confidence_score = crate::response::Response::normalize_confidence_score(vuln_response.confidence_score);\n\n                if verbosity \u003e 0 {\n                    debug!(\n                        \"  LLM応答: confidence_score={}, vulnerability_types={:?}\",\n                        vuln_response.confidence_score, vuln_response.vulnerability_types\n                    );\n                    println!(\n                        \"  analysis要約: {}\",\n                        \u0026vuln_response.analysis.chars().take(60).collect::\u003cString\u003e()\n                    );\n                    if !vuln_response.context_code.is_empty() {\n                        println!(\"  context_code:\");\n                        for ctx in \u0026vuln_response.context_code {\n                            println!(\"    - {}: {}\", ctx.name, ctx.reason);\n                        }\n                    }\n                    return Ok(vuln_response);\n                }\n\n                if vuln_response.context_code.is_empty() {\n                    if verbosity == 0 {\n                        return Ok(vuln_response);\n                    }\n                    break;\n                }\n\n                // Get language for pattern detection\n                let file_extension = file_path.extension()\n                    .and_then(|ext| ext.to_str())\n                    .unwrap_or(\"\");\n                let language = Language::from_extension(file_extension);\n                let patterns = SecurityRiskPatterns::new(language);\n\n                for context in vuln_response.context_code {\n                    let escaped_name = escape(\u0026context.name);\n                    if !stored_code_definitions\n                        .iter()\n                        .any(|(_, def)| def.name == escaped_name)\n                    {\n                        // Determine pattern type to choose appropriate search method\n                        let pattern_type = patterns.get_pattern_type(\u0026context.name);\n                        \n                        match pattern_type {\n                            Some(PatternType::Source) =\u003e {\n                                // For sources, use find_references to track data flow forward\n                                match parser.find_references(\u0026escaped_name) {\n                                    Ok(refs) =\u003e {\n                                        stored_code_definitions.extend(refs);\n                                    }\n                                    Err(e) =\u003e {\n                                        warn!(\n                                            \"Failed to find references for source context {}: {}\",\n                                            escaped_name, e\n                                        );\n                                    }\n                                }\n                            }\n                            Some(PatternType::Sink) | Some(PatternType::Validate) | None =\u003e {\n                                // For sinks, validate patterns, or unknown patterns, use find_definition\n                                match parser.find_definition(\u0026escaped_name, file_path) {\n                                    Ok(Some(def)) =\u003e {\n                                        stored_code_definitions.push(def);\n                                    }\n                                    Ok(None) =\u003e {\n                                        debug!(\"No definition found for context: {}\", escaped_name);\n                                    }\n                                    Err(e) =\u003e {\n                                        warn!(\n                                            \"Failed to find definition for context {}: {}\",\n                                            escaped_name, e\n                                        );\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // previous_analysis = vuln_response.analysis; // TODO: Use this variable or remove it\n\n            }\n        }\n    }\n    Ok(response)\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":145},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","lib.rs"],"content":"pub mod analyzer;\npub mod parser;\npub mod pattern_generator;\npub mod prompts;\npub mod repo;\npub mod repo_clone;\npub mod response;\npub mod security_patterns;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","main.rs"],"content":"use anyhow::Result;\nuse clap::Parser;\nuse dotenv::dotenv;\nuse std::path::PathBuf;\nuse vulnhuntrs::analyzer::analyze_file;\nuse vulnhuntrs::pattern_generator::generate_custom_patterns;\nuse vulnhuntrs::security_patterns::Language;\nuse vulnhuntrs::security_patterns::SecurityRiskPatterns;\n\nuse vulnhuntrs::repo::RepoOps;\nuse vulnhuntrs::repo_clone::clone_github_repo;\nuse vulnhuntrs::response::{AnalysisSummary, VulnType};\n\nuse futures::future::join_all;\nuse std::sync::Arc;\n\n#[derive(Parser, Debug)]\n#[command(\n    author,\n    version,\n    about,\n    long_about = None,\n    group = clap::ArgGroup::new(\"target\")\n        .required(true)\n        .args(\u0026[\"root\", \"repo\"])\n)]\nstruct Args {\n    /// Path to the root directory of the project\n    #[arg(short, long, group = \"target\")]\n    root: Option\u003cPathBuf\u003e,\n\n    /// GitHub repository (owner/repo or URL)\n    #[arg(long, group = \"target\")]\n    repo: Option\u003cString\u003e,\n\n    /// Specific path or file within the project to analyze\n    #[arg(short, long)]\n    analyze: Option\u003cPathBuf\u003e,\n\n    /// LLM model to use (default: o4-mini)\n    #[arg(short, long, default_value = \"o4-mini\")]\n    model: String,\n\n    /// Increase output verbosity\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    verbosity: u8,\n\n    /// Enable evaluation mode for example vulnerable apps\n    #[arg(short, long)]\n    evaluate: bool,\n\n    /// Output directory for markdown reports\n    #[arg(long)]\n    output_dir: Option\u003cPathBuf\u003e,\n    \n    /// 最小信頼度スコア（これ以上のスコアを持つ脆弱性のみ表示）\n    #[arg(long, default_value = \"0\")]\n    min_confidence: i32,\n    \n    /// 特定の脆弱性タイプでフィルタリング（カンマ区切りで複数指定可）\n    #[arg(long)]\n    vuln_types: Option\u003cString\u003e,\n    \n    /// サマリーレポートを生成する\n    #[arg(long)]\n    summary: bool,\n    \n    /// カスタムパターンを生成する（現在のディレクトリを解析してセキュリティパターンを自動検出）\n    #[arg(long)]\n    generate_patterns: bool,\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    env_logger::init();\n    dotenv().ok();\n\n    let args = Args::parse();\n\n    let root_dir = if let Some(repo) = \u0026args.repo {\n        let dest = PathBuf::from(\"repo\");\n        if dest.exists() {\n            std::fs::remove_dir_all(\u0026dest)\n                .map_err(|e| anyhow::anyhow!(\"クローン先ディレクトリの削除に失敗: {}\", e))?;\n        }\n        println!(\n            \"🛠️  GitHubリポジトリをクローン中: {} → {}\",\n            repo,\n            dest.display()\n        );\n        clone_github_repo(repo, \u0026dest)\n            .map_err(|e| anyhow::anyhow!(\"GitHubリポジトリのクローンに失敗: {}\", e))?;\n        dest\n    } else if let Some(root) = \u0026args.root {\n        root.clone()\n    } else {\n        panic!(\"root path or repo must be set\");\n    };\n\n    let repo = RepoOps::new(root_dir.clone());\n\n    println!(\"🔍 Vulnhuntrs - セキュリティ解析ツール\");\n\n    // Handle pattern generation mode\n    if args.generate_patterns {\n        println!(\"🔧 カスタムパターン生成モードを開始します\");\n        return generate_custom_patterns(\u0026root_dir, \u0026args.model).await;\n    }\n\n    let files = repo.get_relevant_files();\n    println!(\n        \"📁 関連するソースファイルを検出しました ({}件)\",\n        files.len()\n    );\n    for (i, f) in files.iter().enumerate() {\n        println!(\"  [{}] {}\", i + 1, f.display());\n    }\n\n    let mut pattern_files = Vec::new();\n    for file_path in \u0026files {\n        if let Ok(content) = std::fs::read_to_string(file_path) {\n            let ext = file_path\n                .extension()\n                .and_then(|e| e.to_str())\n                .unwrap_or(\"\");\n            let lang = Language::from_extension(ext);\n            let patterns = SecurityRiskPatterns::new(lang);\n            if patterns.matches(\u0026content) {\n                pattern_files.push(file_path.clone());\n            }\n        }\n    }\n\n    println!(\n        \"🔎 セキュリティパターン該当ファイルを検出しました ({}件)\",\n        pattern_files.len()\n    );\n    for (i, f) in pattern_files.iter().enumerate() {\n        println!(\"  [P{}] {}\", i + 1, f.display());\n    }\n\n    let total = pattern_files.len();\n    let root_dir = Arc::new(root_dir);\n    let output_dir = args.output_dir.clone();\n    let model = args.model.clone();\n    let files = files.clone();\n    let verbosity = args.verbosity;\n\n    let mut summary = AnalysisSummary::new();\n\n    let tasks = pattern_files.iter().enumerate().map(|(idx, file_path)| {\n        let file_path = file_path.clone();\n        let root_dir = Arc::clone(\u0026root_dir);\n        let output_dir = output_dir.clone();\n        let model = model.clone();\n        let files = files.clone();\n\n        tokio::spawn(async move {\n            let file_name = file_path.display().to_string();\n            println!(\"📄 解析対象: {} ({} / {})\", file_name, idx + 1, total);\n            println!(\"{}\", \"=\".repeat(80));\n\n            let mut repo = RepoOps::new((*root_dir).clone());\n            if let Err(e) = repo.add_file_to_parser(\u0026file_path) {\n                println!(\"❌ ファイルのパース追加に失敗: {}: {}\", file_path.display(), e);\n                return None;\n            }\n            let context = match repo.collect_context_for_security_pattern(\u0026file_path) {\n                Ok(ctx) =\u003e ctx,\n                Err(e) =\u003e {\n                    println!(\"❌ コンテキスト収集に失敗: {}: {}\", file_path.display(), e);\n                    return None;\n                }\n            };\n\n            let analysis_result = match analyze_file(\u0026file_path, \u0026model, \u0026files, verbosity, \u0026context, 0).await {\n                Ok(res) =\u003e res,\n                Err(e) =\u003e {\n                    println!(\"❌ 解析に失敗: {}: {}\", file_path.display(), e);\n                    return None;\n                }\n            };\n\n            if let Some(ref output_dir) = output_dir {\n                if let Err(e) = std::fs::create_dir_all(output_dir) {\n                    println!(\"❌ 出力ディレクトリ作成に失敗: {}: {}\", output_dir.display(), e);\n                    return None;\n                }\n                let fname = file_path\n                    .file_name()\n                    .map(|n| n.to_string_lossy().to_string() + \".md\")\n                    .unwrap_or_else(|| \"report.md\".to_string());\n                let mut out_path = output_dir.clone();\n                out_path.push(fname);\n                if let Err(e) = std::fs::write(\u0026out_path, analysis_result.to_markdown()) {\n                    println!(\"❌ Markdownレポート出力に失敗: {}: {}\", out_path.display(), e);\n                    return None;\n                }\n                println!(\"📝 Markdownレポートを出力: {}\", out_path.display());\n            }\n\n            analysis_result.print_readable();\n            \n            Some((file_path, analysis_result))\n        })\n    });\n\n    let results = join_all(tasks).await;\n    for (file_path, response) in results.into_iter().flatten().flatten() {\n        summary.add_result(file_path, response);\n    }\n    \n    summary.sort_by_confidence();\n    \n    let mut filtered_summary = if args.min_confidence \u003e 0 {\n        summary.filter_by_min_confidence(args.min_confidence)\n    } else {\n        summary\n    };\n    \n    if let Some(types_str) = args.vuln_types {\n        let vuln_types: Vec\u003cVulnType\u003e = types_str\n            .split(',')\n            .map(|s| match s.trim() {\n                \"LFI\" =\u003e VulnType::LFI,\n                \"RCE\" =\u003e VulnType::RCE,\n                \"SSRF\" =\u003e VulnType::SSRF,\n                \"AFO\" =\u003e VulnType::AFO,\n                \"SQLI\" =\u003e VulnType::SQLI,\n                \"XSS\" =\u003e VulnType::XSS,\n                \"IDOR\" =\u003e VulnType::IDOR,\n                other =\u003e VulnType::Other(other.to_string()),\n            })\n            .collect();\n        \n        filtered_summary = filtered_summary.filter_by_vuln_types(\u0026vuln_types);\n    }\n    \n    if args.summary {\n        if let Some(ref output_dir) = args.output_dir {\n            if let Err(e) = std::fs::create_dir_all(output_dir) {\n                println!(\"❌ 出力ディレクトリ作成に失敗: {}: {}\", output_dir.display(), e);\n            } else {\n                let mut summary_path = output_dir.clone();\n                summary_path.push(\"summary.md\");\n                if let Err(e) = std::fs::write(\u0026summary_path, filtered_summary.to_markdown()) {\n                    println!(\"❌ サマリーレポート出力に失敗: {}: {}\", summary_path.display(), e);\n                } else {\n                    println!(\"📊 サマリーレポートを出力: {}\", summary_path.display());\n                }\n            }\n        } else {\n            println!(\"⚠ サマリーレポートを出力するには --output-dir オプションが必要です\");\n        }\n    }\n\n    println!(\"✅ 解析が完了しました\");\n\n    Ok(())\n}\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":122},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","parser.rs"],"content":"use anyhow::{anyhow, Result};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse streaming_iterator::StreamingIterator;\nunsafe extern \"C\" {\n    fn tree_sitter_rust() -\u003e tree_sitter::Language;\n}\nuse tree_sitter::{Language, Node, Parser, Query, QueryCursor};\n\nunsafe extern \"C\" {\n    fn tree_sitter_python() -\u003e Language;\n    fn tree_sitter_javascript() -\u003e Language;\n    fn tree_sitter_typescript() -\u003e Language;\n    fn tree_sitter_tsx() -\u003e Language;\n    fn tree_sitter_java() -\u003e Language;\n    fn tree_sitter_go() -\u003e Language;\n    fn tree_sitter_ruby() -\u003e Language;\n\n}\n\n#[derive(Debug, Clone)]\npub struct Definition {\n    pub name: String,\n    pub start_byte: usize,\n    pub end_byte: usize,\n    pub source: String,\n}\n\n#[derive(Debug, Clone)]\npub struct Context {\n    pub definitions: Vec\u003cDefinition\u003e,\n}\n\npub struct CodeParser {\n    pub files: HashMap\u003cPathBuf, String\u003e,\n    pub parser: Parser,\n}\n\nimpl CodeParser {\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        Ok(Self {\n            files: HashMap::new(),\n            parser: Parser::new(),\n        })\n    }\n\n    pub fn add_file(\u0026mut self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        let content = fs::read_to_string(path).map_err(|e| {\n            anyhow!(\n                \"ファイルの読み込みに失敗しました: {}: {}\",\n                path.display(),\n                e\n            )\n        })?;\n        self.files.insert(path.to_path_buf(), content.clone());\n        Ok(())\n    }\n\n    fn get_language(\u0026self, path: \u0026Path) -\u003e Option\u003cLanguage\u003e {\n        let extension = path.extension().and_then(|ext| ext.to_str());\n        match extension {\n            Some(\"py\") =\u003e Some(unsafe { tree_sitter_python() }),\n            Some(\"js\") =\u003e Some(unsafe { tree_sitter_javascript() }),\n            Some(\"ts\") =\u003e Some(unsafe { tree_sitter_typescript() }),\n            Some(\"tsx\") =\u003e Some(unsafe { tree_sitter_tsx() }),\n            Some(\"java\") =\u003e Some(unsafe { tree_sitter_java() }),\n            Some(\"rs\") =\u003e Some(unsafe { tree_sitter_rust() }),\n            Some(\"go\") =\u003e Some(unsafe { tree_sitter_go() }),\n            Some(\"rb\") =\u003e Some(unsafe { tree_sitter_ruby() }),\n            _ =\u003e None,\n        }\n    }\n\n    fn get_query_path(\u0026self, language: \u0026Language, query_name: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        let lang_name = if language == \u0026unsafe { tree_sitter_python() } {\n            \"python\"\n        } else if language == \u0026unsafe { tree_sitter_javascript() } {\n            \"javascript\"\n        } else if language == \u0026unsafe { tree_sitter_typescript() }\n            || language == \u0026unsafe { tree_sitter_tsx() }\n        {\n            \"typescript\"\n        } else if language == \u0026unsafe { tree_sitter_java() } {\n            \"java\"\n        }\n        else if language == \u0026unsafe { tree_sitter_go() } {\n            \"go\"\n        } else if language == \u0026unsafe { tree_sitter_rust() } {\n            \"rust\"\n        } else if language == \u0026unsafe { tree_sitter_ruby() } {\n            \"ruby\"\n        } else {\n            return Err(anyhow!(\"クエリに対応していない言語です\"));\n        };\n\n        if lang_name.contains('/') || lang_name.contains('\\\\') || lang_name.contains(\"..\") {\n            return Err(anyhow!(\"クエリパスの言語名が不正です: {}\", lang_name));\n        }\n        if query_name.contains('/') || query_name.contains('\\\\') || query_name.contains(\"..\") {\n            return Err(anyhow!(\"クエリパスのクエリ名が不正です: {}\", query_name));\n        }\n\n        let manifest_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        let query_file_name = format!(\"{}.scm\", query_name);\n        let query_path = manifest_dir\n            .join(\"custom_queries\")\n            .join(lang_name)\n            .join(\u0026query_file_name);\n\n        if !query_path.exists() {\n            return Err(anyhow!(\n                \"クエリファイルが見つかりません: {}\",\n                query_path.display()\n            ));\n        }\n\n        Ok(query_path)\n    }\n\n    pub fn find_definition(\n        \u0026mut self,\n        name: \u0026str,\n        source_file: \u0026Path,\n    ) -\u003e Result\u003cOption\u003c(PathBuf, Definition)\u003e\u003e {\n        let content = self.files.get(source_file).ok_or_else(|| {\n            anyhow!(\n                \"パーサーにファイルが見つかりません: {}\",\n                source_file.display()\n            )\n        })?;\n\n        let language = match self.get_language(source_file) {\n            Some(lang) =\u003e lang,\n            None =\u003e return Ok(None),\n        };\n\n        self.parser\n            .set_language(\u0026language)\n            .map_err(|e| anyhow!(\"言語の設定に失敗しました: {}\", e))?;\n\n        let tree = self\n            .parser\n            .parse(content, None)\n            .ok_or_else(|| anyhow!(\"ファイルのパースに失敗しました: {}\", source_file.display()))?;\n\n        let query_path = self.get_query_path(\u0026language, \"definitions\")?;\n        let query_str = fs::read_to_string(\u0026query_path).map_err(|e| {\n            anyhow!(\n                \"クエリファイルの読み込みに失敗しました: {}: {}\",\n                query_path.display(),\n                e\n            )\n        })?;\n\n        let query = Query::new(\u0026language, \u0026query_str).map_err(|e| {\n            anyhow!(\n                \"クエリの生成に失敗しました: {}: {}\",\n                query_path.display(),\n                e\n            )\n        })?;\n\n        let mut query_cursor = QueryCursor::new();\n        let mut matches = query_cursor.matches(\u0026query, tree.root_node(), content.as_bytes());\n\n        while let Some(mat) = matches.next() {\n            let mut definition_node: Option\u003cNode\u003e = None;\n            let mut name_node: Option\u003cNode\u003e = None;\n\n            for cap in mat.captures {\n                let capture_name = \u0026query.capture_names()[cap.index as usize];\n                match capture_name {\n                    s if *s == \"definition\" =\u003e definition_node = Some(cap.node),\n                    s if *s == \"name\" =\u003e name_node = Some(cap.node),\n                    _ =\u003e {}\n                }\n            }\n\n            if let (Some(def_node), Some(name_node_inner)) = (definition_node, name_node) {\n                if name_node_inner.utf8_text(content.as_bytes())? == name {\n                    let start_byte = def_node.start_byte();\n                    let end_byte = def_node.end_byte();\n                    let source = def_node.utf8_text(content.as_bytes())?.to_string();\n\n                    let definition = Definition {\n                        name: name.to_string(),\n                        start_byte,\n                        end_byte,\n                        source,\n                    };\n                    return Ok(Some((source_file.to_path_buf(), definition)));\n                }\n            }\n        }\n\n        Ok(None)\n    }\n\n    pub fn find_references(\u0026mut self, name: \u0026str) -\u003e Result\u003cVec\u003c(PathBuf, Definition)\u003e\u003e {\n        let mut results = Vec::new();\n\n        for (file_path, content) in \u0026self.files {\n            let language = match self.get_language(file_path) {\n                Some(lang) =\u003e lang,\n                None =\u003e continue,\n            };\n\n            self.parser.set_language(\u0026language).map_err(|e| {\n                anyhow!(\"Failed to set language for {}: {}\", file_path.display(), e)\n            })?;\n\n            let tree = match self.parser.parse(content, None) {\n                Some(t) =\u003e t,\n                None =\u003e {\n                    eprintln!(\n                        \"警告: ファイルのパースに失敗しました: {}\",\n                        file_path.display()\n                    );\n                    continue;\n                }\n            };\n\n            let query_path = match self.get_query_path(\u0026language, \"references\") {\n                Ok(p) =\u003e p,\n                Err(e) =\u003e {\n                    eprintln!(\n                        \"警告: 参照クエリパスの取得に失敗しました: {}: {}\",\n                        file_path.display(),\n                        e\n                    );\n                    continue;\n                }\n            };\n            let query_str = match fs::read_to_string(\u0026query_path) {\n                Ok(s) =\u003e s,\n                Err(e) =\u003e {\n                    eprintln!(\n                        \"警告: 参照クエリファイルの読み込みに失敗しました: {}: {}\",\n                        query_path.display(),\n                        e\n                    );\n                    continue;\n                }\n            };\n\n            let query = match Query::new(\u0026language, \u0026query_str) {\n                Ok(q) =\u003e q,\n                Err(e) =\u003e {\n                    eprintln!(\n                        \"警告: 参照クエリの生成に失敗しました: {}: {}\",\n                        query_path.display(),\n                        e\n                    );\n                    continue;\n                }\n            };\n\n            let mut query_cursor = QueryCursor::new();\n            let mut matches = query_cursor.matches(\u0026query, tree.root_node(), content.as_bytes());\n\n            while let Some(mat) = matches.next() {\n                for cap in mat.captures {\n                    if query.capture_names()[cap.index as usize] == \"reference\" {\n                        let node = cap.node;\n                        if node.utf8_text(content.as_bytes())? == name {\n                            let start_byte = node.start_byte();\n                            let end_byte = node.end_byte();\n                            let source = name.to_string();\n\n                            results.push((\n                                file_path.clone(),\n                                Definition {\n                                    name: name.to_string(),\n                                    start_byte,\n                                    end_byte,\n                                    source,\n                                },\n                            ));\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(results)\n    }\n    pub fn build_context_from_file(\u0026mut self, start_path: \u0026Path) -\u003e Result\u003cContext\u003e {\n        use std::collections::HashSet;\n\n        let mut collected: HashSet\u003cString\u003e = HashSet::new();\n        let mut definitions: Vec\u003cDefinition\u003e = Vec::new();\n\n        let file_content = self\n            .files\n            .get(start_path)\n            .ok_or_else(|| anyhow::anyhow!(\"ファイルが見つかりません: {}\", start_path.display()))?;\n        let language = self\n            .get_language(start_path)\n            .ok_or_else(|| anyhow::anyhow!(\"言語が特定できません: {}\", start_path.display()))?;\n        self.parser\n            .set_language(\u0026language)\n            .map_err(|e| anyhow::anyhow!(\"言語の設定に失敗: {}\", e))?;\n        let tree = self\n            .parser\n            .parse(file_content, None)\n            .ok_or_else(|| anyhow::anyhow!(\"パース失敗: {}\", start_path.display()))?;\n\n        let query_path = self.get_query_path(\u0026language, \"definitions\")?;\n        let query_str = std::fs::read_to_string(\u0026query_path)?;\n        let query = tree_sitter::Query::new(\u0026language, \u0026query_str)?;\n\n        let mut query_cursor = tree_sitter::QueryCursor::new();\n        let mut matches = query_cursor.matches(\u0026query, tree.root_node(), file_content.as_bytes());\n\n        let mut to_visit: Vec\u003c(PathBuf, String)\u003e = Vec::new();\n\n        while let Some(mat) = matches.next() {\n            let mut def_node: Option\u003ctree_sitter::Node\u003e = None;\n            let mut name_node: Option\u003ctree_sitter::Node\u003e = None;\n            for cap in mat.captures {\n                let capture_name = \u0026query.capture_names()[cap.index as usize];\n                match \u0026capture_name[..] {\n                    \"definition\" =\u003e def_node = Some(cap.node),\n                    \"name\" =\u003e name_node = Some(cap.node),\n                    _ =\u003e {}\n                }\n            }\n            if let (Some(def_node), Some(name_node)) = (def_node, name_node) {\n                let name = name_node.utf8_text(file_content.as_bytes())?.to_string();\n                if !collected.contains(\u0026name) {\n                    let start_byte = def_node.start_byte();\n                    let end_byte = def_node.end_byte();\n                    let source = def_node.utf8_text(file_content.as_bytes())?.to_string();\n                    definitions.push(Definition {\n                        name: name.clone(),\n                        start_byte,\n                        end_byte,\n                        source,\n                    });\n                    collected.insert(name.clone());\n                    to_visit.push((start_path.to_path_buf(), name));\n                }\n            }\n        }\n\n        while let Some((file_path, func_name)) = to_visit.pop() {\n            if let Some((_, def)) = self.find_definition(\u0026func_name, \u0026file_path)? {\n                // referencesクエリで呼び出し先を抽出\n                let refs = self.find_references(\u0026def.name)?;\n                for (ref_file, ref_def) in refs {\n                    if !collected.contains(\u0026ref_def.name) {\n                        definitions.push(ref_def.clone());\n                        collected.insert(ref_def.name.clone());\n                        to_visit.push((ref_file, ref_def.name.clone()));\n                    }\n                }\n            }\n        }\n\n        Ok(Context { definitions })\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":22}},{"line":61,"address":[],"length":0,"stats":{"Line":66}},{"line":62,"address":[],"length":0,"stats":{"Line":22}},{"line":63,"address":[],"length":0,"stats":{"Line":44}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":22}},{"line":76,"address":[],"length":0,"stats":{"Line":44}},{"line":77,"address":[],"length":0,"stats":{"Line":22}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":44}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":66}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":22}},{"line":105,"address":[],"length":0,"stats":{"Line":22}},{"line":106,"address":[],"length":0,"stats":{"Line":22}},{"line":108,"address":[],"length":0,"stats":{"Line":22}},{"line":109,"address":[],"length":0,"stats":{"Line":22}},{"line":111,"address":[],"length":0,"stats":{"Line":22}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":22}},{"line":121,"address":[],"length":0,"stats":{"Line":10}},{"line":126,"address":[],"length":0,"stats":{"Line":20}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":10}},{"line":134,"address":[],"length":0,"stats":{"Line":10}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":10}},{"line":140,"address":[],"length":0,"stats":{"Line":20}},{"line":142,"address":[],"length":0,"stats":{"Line":20}},{"line":143,"address":[],"length":0,"stats":{"Line":10}},{"line":144,"address":[],"length":0,"stats":{"Line":10}},{"line":145,"address":[],"length":0,"stats":{"Line":10}},{"line":147,"address":[],"length":0,"stats":{"Line":10}},{"line":148,"address":[],"length":0,"stats":{"Line":10}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":10}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":60}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":150}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":60}},{"line":175,"address":[],"length":0,"stats":{"Line":90}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":60}},{"line":181,"address":[],"length":0,"stats":{"Line":60}},{"line":182,"address":[],"length":0,"stats":{"Line":10}},{"line":183,"address":[],"length":0,"stats":{"Line":10}},{"line":184,"address":[],"length":0,"stats":{"Line":20}},{"line":187,"address":[],"length":0,"stats":{"Line":10}},{"line":192,"address":[],"length":0,"stats":{"Line":10}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":10}},{"line":201,"address":[],"length":0,"stats":{"Line":10}},{"line":203,"address":[],"length":0,"stats":{"Line":30}},{"line":204,"address":[],"length":0,"stats":{"Line":10}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":20}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":10}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":10}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":10}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":850}},{"line":263,"address":[],"length":0,"stats":{"Line":1260}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":420}},{"line":266,"address":[],"length":0,"stats":{"Line":850}},{"line":267,"address":[],"length":0,"stats":{"Line":10}},{"line":268,"address":[],"length":0,"stats":{"Line":10}},{"line":269,"address":[],"length":0,"stats":{"Line":10}},{"line":271,"address":[],"length":0,"stats":{"Line":10}},{"line":272,"address":[],"length":0,"stats":{"Line":10}},{"line":273,"address":[],"length":0,"stats":{"Line":10}},{"line":274,"address":[],"length":0,"stats":{"Line":10}},{"line":275,"address":[],"length":0,"stats":{"Line":10}},{"line":276,"address":[],"length":0,"stats":{"Line":10}},{"line":277,"address":[],"length":0,"stats":{"Line":10}},{"line":286,"address":[],"length":0,"stats":{"Line":10}},{"line":288,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":2}},{"line":292,"address":[],"length":0,"stats":{"Line":2}},{"line":294,"address":[],"length":0,"stats":{"Line":4}},{"line":295,"address":[],"length":0,"stats":{"Line":2}},{"line":296,"address":[],"length":0,"stats":{"Line":2}},{"line":297,"address":[],"length":0,"stats":{"Line":4}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":2}},{"line":306,"address":[],"length":0,"stats":{"Line":2}},{"line":307,"address":[],"length":0,"stats":{"Line":2}},{"line":309,"address":[],"length":0,"stats":{"Line":2}},{"line":310,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":22}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":50}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":10}},{"line":325,"address":[],"length":0,"stats":{"Line":20}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":20}},{"line":330,"address":[],"length":0,"stats":{"Line":20}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":10}},{"line":333,"address":[],"length":0,"stats":{"Line":10}},{"line":334,"address":[],"length":0,"stats":{"Line":20}},{"line":335,"address":[],"length":0,"stats":{"Line":10}},{"line":336,"address":[],"length":0,"stats":{"Line":10}},{"line":337,"address":[],"length":0,"stats":{"Line":10}},{"line":338,"address":[],"length":0,"stats":{"Line":10}},{"line":339,"address":[],"length":0,"stats":{"Line":10}},{"line":341,"address":[],"length":0,"stats":{"Line":10}},{"line":342,"address":[],"length":0,"stats":{"Line":10}},{"line":347,"address":[],"length":0,"stats":{"Line":22}},{"line":348,"address":[],"length":0,"stats":{"Line":10}},{"line":350,"address":[],"length":0,"stats":{"Line":20}},{"line":351,"address":[],"length":0,"stats":{"Line":30}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":2}}],"covered":106,"coverable":210},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","pattern_generator.rs"],"content":"use anyhow::Result;\nuse genai::chat::{ChatMessage, ChatOptions, ChatRequest, JsonSpec};\nuse genai::{Client, ClientConfig};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n#[allow(unused_imports)]\nuse std::path::{Path, PathBuf};\n\nuse crate::repo::RepoOps;\nuse crate::security_patterns::Language;\n\n#[derive(Serialize, Deserialize, Debug)]\npub struct PatternClassification {\n    pub function_name: String,\n    pub pattern_type: Option\u003cString\u003e,\n    pub pattern: String,\n    pub description: String,\n    pub reasoning: String,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct PatternAnalysisResponse {\n    patterns: Vec\u003cPatternClassification\u003e,\n}\n\npub async fn generate_custom_patterns(root_dir: \u0026Path, model: \u0026str) -\u003e Result\u003c()\u003e {\n    println!(\"📂 ディレクトリを解析してdefinitionsを抽出中: {}\", root_dir.display());\n    \n    let repo = RepoOps::new(root_dir.to_path_buf());\n    let files = repo.get_files_to_analyze(None)?;\n    \n    println!(\"📁 検出されたファイル数: {}\", files.len());\n    for file in \u0026files {\n        println!(\"   - {}\", file.display());\n    }\n    \n    let mut all_definitions = Vec::new();\n    let mut languages_found = HashMap::new();\n    \n    for file_path in \u0026files {\n        let mut parser = crate::parser::CodeParser::new()?;\n        if let Err(e) = parser.add_file(file_path) {\n            eprintln!(\"⚠️  ファイルのパース追加に失敗: {}: {}\", file_path.display(), e);\n            continue;\n        }\n        \n        match parser.build_context_from_file(file_path) {\n            Ok(context) =\u003e {\n                let ext = file_path.extension().and_then(|e| e.to_str()).unwrap_or(\"\");\n                let language = Language::from_extension(ext);\n                languages_found.insert(language, true);\n                \n                println!(\"📄 {} (言語: {:?}) から {}個のdefinitionsを検出\", file_path.display(), language, context.definitions.len());\n                if context.definitions.is_empty() {\n                    println!(\"   ⚠️  定義が見つかりませんでした。tree-sitterクエリが適切に動作していない可能性があります。\");\n                } else {\n                    for def in \u0026context.definitions {\n                        println!(\"   - {}\", def.name);\n                    }\n                }\n                for def in context.definitions {\n                    all_definitions.push((def, language));\n                }\n            }\n            Err(e) =\u003e {\n                eprintln!(\"⚠️  コンテキスト収集に失敗: {}: {}\", file_path.display(), e);\n                continue;\n            }\n        }\n    }\n    \n    println!(\"🔍 総計 {}個のdefinitionsを抽出しました\", all_definitions.len());\n    \n    for (language, _) in languages_found {\n        let lang_definitions: Vec\u003c_\u003e = all_definitions.iter()\n            .filter(|(_, lang)| *lang == language)\n            .map(|(def, _)| def)\n            .collect();\n            \n        if lang_definitions.is_empty() {\n            continue;\n        }\n        \n        println!(\"🧠 {:?}言語の{}個のdefinitionsをLLMで分析中...\", language, lang_definitions.len());\n        \n        let patterns = analyze_definitions_for_security_patterns(model, \u0026lang_definitions, language).await?;\n        \n        if !patterns.is_empty() {\n            write_patterns_to_file(root_dir, language, \u0026patterns)?;\n            println!(\"✅ {:?}言語用の{}個のパターンを生成しました\", language, patterns.len());\n        } else {\n            println!(\"ℹ️  {:?}言語でセキュリティパターンは検出されませんでした\", language);\n        }\n    }\n    \n    println!(\"🎉 カスタムパターン生成が完了しました\");\n    Ok(())\n}\n\nasync fn analyze_definitions_for_security_patterns(\n    model: \u0026str,\n    definitions: \u0026[\u0026crate::parser::Definition],\n    language: Language,\n) -\u003e Result\u003cVec\u003cPatternClassification\u003e\u003e {\n    let definitions_text = definitions.iter()\n        .map(|def| format!(\"Function: {}\\nCode:\\n{}\\n---\", def.name, def.source))\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\\n\\n\");\n    \n    let prompt = format!(\n        r#\"Analyze the following function definitions from a {:?} codebase and classify them as security patterns.\n\nFor each function, determine if it should be classified as:\n- \"sources\": Functions that introduce user input, external data, or untrusted data into the application\n- \"sinks\": Functions that can execute, write, or perform dangerous operations with data\n- \"validate\": Functions that validate, sanitize, or secure data\n- null: Functions that don't fit any security pattern category\n\nFor each function that IS a security pattern, generate a regex pattern that would match similar functions.\n\nFunction Definitions:\n{}\n\nReturn a JSON object with this exact structure:\n{{\n  \"patterns\": [\n    {{\n      \"function_name\": \"example_function\",\n      \"pattern_type\": \"sources\",\n      \"pattern\": \"\\\\\\\\bexample_function\\\\\\\\s*\\\\\\\\(\",\n      \"description\": \"Example function description\",\n      \"reasoning\": \"Why this function is classified as this pattern type\"\n    }}\n  ]\n}}\n\nOnly include functions that ARE security patterns (sources, sinks, or validate). Do not include functions that are not security-related.\"#,\n        language, definitions_text\n    );\n    \n    let pattern_schema = serde_json::json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"patterns\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"function_name\": {\"type\": \"string\"},\n                        \"pattern_type\": {\"type\": \"string\", \"enum\": [\"sources\", \"sinks\", \"validate\"]},\n                        \"pattern\": {\"type\": \"string\"},\n                        \"description\": {\"type\": \"string\"},\n                        \"reasoning\": {\"type\": \"string\"}\n                    },\n                    \"required\": [\"function_name\", \"pattern_type\", \"pattern\", \"description\", \"reasoning\"]\n                }\n            }\n        },\n        \"required\": [\"patterns\"]\n    });\n    \n    let client_config = ClientConfig::default().with_chat_options(\n        ChatOptions::default()\n            .with_response_format(JsonSpec::new(\"json_object\", pattern_schema)),\n    );\n    let client = Client::builder().with_config(client_config).build();\n    \n    let chat_req = ChatRequest::new(vec![\n        ChatMessage::system(\"You are a security pattern analyzer. You must reply with exactly one JSON object that matches the specified schema. Do not include any explanatory text outside the JSON object.\"),\n        ChatMessage::user(\u0026prompt),\n    ]);\n    \n    let chat_res = client.exec_chat(model, chat_req, None).await?;\n    let content = chat_res.content_text_as_str()\n        .ok_or_else(|| anyhow::anyhow!(\"Failed to get response content\"))?;\n    \n    println!(\"🔍 LLM Response: {}\", content);\n    \n    let response: PatternAnalysisResponse = serde_json::from_str(content)\n        .map_err(|e| anyhow::anyhow!(\"Failed to parse LLM response: {}. Content: {}\", e, content))?;\n    \n    Ok(response.patterns)\n}\n\npub fn write_patterns_to_file(\n    root_dir: \u0026Path,\n    language: Language,\n    patterns: \u0026[PatternClassification],\n) -\u003e Result\u003c()\u003e {\n    let mut vuln_patterns_path = root_dir.to_path_buf();\n    vuln_patterns_path.push(\"vuln-patterns.yml\");\n    \n    let lang_name = match language {\n        Language::Python =\u003e \"Python\",\n        Language::JavaScript =\u003e \"JavaScript\", \n        Language::TypeScript =\u003e \"TypeScript\",\n        Language::Rust =\u003e \"Rust\",\n        Language::Java =\u003e \"Java\",\n        Language::Go =\u003e \"Go\",\n        Language::Ruby =\u003e \"Ruby\",\n        Language::Other =\u003e return Ok(()),\n    };\n    \n    let mut sources = Vec::new();\n    let mut sinks = Vec::new();\n    let mut validate = Vec::new();\n    \n    for pattern in patterns {\n        match pattern.pattern_type.as_deref() {\n            Some(\"sources\") =\u003e sources.push(pattern),\n            Some(\"sinks\") =\u003e sinks.push(pattern),\n            Some(\"validate\") =\u003e validate.push(pattern),\n            _ =\u003e {}\n        }\n    }\n    \n    let mut yaml_content = format!(\"{}:\\n\", lang_name);\n    \n    if !sources.is_empty() {\n        yaml_content.push_str(\"  sources:\\n\");\n        for pattern in sources {\n            yaml_content.push_str(\u0026format!(\n                \"    - pattern: \\\"{}\\\"\\n      description: \\\"{}\\\"\\n\",\n                pattern.pattern, pattern.description\n            ));\n        }\n    }\n    \n    if !validate.is_empty() {\n        yaml_content.push_str(\"  validate:\\n\");\n        for pattern in validate {\n            yaml_content.push_str(\u0026format!(\n                \"    - pattern: \\\"{}\\\"\\n      description: \\\"{}\\\"\\n\",\n                pattern.pattern, pattern.description\n            ));\n        }\n    }\n    \n    if !sinks.is_empty() {\n        yaml_content.push_str(\"  sinks:\\n\");\n        for pattern in sinks {\n            yaml_content.push_str(\u0026format!(\n                \"    - pattern: \\\"{}\\\"\\n      description: \\\"{}\\\"\\n\",\n                pattern.pattern, pattern.description\n            ));\n        }\n    }\n    \n    if vuln_patterns_path.exists() {\n        let existing_content = std::fs::read_to_string(\u0026vuln_patterns_path)?;\n        let updated_content = format!(\"{}\\n{}\", existing_content, yaml_content);\n        std::fs::write(\u0026vuln_patterns_path, updated_content)?;\n    } else {\n        std::fs::write(\u0026vuln_patterns_path, yaml_content)?;\n    }\n    \n    println!(\"📝 パターンファイルに追記: {}\", vuln_patterns_path.display());\n    Ok(())\n}","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":8}},{"line":190,"address":[],"length":0,"stats":{"Line":8}},{"line":191,"address":[],"length":0,"stats":{"Line":8}},{"line":193,"address":[],"length":0,"stats":{"Line":14}},{"line":194,"address":[],"length":0,"stats":{"Line":6}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":26}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":10}},{"line":211,"address":[],"length":0,"stats":{"Line":10}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":217,"address":[],"length":0,"stats":{"Line":6}},{"line":219,"address":[],"length":0,"stats":{"Line":6}},{"line":220,"address":[],"length":0,"stats":{"Line":2}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":6}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":8}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":4}},{"line":241,"address":[],"length":0,"stats":{"Line":16}},{"line":242,"address":[],"length":0,"stats":{"Line":4}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":249,"address":[],"length":0,"stats":{"Line":6}},{"line":250,"address":[],"length":0,"stats":{"Line":4}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":257,"address":[],"length":0,"stats":{"Line":6}},{"line":258,"address":[],"length":0,"stats":{"Line":6}}],"covered":35,"coverable":125},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","prompts","analysis.rs"],"content":"use crate::response::VulnType;\nuse std::collections::HashMap;\n\npub const SYS_PROMPT_TEMPLATE: \u0026str = r#\"\nあなたはセキュリティ研究者として、コードの脆弱性を分析します。特に以下に注目してください：\n- 入力値の検証とサニタイズ\n- 認証・認可\n- データの取り扱いと漏洩\n- コマンドインジェクションの可能性\n- パストラバーサルの脆弱性\n- その他セキュリティ上重要なパターン\n\"#;\n\npub const INITIAL_ANALYSIS_PROMPT_TEMPLATE: \u0026str = r#\"\n与えられたコードをセキュリティ脆弱性の観点から分析してください。特に以下を考慮してください：\n- ユーザー入力の取り扱いと検証\n- 認証・認可の仕組み\n- データのサニタイズやエスケープ\n- ファイルシステム操作\n- ネットワークリクエストとレスポンス\n- コマンド実行\n- データベースクエリ\n\"#;\n\npub const ANALYSIS_APPROACH_TEMPLATE: \u0026str = r#\"\n以下の手順で分析を進めてください：\n1. エントリポイントとユーザーが制御可能な入力を特定する\n2. アプリケーション内のデータフローを追跡する\n3. セキュリティ上重要な操作を調査する\n4. 既存の防御策を回避する手法（バイパス）を検討する\n5. 潜在的な脆弱性の影響を評価する\n\"#;\n\npub const GUIDELINES_TEMPLATE: \u0026str = r#\"\n以下のガイドラインを遵守してください：\n1. 実際に悪用可能な脆弱性に絞って分析する\n2. 該当するコード箇所や行番号を具体的に示す\n3. アプリケーション全体の文脈を考慮する\n4. コードの可視性や分析の深さに応じて信頼度を評価する\n5. より良い分析のために追加情報が必要な場合はリクエストする\n6. 必ず日本語で応答してください\n\"#;\n\npub mod vuln_specific {\n    use super::*;\n\n    pub struct VulnTypeInfo {\n        pub prompt: String,\n        pub bypasses: Vec\u003cString\u003e,\n    }\n\n    pub fn get_vuln_specific_info() -\u003e HashMap\u003cVulnType, VulnTypeInfo\u003e {\n        let mut map = HashMap::new();\n\n        map.insert(\n            VulnType::LFI,\n            VulnTypeInfo {\n                prompt: \"Analyze for Local File Inclusion vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"Path traversal sequences(../../)\".to_string(),\n                    \"URL encoding\".to_string(),\n                    \"Null byte injection\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::RCE,\n            VulnTypeInfo {\n                prompt: \"Analyze for Remote Code Execution vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"Shell metacharacters for command injection\".to_string(),\n                    \"Python execution vectors\".to_string(),\n                    \"Deserialization attacks\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::SSRF,\n            VulnTypeInfo {\n                prompt: \"Analyze for Server-Side Request Forgery vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"DNS rebinding\".to_string(),\n                    \"IP address encoding tricks\".to_string(),\n                    \"Redirect chain\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::AFO,\n            VulnTypeInfo {\n                prompt: \"Analyze for Arbitrary File Operation vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"Directory traversal sequences\".to_string(),\n                    \"Following symbolic links\".to_string(),\n                    \"Race conditions\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::SQLI,\n            VulnTypeInfo {\n                prompt: \"Analyze for SQL Injection vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"UNION-based injection\".to_string(),\n                    \"Boolean-based blind injection\".to_string(),\n                    \"Time-based blind injection\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::XSS,\n            VulnTypeInfo {\n                prompt: \"Analyze for Cross-Site Scripting vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"HTML entity encoding bypass\".to_string(),\n                    \"JavaScript template injection\".to_string(),\n                    \"DOM-based XSS vectors\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::IDOR,\n            VulnTypeInfo {\n                prompt: \"Analyze for Insecure Direct Object Reference vulnerabilities...\"\n                    .to_string(),\n                bypasses: vec![\n                    \"Parameter tampering\".to_string(),\n                    \"Horizontal privilege escalation\".to_string(),\n                    \"Predictable resource paths\".to_string(),\n                ],\n            },\n        );\n\n        map\n    }\n}\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":14}},{"line":53,"address":[],"length":0,"stats":{"Line":14}},{"line":55,"address":[],"length":0,"stats":{"Line":14}},{"line":56,"address":[],"length":0,"stats":{"Line":14}},{"line":57,"address":[],"length":0,"stats":{"Line":14}},{"line":58,"address":[],"length":0,"stats":{"Line":14}},{"line":59,"address":[],"length":0,"stats":{"Line":14}},{"line":60,"address":[],"length":0,"stats":{"Line":14}},{"line":61,"address":[],"length":0,"stats":{"Line":14}},{"line":62,"address":[],"length":0,"stats":{"Line":14}},{"line":67,"address":[],"length":0,"stats":{"Line":14}},{"line":68,"address":[],"length":0,"stats":{"Line":14}},{"line":69,"address":[],"length":0,"stats":{"Line":14}},{"line":70,"address":[],"length":0,"stats":{"Line":14}},{"line":71,"address":[],"length":0,"stats":{"Line":14}},{"line":72,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":14}},{"line":74,"address":[],"length":0,"stats":{"Line":14}},{"line":79,"address":[],"length":0,"stats":{"Line":14}},{"line":80,"address":[],"length":0,"stats":{"Line":14}},{"line":81,"address":[],"length":0,"stats":{"Line":14}},{"line":82,"address":[],"length":0,"stats":{"Line":14}},{"line":83,"address":[],"length":0,"stats":{"Line":14}},{"line":84,"address":[],"length":0,"stats":{"Line":14}},{"line":85,"address":[],"length":0,"stats":{"Line":14}},{"line":86,"address":[],"length":0,"stats":{"Line":14}},{"line":91,"address":[],"length":0,"stats":{"Line":14}},{"line":92,"address":[],"length":0,"stats":{"Line":14}},{"line":93,"address":[],"length":0,"stats":{"Line":14}},{"line":94,"address":[],"length":0,"stats":{"Line":14}},{"line":95,"address":[],"length":0,"stats":{"Line":14}},{"line":96,"address":[],"length":0,"stats":{"Line":14}},{"line":97,"address":[],"length":0,"stats":{"Line":14}},{"line":98,"address":[],"length":0,"stats":{"Line":14}},{"line":103,"address":[],"length":0,"stats":{"Line":14}},{"line":104,"address":[],"length":0,"stats":{"Line":14}},{"line":105,"address":[],"length":0,"stats":{"Line":14}},{"line":106,"address":[],"length":0,"stats":{"Line":14}},{"line":107,"address":[],"length":0,"stats":{"Line":14}},{"line":108,"address":[],"length":0,"stats":{"Line":14}},{"line":109,"address":[],"length":0,"stats":{"Line":14}},{"line":110,"address":[],"length":0,"stats":{"Line":14}},{"line":115,"address":[],"length":0,"stats":{"Line":14}},{"line":116,"address":[],"length":0,"stats":{"Line":14}},{"line":117,"address":[],"length":0,"stats":{"Line":14}},{"line":118,"address":[],"length":0,"stats":{"Line":14}},{"line":119,"address":[],"length":0,"stats":{"Line":14}},{"line":120,"address":[],"length":0,"stats":{"Line":14}},{"line":121,"address":[],"length":0,"stats":{"Line":14}},{"line":122,"address":[],"length":0,"stats":{"Line":14}},{"line":127,"address":[],"length":0,"stats":{"Line":14}},{"line":128,"address":[],"length":0,"stats":{"Line":14}},{"line":129,"address":[],"length":0,"stats":{"Line":14}},{"line":130,"address":[],"length":0,"stats":{"Line":14}},{"line":131,"address":[],"length":0,"stats":{"Line":14}},{"line":132,"address":[],"length":0,"stats":{"Line":14}},{"line":133,"address":[],"length":0,"stats":{"Line":14}},{"line":134,"address":[],"length":0,"stats":{"Line":14}},{"line":135,"address":[],"length":0,"stats":{"Line":14}},{"line":140,"address":[],"length":0,"stats":{"Line":14}}],"covered":60,"coverable":60},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","prompts","evaluator.rs"],"content":"pub const EVALUATOR_PROMPT_TEMPLATE: \u0026str = r#\"あなたは、脆弱性分析レポートを評価するセキュリティ専門家です。\nこのレポートは、SQLインジェクション（SQLI）、クロスサイトスクリプティング（XSS）、リモートコード実行（RCE）の脆弱性が含まれていることが知られているPythonウェブアプリケーションの脆弱性を特定することを目的としています。\n\n以下の観点からレポートを評価してください：\n1. 正しく特定された脆弱性（SQLI、XSS、RCE）\n2. 誤検知（存在しない脆弱性が報告されている場合）\n3. 分析の質（影響評価、根本原因の説明、緩和策の提案）\n4. 検証用コードの質（明確な手順、例となるリクエスト、期待される結果）\n\n評価対象のレポート：\n{report}\n\"#;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","prompts","mod.rs"],"content":"mod analysis;\nmod evaluator;\n\npub use analysis::*;\npub use evaluator::EVALUATOR_PROMPT_TEMPLATE;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","repo.rs"],"content":"use anyhow::Result;\nuse crate::security_patterns::SecurityRiskPatterns;\nuse std::{\n    fs::{read_dir, read_to_string, File},\n    io::{BufRead, BufReader, Result as IoResult},\n    path::{Path, PathBuf},\n};\n#[derive(Default)]\npub struct LanguageExclusions {\n    pub file_patterns: Vec\u003cString\u003e,\n}\n\npub struct RepoOps {\n    repo_path: PathBuf,\n    gitignore_patterns: Vec\u003cString\u003e,\n    language_exclusions: LanguageExclusions,\n    supported_extensions: Vec\u003cString\u003e,\n    code_parser: crate::parser::CodeParser,\n    parser_initialized: bool,\n}\n\nimpl RepoOps {\n    pub fn new(repo_path: PathBuf) -\u003e Self {\n        let gitignore_patterns = Self::read_gitignore(\u0026repo_path).unwrap_or_default();\n\n        let language_exclusions = LanguageExclusions {\n            file_patterns: vec![\"test_\".to_string(), \"conftest\".to_string()],\n        };\n\n        let code_parser = crate::parser::CodeParser::new().unwrap();\n        let supported_extensions = vec![\n            \"py\".to_string(),\n            \"js\".to_string(),\n            \"jsx\".to_string(),\n            \"ts\".to_string(),\n            \"tsx\".to_string(),\n            \"rs\".to_string(),\n            \"go\".to_string(),\n            \"java\".to_string(),\n            \"rb\".to_string(),\n        ];\n\n        Self {\n            repo_path,\n            gitignore_patterns,\n            language_exclusions,\n            supported_extensions,\n            code_parser,\n            parser_initialized: false,\n        }\n    }\n\n    pub fn collect_context_for_security_pattern(\n        \u0026mut self,\n        file_path: \u0026std::path::Path,\n    ) -\u003e anyhow::Result\u003ccrate::parser::Context\u003e {\n        self.code_parser.build_context_from_file(file_path)\n    }\n\n    fn read_gitignore(repo_path: \u0026Path) -\u003e IoResult\u003cVec\u003cString\u003e\u003e {\n        let gitignore_path = repo_path.join(\".gitignore\");\n        if !gitignore_path.exists() {\n            return Ok(Vec::new());\n        }\n\n        let file = File::open(gitignore_path)?;\n        let reader = BufReader::new(file);\n        let mut patterns = Vec::new();\n\n        for line in reader.lines() {\n            let line = line?;\n            let trimmed = line.trim();\n            if !trimmed.is_empty() \u0026\u0026 !trimmed.starts_with('#') {\n                patterns.push(trimmed.to_string());\n            };\n        }\n\n        Ok(patterns)\n    }\n\n    #[allow(clippy::only_used_in_recursion)]\n    fn visit_dirs(\u0026self, dir: \u0026Path, cb: \u0026mut dyn FnMut(\u0026Path)) -\u003e std::io::Result\u003c()\u003e {\n        if dir.is_dir() {\n            for entry in read_dir(dir)? {\n                let entry = entry?;\n                let path = entry.path();\n                if path.is_dir() {\n                    self.visit_dirs(\u0026path, cb)?;\n                } else {\n                    cb(\u0026path);\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn should_exclude_path(\u0026self, path: \u0026Path) -\u003e bool {\n        if let Ok(relative_path) = path.strip_prefix(\u0026self.repo_path) {\n            let relative_str = relative_path.to_string_lossy();\n\n            for pattern in \u0026self.gitignore_patterns {\n                if Self::matches_gitignore_pattern(\u0026relative_str, pattern) {\n                    return true;\n                }\n            }\n\n            if let Some(file_name) = path.file_name() {\n                let file_name = file_name.to_string_lossy().to_lowercase();\n                if self\n                    .language_exclusions\n                    .file_patterns\n                    .iter()\n                    .any(|pattern| file_name.contains(pattern))\n                {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n\n    /// Determine if a path matches a .gitignore style pattern.\n    ///\n    /// The function is public so that integration tests can verify the\n    /// behaviour of pattern matching.\n    pub fn matches_gitignore_pattern(path: \u0026str, pattern: \u0026str) -\u003e bool {\n        let pattern = pattern.trim_start_matches('/');\n        let path = path.trim_start_matches('/');\n\n        if let Some(stripped) = pattern.strip_prefix('*') {\n            path.ends_with(stripped)\n        } else if let Some(stripped) = pattern.strip_suffix('*') {\n            path.starts_with(stripped)\n        } else if !pattern.contains('/') {\n            if path == pattern {\n                true\n            } else {\n                path.split('/')\n                    .any(|segment| segment == pattern)\n            }\n        } else {\n            path == pattern || path.starts_with(\u0026format!(\"{}/\", pattern))\n        }\n    }\n\n    pub fn get_relevant_files(\u0026self) -\u003e Vec\u003cPathBuf\u003e {\n        let mut files = Vec::new();\n\n        let mut callback = |path: \u0026Path| {\n            if let Some(ext) = path.extension() {\n                let ext_str = ext.to_string_lossy().to_lowercase();\n                if !self.supported_extensions.contains(\u0026ext_str) {\n                    return;\n                }\n\n                if self.should_exclude_path(path) {\n                    return;\n                }\n\n                files.push(path.to_path_buf());\n            }\n        };\n\n        if let Err(e) = self.visit_dirs(\u0026self.repo_path, \u0026mut callback) {\n            eprintln!(\"ディレクトリの走査中にエラーが発生しました: {}\", e);\n        }\n\n        files\n    }\n\n    pub fn get_network_related_files(\u0026self, files: \u0026[PathBuf]) -\u003e Vec\u003cPathBuf\u003e {\n        let mut network_files = Vec::new();\n        for file_path in files {\n            if let Ok(content) = read_to_string(file_path) {\n                let ext = file_path\n                    .extension()\n                    .and_then(|e| e.to_str())\n                    .unwrap_or(\"\");\n                let lang = crate::security_patterns::Language::from_extension(ext);\n                let patterns = SecurityRiskPatterns::new(lang);\n                if patterns.matches(\u0026content) {\n                    network_files.push(file_path.clone());\n                }\n            }\n        }\n\n        network_files\n    }\n\n    pub fn get_files_to_analyze(\u0026self, analyze_path: Option\u003cPathBuf\u003e) -\u003e Result\u003cVec\u003cPathBuf\u003e\u003e {\n        let path_to_analyze = analyze_path.unwrap_or_else(|| self.repo_path.clone());\n\n        if path_to_analyze.is_file() {\n            if let Some(ext) = path_to_analyze.extension() {\n                let ext_str = ext.to_string_lossy().to_lowercase();\n                if self.supported_extensions.contains(\u0026ext_str) {\n                    return Ok(vec![path_to_analyze]);\n                }\n            }\n            Ok(vec![])\n        } else if path_to_analyze.is_dir() {\n            let mut files = Vec::new();\n            let mut callback = |path: \u0026Path| {\n                if let Some(ext) = path.extension() {\n                    let ext_str = ext.to_string_lossy().to_lowercase();\n                    if self.supported_extensions.contains(\u0026ext_str) {\n                        files.push(path.to_path_buf());\n                    }\n                }\n            };\n\n            self.visit_dirs(\u0026path_to_analyze, \u0026mut callback)?;\n            Ok(files)\n        } else {\n            anyhow::bail!(\n                \"指定された解析パスが存在しません: {}\",\n                path_to_analyze.display()\n            )\n        }\n    }\n\n    pub fn parse_repo_files(\u0026mut self, analyze_path: Option\u003cPathBuf\u003e) -\u003e Result\u003c()\u003e {\n        let files = self.get_files_to_analyze(analyze_path)?;\n        for file in \u0026files {\n            self.code_parser.add_file(file)?;\n        }\n        self.parser_initialized = true;\n\n        Ok(())\n    }\n\n    pub fn find_definition_in_repo(\n        \u0026mut self,\n        name: \u0026str,\n        source_file: \u0026Path,\n    ) -\u003e anyhow::Result\u003cOption\u003c(PathBuf, crate::parser::Definition)\u003e\u003e {\n        if !self.parser_initialized {\n            self.parse_repo_files(None)?;\n        }\n\n        self.code_parser.find_definition(name, source_file)\n    }\n\n    pub fn find_references_in_repo(\n        \u0026mut self,\n        name: \u0026str,\n    ) -\u003e anyhow::Result\u003cVec\u003c(PathBuf, crate::parser::Definition)\u003e\u003e {\n        if !self.parser_initialized {\n            self.parse_repo_files(None)?;\n        }\n        self.code_parser.find_references(name)\n    }\n    pub fn add_file_to_parser(\u0026mut self, path: \u0026std::path::Path) -\u003e anyhow::Result\u003c()\u003e {\n        self.code_parser.add_file(path)\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":4}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":34,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":10}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":20}},{"line":127,"address":[],"length":0,"stats":{"Line":20}},{"line":128,"address":[],"length":0,"stats":{"Line":20}},{"line":130,"address":[],"length":0,"stats":{"Line":26}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":20}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":14}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":6}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":6}},{"line":204,"address":[],"length":0,"stats":{"Line":8}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}}],"covered":59,"coverable":124},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","repo_clone.rs"],"content":"use git2::{Cred, Error, FetchOptions, RemoteCallbacks, Repository};\nuse std::env;\nuse std::path::Path;\n\n/// GitHubリポジトリをcloneする\n///\n/// # 引数\n/// - repo: \"owner/repo\" 形式のGitHubリポジトリ名\n/// - dest: clone先ディレクトリ\n///\n/// # 戻り値\n/// - Ok(()) 成功\n/// - Err(Error) 失敗\npub fn clone_github_repo(repo: \u0026str, dest: \u0026Path) -\u003e Result\u003c(), Error\u003e {\n    // 既存ディレクトリがあればエラー\n    if dest.exists() {\n        return Err(Error::from_str(\"Destination directory already exists\"));\n    }\n\n    // GitHubリポジトリURL組み立て\n    let url = format!(\"https://github.com/{}.git\", repo);\n\n    // GITHUB_TOKENがあれば認証付き\n    let token = env::var(\"GITHUB_TOKEN\").ok();\n\n    let mut callbacks = RemoteCallbacks::new();\n    if let Some(ref token) = token {\n        callbacks.credentials(move |_url, _username_from_url, _allowed_types| {\n            Cred::userpass_plaintext(\"x-access-token\", token)\n        });\n    }\n\n    let mut fetch_options = FetchOptions::new();\n    if token.is_some() {\n        fetch_options.remote_callbacks(callbacks);\n    }\n\n    // 空リポジトリ作成\n    let repo = Repository::init(dest)?;\n    // origin remote 作成\n    let mut remote = repo.remote(\"origin\", \u0026url)?;\n\n    // fetch\n    remote.fetch(\n        \u0026[\"refs/heads/*:refs/remotes/origin/*\"],\n        Some(\u0026mut fetch_options),\n        None,\n    )?;\n\n    // HEAD をセット\n    let fetch_head = repo.find_reference(\"FETCH_HEAD\")?;\n    let fetch_commit = fetch_head.peel_to_commit()?;\n    repo.branch(\"master\", \u0026fetch_commit, true)?;\n    repo.set_head(\"refs/heads/master\")?;\n    repo.checkout_head(None)?;\n\n    Ok(())\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","response.rs"],"content":"use serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\n#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]\npub enum VulnType {\n    LFI,\n    RCE,\n    SSRF,\n    AFO,\n    SQLI,\n    XSS,\n    IDOR,\n    Other(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ContextCode {\n    pub name: String,\n    pub reason: String,\n    pub code_line: String,\n    pub path: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Response {\n    pub scratchpad: String,\n    pub analysis: String,\n    pub poc: String,\n    pub confidence_score: i32,\n    pub vulnerability_types: Vec\u003cVulnType\u003e,\n    pub context_code: Vec\u003cContextCode\u003e,\n}\n\npub fn response_json_schema() -\u003e serde_json::Value {\n    json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"scratchpad\": { \"type\": \"string\" },\n            \"analysis\": { \"type\": \"string\" },\n            \"poc\": { \"type\": \"string\" },\n            \"confidence_score\": { \"type\": \"integer\" },\n            \"vulnerability_types\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"LFI\", \"RCE\", \"SSRF\", \"AFO\", \"SQLI\", \"XSS\", \"IDOR\"]\n                }\n            },\n            \"context_code\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"name\": { \"type\": \"string\" },\n                        \"reason\": { \"type\": \"string\" },\n                        \"code_line\": { \"type\": \"string\" },\n                        \"path\": { \"type\": \"string\" }\n                    },\n                    \"required\": [\"name\", \"reason\", \"code_line\", \"path\"]\n                }\n            }\n        },\n        \"required\": [\"scratchpad\", \"analysis\", \"poc\", \"confidence_score\", \"vulnerability_types\", \"context_code\"]\n    })\n}\n\nimpl Response {\n    pub fn normalize_confidence_score(score: i32) -\u003e i32 {\n        if score \u003e 0 \u0026\u0026 score \u003c= 10 {\n            score * 10\n        } else {\n            score\n        }\n    }\n\n    pub fn print_readable(\u0026self) {\n        println!(\"\\n📝 解析レポート\");\n        println!(\"{}\", \"=\".repeat(80));\n\n        let confidence_icon = match self.confidence_score {\n            90..=100 =\u003e \"🔴 高\",\n            70..=89 =\u003e \"🟠 中高\",\n            50..=69 =\u003e \"🟡 中\",\n            30..=49 =\u003e \"🟢 中低\",\n            _ =\u003e \"🔵 低\",\n        };\n        println!(\n            \"\\n🎯 信頼度スコア: {} ({})\",\n            self.confidence_score, confidence_icon\n        );\n\n        if !self.vulnerability_types.is_empty() {\n            println!(\"\\n⚠ 検出された脆弱性タイプ:\");\n            for vuln_type in \u0026self.vulnerability_types {\n                println!(\"  - {:?}\", vuln_type);\n            }\n        }\n\n        println!(\"\\n🔍 解析結果:\");\n        println!(\"{}\", \"-\".repeat(80));\n        println!(\"{}\", self.analysis);\n\n        if !self.poc.is_empty() {\n            println!(\"\\n🔨 PoC(概念実証コード):\");\n            println!(\"{}\", \"-\".repeat(80));\n            println!(\"{}\", self.poc);\n        }\n\n        if !self.context_code.is_empty() {\n            println!(\"\\n📄 関連コードコンテキスト:\");\n            println!(\"{}\", \"-\".repeat(80));\n            for context in \u0026self.context_code {\n                println!(\"関数名: {}\", context.name);\n                println!(\"理由: {}\", context.reason);\n                println!(\"コード: {}\", context.code_line);\n                println!(\"パス: {}\", context.path);\n                println!();\n            }\n        }\n\n        if !self.scratchpad.is_empty() {\n            println!(\"\\n📓 解析ノート:\");\n            println!(\"{}\", \"-\".repeat(80));\n            println!(\"{}\", self.scratchpad);\n        }\n\n        println!();\n    }\n\n    pub fn to_markdown(\u0026self) -\u003e String {\n        let mut md = String::new();\n        md.push_str(\"# 解析レポート\\n\\n\");\n\n        let confidence_badge = match self.confidence_score {\n            90..=100 =\u003e \"![高信頼度](https://img.shields.io/badge/信頼度-高-red)\",\n            70..=89 =\u003e \"![中高信頼度](https://img.shields.io/badge/信頼度-中高-orange)\",\n            50..=69 =\u003e \"![中信頼度](https://img.shields.io/badge/信頼度-中-yellow)\",\n            30..=49 =\u003e \"![中低信頼度](https://img.shields.io/badge/信頼度-中低-green)\",\n            _ =\u003e \"![低信頼度](https://img.shields.io/badge/信頼度-低-blue)\",\n        };\n        md.push_str(\u0026format!(\n            \"{} **信頼度スコア: {}**\\n\\n\",\n            confidence_badge, self.confidence_score\n        ));\n\n        if !self.vulnerability_types.is_empty() {\n            md.push_str(\"## 脆弱性タイプ\\n\\n\");\n            for vuln_type in \u0026self.vulnerability_types {\n                md.push_str(\u0026format!(\"- `{:?}`\\n\", vuln_type));\n            }\n            md.push('\\n');\n        }\n\n        md.push_str(\"## 解析結果\\n\\n\");\n        md.push_str(\u0026self.analysis);\n        md.push_str(\"\\n\\n\");\n\n        if !self.poc.is_empty() {\n            md.push_str(\"## PoC（概念実証コード）\\n\\n\");\n            md.push_str(\"```text\\n\");\n            md.push_str(\u0026self.poc);\n            md.push_str(\"\\n```\\n\\n\");\n        }\n\n        if !self.context_code.is_empty() {\n            md.push_str(\"## 関連コードコンテキスト\\n\\n\");\n            for context in \u0026self.context_code {\n                md.push_str(\u0026format!(\"### 関数名: {}\\n\", context.name));\n                md.push_str(\u0026format!(\"- 理由: {}\\n\", context.reason));\n                md.push_str(\u0026format!(\"- パス: {}\\n\", context.path));\n                md.push_str(\"```rust\\n\");\n                md.push_str(\u0026context.code_line);\n                md.push_str(\"\\n```\\n\\n\");\n            }\n        }\n\n        if !self.scratchpad.is_empty() {\n            md.push_str(\"## 解析ノート\\n\\n\");\n            md.push_str(\u0026self.scratchpad);\n            md.push_str(\"\\n\\n\");\n        }\n\n        md\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct FileAnalysisResult {\n    pub file_path: PathBuf,\n    pub response: Response,\n}\n\n#[derive(Debug, Clone, Default)]\npub struct AnalysisSummary {\n    pub results: Vec\u003cFileAnalysisResult\u003e,\n}\n\nimpl AnalysisSummary {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn add_result(\u0026mut self, file_path: PathBuf, response: Response) {\n        self.results.push(FileAnalysisResult {\n            file_path,\n            response,\n        });\n    }\n\n    pub fn sort_by_confidence(\u0026mut self) {\n        self.results.sort_by(|a, b| {\n            b.response\n                .confidence_score\n                .cmp(\u0026a.response.confidence_score)\n        });\n    }\n\n    pub fn filter_by_min_confidence(\u0026self, min_score: i32) -\u003e Self {\n        Self {\n            results: self\n                .results\n                .iter()\n                .filter(|r| r.response.confidence_score \u003e= min_score)\n                .cloned()\n                .collect(),\n        }\n    }\n\n    pub fn filter_by_vuln_types(\u0026self, vuln_types: \u0026[VulnType]) -\u003e Self {\n        Self {\n            results: self\n                .results\n                .iter()\n                .filter(|r| {\n                    r.response\n                        .vulnerability_types\n                        .iter()\n                        .any(|vt| vuln_types.contains(vt))\n                })\n                .cloned()\n                .collect(),\n        }\n    }\n\n    pub fn to_markdown(\u0026self) -\u003e String {\n        let mut md = String::new();\n        md.push_str(\"# 脆弱性解析サマリーレポート\\n\\n\");\n\n        md.push_str(\"## 概要\\n\\n\");\n        md.push_str(\"| ファイル | 脆弱性タイプ | 信頼度 | 重要度 |\\n\");\n        md.push_str(\"|---------|------------|--------|--------|\\n\");\n\n        for result in \u0026self.results {\n            if result.response.confidence_score \u003e 0 {\n                let confidence_level = match result.response.confidence_score {\n                    90..=100 =\u003e \"🔴 高\",\n                    70..=89 =\u003e \"🟠 中高\",\n                    50..=69 =\u003e \"🟡 中\",\n                    30..=49 =\u003e \"🟢 中低\",\n                    _ =\u003e \"🔵 低\",\n                };\n\n                let vuln_types = result\n                    .response\n                    .vulnerability_types\n                    .iter()\n                    .map(|vt| format!(\"{:?}\", vt))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n\n                md.push_str(\u0026format!(\n                    \"| [{}]({}.md) | {} | {} | {} |\\n\",\n                    result\n                        .file_path\n                        .file_name()\n                        .unwrap_or_default()\n                        .to_string_lossy(),\n                    result\n                        .file_path\n                        .file_name()\n                        .unwrap_or_default()\n                        .to_string_lossy(),\n                    vuln_types,\n                    result.response.confidence_score,\n                    confidence_level\n                ));\n            }\n        }\n\n        md.push_str(\"\\n## 脆弱性タイプ別集計\\n\\n\");\n\n        let mut type_count: HashMap\u003c\u0026VulnType, i32\u003e = HashMap::new();\n        for result in \u0026self.results {\n            for vuln_type in \u0026result.response.vulnerability_types {\n                *type_count.entry(vuln_type).or_insert(0) += 1;\n            }\n        }\n\n        md.push_str(\"| 脆弱性タイプ | 件数 |\\n\");\n        md.push_str(\"|------------|------|\\n\");\n\n        for (vuln_type, count) in type_count.iter() {\n            md.push_str(\u0026format!(\"| {:?} | {} |\\n\", vuln_type, count));\n        }\n\n        md\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":14}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":8}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":10}},{"line":202,"address":[],"length":0,"stats":{"Line":10}},{"line":205,"address":[],"length":0,"stats":{"Line":22}},{"line":206,"address":[],"length":0,"stats":{"Line":22}},{"line":207,"address":[],"length":0,"stats":{"Line":22}},{"line":208,"address":[],"length":0,"stats":{"Line":22}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":12}},{"line":214,"address":[],"length":0,"stats":{"Line":10}},{"line":215,"address":[],"length":0,"stats":{"Line":10}},{"line":216,"address":[],"length":0,"stats":{"Line":10}},{"line":220,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}}],"covered":64,"coverable":162},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","security_patterns.rs"],"content":"use regex::Regex;\nuse serde::Deserialize;\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::PathBuf;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Language {\n    Python,\n    JavaScript,\n    Rust,\n    TypeScript,\n    Java,\n    Go,\n    Ruby,\n    Other,\n}\n\nimpl Language {\n    pub fn from_extension(ext: \u0026str) -\u003e Self {\n        match ext {\n            \"py\" =\u003e Language::Python,\n            \"js\" =\u003e Language::JavaScript,\n            \"rs\" =\u003e Language::Rust,\n            \"ts\" =\u003e Language::TypeScript,\n            \"java\" =\u003e Language::Java,\n            \"go\" =\u003e Language::Go,\n            \"rb\" =\u003e Language::Ruby,\n            _ =\u003e Language::Other,\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum PatternType {\n    Source,\n    Sink,\n    Validate,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct PatternConfig {\n    pub pattern: String,\n    pub description: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct LanguagePatterns {\n    pub sources: Option\u003cVec\u003cPatternConfig\u003e\u003e,\n    pub sinks: Option\u003cVec\u003cPatternConfig\u003e\u003e,\n    pub validate: Option\u003cVec\u003cPatternConfig\u003e\u003e,\n}\n\npub struct SecurityRiskPatterns {\n    source_patterns: Vec\u003cRegex\u003e,\n    sink_patterns: Vec\u003cRegex\u003e,\n    validate_patterns: Vec\u003cRegex\u003e,\n    pattern_type_map: HashMap\u003cString, PatternType\u003e,\n}\n\nimpl SecurityRiskPatterns {\n    pub fn new(language: Language) -\u003e Self {\n        let pattern_map = Self::load_patterns();\n        let lang_patterns = pattern_map\n            .get(\u0026language)\n            .or_else(|| pattern_map.get(\u0026Language::Other))\n            .unwrap();\n\n        let mut source_patterns = Vec::new();\n        let mut sink_patterns = Vec::new(); \n        let mut validate_patterns = Vec::new();\n        let mut pattern_type_map = HashMap::new();\n\n        if let Some(sources) = \u0026lang_patterns.sources {\n            for config in sources {\n                let regex = Regex::new(\u0026config.pattern).unwrap();\n                pattern_type_map.insert(config.pattern.clone(), PatternType::Source);\n                source_patterns.push(regex);\n            }\n        }\n\n        if let Some(sinks) = \u0026lang_patterns.sinks {\n            for config in sinks {\n                let regex = Regex::new(\u0026config.pattern).unwrap();\n                pattern_type_map.insert(config.pattern.clone(), PatternType::Sink);\n                sink_patterns.push(regex);\n            }\n        }\n\n        if let Some(validates) = \u0026lang_patterns.validate {\n            for config in validates {\n                let regex = Regex::new(\u0026config.pattern).unwrap();\n                pattern_type_map.insert(config.pattern.clone(), PatternType::Validate);\n                validate_patterns.push(regex);\n            }\n        }\n\n        Self { \n            source_patterns,\n            sink_patterns, \n            validate_patterns,\n            pattern_type_map,\n        }\n    }\n\n    pub fn matches(\u0026self, content: \u0026str) -\u003e bool {\n        self.source_patterns.iter().any(|pattern| pattern.is_match(content))\n            || self.sink_patterns.iter().any(|pattern| pattern.is_match(content))\n            || self.validate_patterns.iter().any(|pattern| pattern.is_match(content))\n    }\n\n    /// パターンの種類を取得する。\n    pub fn get_pattern_type(\u0026self, content: \u0026str) -\u003e Option\u003cPatternType\u003e {\n        for (pattern_str, pattern_type) in \u0026self.pattern_type_map {\n            let regex = Regex::new(pattern_str).ok()?;\n            if regex.is_match(content) {\n                return Some(pattern_type.clone());\n            }\n        }\n        None\n    }\n\n    /// 言語ごとのパターン定義を読み込む\n    fn load_patterns() -\u003e HashMap\u003cLanguage, LanguagePatterns\u003e {\n        use Language::*;\n\n        let manifest_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        let yaml_path = manifest_dir\n            .join(\"security_patterns\")\n            .join(\"patterns.yml\");\n        let content = fs::read_to_string(\u0026yaml_path)\n            .unwrap_or_else(|_| panic!(\"failed to read {}\", yaml_path.display()));\n        let raw_map: HashMap\u003cString, LanguagePatterns\u003e =\n            serde_yaml::from_str(\u0026content).expect(\"failed to parse patterns.yml\");\n\n        let mut map = HashMap::new();\n        for (lang, patterns) in raw_map {\n            let key = match lang.as_str() {\n                \"Python\" =\u003e Python,\n                \"JavaScript\" =\u003e JavaScript,\n                \"Rust\" =\u003e Rust,\n                \"TypeScript\" =\u003e TypeScript,\n                \"Java\" =\u003e Java,\n                \"Go\" =\u003e Go,\n                \"Ruby\" =\u003e Ruby,\n                \"Other\" =\u003e Other,\n                _ =\u003e continue,\n            };\n            map.insert(key, patterns);\n        }\n\n        map\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":22}},{"line":21,"address":[],"length":0,"stats":{"Line":22}},{"line":22,"address":[],"length":0,"stats":{"Line":24}},{"line":23,"address":[],"length":0,"stats":{"Line":22}},{"line":24,"address":[],"length":0,"stats":{"Line":20}},{"line":25,"address":[],"length":0,"stats":{"Line":18}},{"line":26,"address":[],"length":0,"stats":{"Line":16}},{"line":27,"address":[],"length":0,"stats":{"Line":14}},{"line":28,"address":[],"length":0,"stats":{"Line":12}},{"line":29,"address":[],"length":0,"stats":{"Line":8}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":32}},{"line":76,"address":[],"length":0,"stats":{"Line":10}},{"line":77,"address":[],"length":0,"stats":{"Line":10}},{"line":78,"address":[],"length":0,"stats":{"Line":10}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":38}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":12}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":44}},{"line":92,"address":[],"length":0,"stats":{"Line":14}},{"line":93,"address":[],"length":0,"stats":{"Line":14}},{"line":94,"address":[],"length":0,"stats":{"Line":14}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":30}},{"line":138,"address":[],"length":0,"stats":{"Line":14}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":14}},{"line":141,"address":[],"length":0,"stats":{"Line":12}},{"line":142,"address":[],"length":0,"stats":{"Line":10}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":4}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":2}}],"covered":52,"coverable":65},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","analyzer_test.rs"],"content":"#[allow(unused_imports)]\nuse std::path::PathBuf;\n#[allow(unused_imports)]\nuse tempfile::NamedTempFile;\n#[allow(unused_imports)]\nuse vulnhuntrs::analyzer::analyze_file;\n#[allow(unused_imports)]\nuse vulnhuntrs::response::{ContextCode, VulnType};\n\n#[cfg(feature = \"snapshot-test\")]\n#[tokio::test]\nasync fn test_analyze_empty_file() -\u003e anyhow::Result\u003c()\u003e {\n    let temp_file = NamedTempFile::new()?;\n\n    let result = analyze_file(\n        \u0026PathBuf::from(temp_file.path()),\n        \"gpt-4o-mini\",\n        \u0026[PathBuf::from(temp_file.path())],\n        0,\n        \u0026vulnhuntrs::parser::Context {\n            definitions: vec![],\n        },\n        0,\n    )\n    .await?;\n\n    assert_eq!(result.scratchpad, String::new());\n    assert_eq!(result.analysis, String::new());\n    assert_eq!(result.poc, String::new());\n    assert_eq!(result.confidence_score, 0);\n    assert!(result.vulnerability_types.is_empty());\n    assert!(result.context_code.is_empty());\n\n    Ok(())\n}\n\n#[cfg(feature = \"snapshot-test\")]\n#[tokio::test]\nasync fn test_analyze_hardcoded_password() -\u003e anyhow::Result\u003c()\u003e {\n    let temp_file = NamedTempFile::new()?;\n    std::fs::write(\n        temp_file.path(),\n        r#\"\nfn main() {\n    let password = \"hardcoded_password\";\n    println!(\"{}\", password);\n}\n\"#,\n    )?;\n\n    let result = analyze_file(\n        \u0026PathBuf::from(temp_file.path()),\n        \"gpt-4o-mini\",\n        \u0026[PathBuf::from(temp_file.path())],\n        0,\n        \u0026vulnhuntrs::parser::Context {\n            definitions: vec![],\n        },\n        0,\n    )\n    .await?;\n\n    assert!(!result.analysis.is_empty(), \"Analysis should not be empty\");\n    assert!(\n        result.confidence_score \u003e 0,\n        \"Confidence score should be positive\"\n    );\n    assert!(\n        !result.vulnerability_types.is_empty(),\n        \"Should detect vulnerabilities\"\n    );\n    assert!(\n        !result.context_code.is_empty(),\n        \"Should include context code\"\n    );\n\n    Ok(())\n}\n\n#[cfg(feature = \"snapshot-test\")]\n#[tokio::test]\nasync fn test_analyze_authentication_function() -\u003e anyhow::Result\u003c()\u003e {\n    let temp_file = NamedTempFile::new()?;\n    std::fs::write(\n        temp_file.path(),\n        r#\"\nfn authenticate(input: \u0026str) -\u003e bool {\n    let password = \"hardcoded_password\";\n    input == password\n}\n\nfn main() {\n    let user_input = \"test\";\n    if authenticate(user_input) {\n        println!(\"Authenticated!\");\n    }\n}\n\"#,\n    )?;\n\n    let result = analyze_file(\n        \u0026PathBuf::from(temp_file.path()),\n        \"gpt-4o-mini\",\n        \u0026[PathBuf::from(temp_file.path())],\n        0,\n        \u0026vulnhuntrs::parser::Context {\n            definitions: vec![],\n        },\n        0,\n    )\n    .await?;\n\n    assert!(!result.analysis.is_empty(), \"Analysis should not be empty\");\n    assert!(\n        result.confidence_score \u003e= 0,\n        \"Confidence score should be positive\"\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","analyzer_unit_test.rs"],"content":"use std::path::PathBuf;\nuse tempfile::NamedTempFile;\nuse vulnhuntrs::parser::{Context, Definition};\nuse vulnhuntrs::response::Response;\nuse std::io::Write;\n\n// Mock functions for testing\n#[tokio::test]\nasync fn test_analyze_empty_file() -\u003e anyhow::Result\u003c()\u003e {\n    // Create empty temporary file\n    let temp_file = NamedTempFile::new()?;\n    let file_path = temp_file.path().to_path_buf();\n    \n    // Create empty context\n    let context = Context {\n        definitions: vec![],\n    };\n    \n    // Test with mock model (this would require actual API key in real scenario)\n    // For unit test, we'll test the empty file handling specifically\n    let result = analyze_empty_file_logic(\u0026file_path).await?;\n    \n    assert_eq!(result.scratchpad, \"\");\n    assert_eq!(result.analysis, \"\");\n    assert_eq!(result.poc, \"\");\n    assert_eq!(result.confidence_score, 0);\n    assert_eq!(result.vulnerability_types.len(), 0);\n    assert_eq!(result.context_code.len(), 0);\n    \n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_analyze_file_with_basic_content() -\u003e anyhow::Result\u003c()\u003e {\n    // Create temporary file with basic content\n    let mut temp_file = NamedTempFile::new()?;\n    writeln!(temp_file, \"print('Hello, World!')\")?;\n    let file_path = temp_file.path().to_path_buf();\n    \n    // Create context with a mock definition\n    let context = Context {\n        definitions: vec![Definition {\n            name: \"test_function\".to_string(),\n            source: \"def test_function(): pass\".to_string(),\n            start_byte: 0,\n            end_byte: 25,\n        }],\n    };\n    \n    // Test basic file processing logic (without actual LLM call)\n    let content = std::fs::read_to_string(\u0026file_path)?;\n    assert!(!content.is_empty());\n    assert!(content.contains(\"Hello, World!\"));\n    \n    Ok(())\n}\n\n#[test]\nfn test_context_text_generation() {\n    let context = Context {\n        definitions: vec![\n            Definition {\n                name: \"vulnerable_function\".to_string(),\n                source: \"def vulnerable_function(user_input):\\n    os.system(user_input)\".to_string(),\n                start_byte: 0,\n                end_byte: 50,\n            },\n            Definition {\n                name: \"safe_function\".to_string(),\n                source: \"def safe_function(user_input):\\n    return user_input.strip()\".to_string(),\n                start_byte: 60,\n                end_byte: 110,\n            },\n        ],\n    };\n    \n    let mut context_text = String::new();\n    if !context.definitions.is_empty() {\n        context_text.push_str(\"\\nContext Definitions:\\n\");\n        for def in \u0026context.definitions {\n            context_text.push_str(\u0026format!(\n                \"\\nFunction/Definition: {}\\nCode:\\n{}\\n\",\n                def.name, def.source\n            ));\n        }\n    }\n    \n    assert!(context_text.contains(\"vulnerable_function\"));\n    assert!(context_text.contains(\"safe_function\"));\n    assert!(context_text.contains(\"os.system\"));\n    assert!(context_text.contains(\"Context Definitions:\"));\n}\n\n// Simulate the empty file handling logic from analyzer.rs\nasync fn analyze_empty_file_logic(file_path: \u0026PathBuf) -\u003e anyhow::Result\u003cResponse\u003e {\n    let content = std::fs::read_to_string(file_path)?;\n    if content.is_empty() {\n        return Ok(Response {\n            scratchpad: String::new(),\n            analysis: String::new(),\n            poc: String::new(),\n            confidence_score: 0,\n            vulnerability_types: vec![],\n            context_code: vec![],\n        });\n    }\n    \n    // For non-empty files, return a mock response\n    Ok(Response {\n        scratchpad: \"File processed\".to_string(),\n        analysis: \"Basic analysis performed\".to_string(),\n        poc: \"\".to_string(),\n        confidence_score: 5,\n        vulnerability_types: vec![],\n        context_code: vec![],\n    })\n}\n\n#[test]\nfn test_parse_json_response_valid() {\n    let json_content = r#\"{\n        \"scratchpad\": \"Test scratchpad\",\n        \"analysis\": \"Test analysis\",\n        \"poc\": \"Test PoC\",\n        \"confidence_score\": 8,\n        \"vulnerability_types\": [],\n        \"context_code\": []\n    }\"#;\n    \n    let result: Result\u003cResponse, _\u003e = serde_json::from_str(json_content);\n    assert!(result.is_ok());\n    \n    let response = result.unwrap();\n    assert_eq!(response.scratchpad, \"Test scratchpad\");\n    assert_eq!(response.analysis, \"Test analysis\");\n    assert_eq!(response.confidence_score, 8);\n}\n\n#[test]\nfn test_parse_json_response_invalid() {\n    let invalid_json = r#\"{ invalid json content\"#;\n    \n    let result: Result\u003cResponse, _\u003e = serde_json::from_str(invalid_json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_file_path_display() {\n    let file_path = PathBuf::from(\"/test/path/vulnerable.py\");\n    let display_str = format!(\"File: {}\", file_path.display());\n    assert!(display_str.contains(\"vulnerable.py\"));\n    assert!(display_str.contains(\"/test/path/\"));\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","main_unit_test.rs"],"content":"use std::path::PathBuf;\nuse vulnhuntrs::response::{AnalysisSummary, VulnType, Response};\nuse vulnhuntrs::response::FileAnalysisResult;\n\n#[test]\nfn test_vuln_type_parsing() {\n    // Test vulnerability type parsing logic similar to main.rs\n    let types_str = \"LFI,RCE,SSRF,IDOR\";\n    let vuln_types: Vec\u003cVulnType\u003e = types_str\n        .split(',')\n        .map(|s| match s.trim() {\n            \"LFI\" =\u003e VulnType::LFI,\n            \"RCE\" =\u003e VulnType::RCE,\n            \"SSRF\" =\u003e VulnType::SSRF,\n            \"AFO\" =\u003e VulnType::AFO,\n            \"SQLI\" =\u003e VulnType::SQLI,\n            \"XSS\" =\u003e VulnType::XSS,\n            \"IDOR\" =\u003e VulnType::IDOR,\n            other =\u003e VulnType::Other(other.to_string()),\n        })\n        .collect();\n    \n    assert_eq!(vuln_types.len(), 4);\n    assert_eq!(vuln_types[0], VulnType::LFI);\n    assert_eq!(vuln_types[1], VulnType::RCE);\n    assert_eq!(vuln_types[2], VulnType::SSRF);\n    assert_eq!(vuln_types[3], VulnType::IDOR);\n}\n\n#[test]\nfn test_vuln_type_parsing_with_unknown_type() {\n    let types_str = \"LFI,UNKNOWN_TYPE,RCE\";\n    let vuln_types: Vec\u003cVulnType\u003e = types_str\n        .split(',')\n        .map(|s| match s.trim() {\n            \"LFI\" =\u003e VulnType::LFI,\n            \"RCE\" =\u003e VulnType::RCE,\n            \"SSRF\" =\u003e VulnType::SSRF,\n            \"AFO\" =\u003e VulnType::AFO,\n            \"SQLI\" =\u003e VulnType::SQLI,\n            \"XSS\" =\u003e VulnType::XSS,\n            \"IDOR\" =\u003e VulnType::IDOR,\n            other =\u003e VulnType::Other(other.to_string()),\n        })\n        .collect();\n    \n    assert_eq!(vuln_types.len(), 3);\n    assert_eq!(vuln_types[0], VulnType::LFI);\n    assert_eq!(vuln_types[1], VulnType::Other(\"UNKNOWN_TYPE\".to_string()));\n    assert_eq!(vuln_types[2], VulnType::RCE);\n}\n\n#[test]\nfn test_analysis_summary_creation() {\n    let mut summary = AnalysisSummary::new();\n    \n    // Create mock responses\n    let response1 = Response {\n        scratchpad: \"Test scratchpad 1\".to_string(),\n        analysis: \"Test analysis 1\".to_string(),\n        poc: \"Test PoC 1\".to_string(),\n        confidence_score: 8,\n        vulnerability_types: vec![VulnType::RCE],\n        context_code: vec![],\n    };\n    \n    let response2 = Response {\n        scratchpad: \"Test scratchpad 2\".to_string(),\n        analysis: \"Test analysis 2\".to_string(),\n        poc: \"Test PoC 2\".to_string(),\n        confidence_score: 6,\n        vulnerability_types: vec![VulnType::SQLI],\n        context_code: vec![],\n    };\n    \n    // Add results to summary\n    summary.add_result(PathBuf::from(\"/test/file1.py\"), response1);\n    summary.add_result(PathBuf::from(\"/test/file2.py\"), response2);\n    \n    assert_eq!(summary.results.len(), 2);\n    assert_eq!(summary.results[0].response.confidence_score, 8);\n    assert_eq!(summary.results[1].response.confidence_score, 6);\n}\n\n#[test]\nfn test_analysis_summary_filtering_by_confidence() {\n    let mut summary = AnalysisSummary::new();\n    \n    // Create responses with different confidence scores\n    let high_confidence = Response {\n        scratchpad: \"High confidence\".to_string(),\n        analysis: \"High confidence analysis\".to_string(),\n        poc: \"High confidence PoC\".to_string(),\n        confidence_score: 9,\n        vulnerability_types: vec![VulnType::RCE],\n        context_code: vec![],\n    };\n    \n    let low_confidence = Response {\n        scratchpad: \"Low confidence\".to_string(),\n        analysis: \"Low confidence analysis\".to_string(),\n        poc: \"Low confidence PoC\".to_string(),\n        confidence_score: 3,\n        vulnerability_types: vec![VulnType::XSS],\n        context_code: vec![],\n    };\n    \n    summary.add_result(PathBuf::from(\"/test/high.py\"), high_confidence);\n    summary.add_result(PathBuf::from(\"/test/low.py\"), low_confidence);\n    \n    // Filter by minimum confidence 5\n    let filtered = summary.filter_by_min_confidence(5);\n    \n    assert_eq!(filtered.results.len(), 1);\n    assert_eq!(filtered.results[0].response.confidence_score, 9);\n}\n\n#[test]\nfn test_analysis_summary_filtering_by_vuln_types() {\n    let mut summary = AnalysisSummary::new();\n    \n    let rce_response = Response {\n        scratchpad: \"RCE vulnerability\".to_string(),\n        analysis: \"RCE analysis\".to_string(),\n        poc: \"RCE PoC\".to_string(),\n        confidence_score: 8,\n        vulnerability_types: vec![VulnType::RCE],\n        context_code: vec![],\n    };\n    \n    let sqli_response = Response {\n        scratchpad: \"SQLI vulnerability\".to_string(),\n        analysis: \"SQLI analysis\".to_string(),\n        poc: \"SQLI PoC\".to_string(),\n        confidence_score: 7,\n        vulnerability_types: vec![VulnType::SQLI],\n        context_code: vec![],\n    };\n    \n    let xss_response = Response {\n        scratchpad: \"XSS vulnerability\".to_string(),\n        analysis: \"XSS analysis\".to_string(),\n        poc: \"XSS PoC\".to_string(),\n        confidence_score: 6,\n        vulnerability_types: vec![VulnType::XSS],\n        context_code: vec![],\n    };\n    \n    summary.add_result(PathBuf::from(\"/test/rce.py\"), rce_response);\n    summary.add_result(PathBuf::from(\"/test/sqli.py\"), sqli_response);\n    summary.add_result(PathBuf::from(\"/test/xss.py\"), xss_response);\n    \n    // Filter by specific vulnerability types\n    let filter_types = vec![VulnType::RCE, VulnType::SQLI];\n    let filtered = summary.filter_by_vuln_types(\u0026filter_types);\n    \n    assert_eq!(filtered.results.len(), 2);\n    assert!(filtered.results.iter().any(|r| r.response.vulnerability_types.contains(\u0026VulnType::RCE)));\n    assert!(filtered.results.iter().any(|r| r.response.vulnerability_types.contains(\u0026VulnType::SQLI)));\n    assert!(!filtered.results.iter().any(|r| r.response.vulnerability_types.contains(\u0026VulnType::XSS)));\n}\n\n#[test]\nfn test_analysis_summary_sorting_by_confidence() {\n    let mut summary = AnalysisSummary::new();\n    \n    // Add results in random order\n    let responses = [\n        (PathBuf::from(\"/test/medium.py\"), 5),\n        (PathBuf::from(\"/test/high.py\"), 9),\n        (PathBuf::from(\"/test/low.py\"), 2),\n        (PathBuf::from(\"/test/very_high.py\"), 10),\n    ];\n    \n    for (path, confidence) in responses {\n        let response = Response {\n            scratchpad: format!(\"Confidence {}\", confidence),\n            analysis: format!(\"Analysis with confidence {}\", confidence),\n            poc: format!(\"PoC {}\", confidence),\n            confidence_score: confidence,\n            vulnerability_types: vec![VulnType::RCE],\n            context_code: vec![],\n        };\n        summary.add_result(path, response);\n    }\n    \n    summary.sort_by_confidence();\n    \n    // Should be sorted in descending order by confidence\n    assert_eq!(summary.results[0].response.confidence_score, 10);\n    assert_eq!(summary.results[1].response.confidence_score, 9);\n    assert_eq!(summary.results[2].response.confidence_score, 5);\n    assert_eq!(summary.results[3].response.confidence_score, 2);\n}\n\n#[test]\nfn test_pathbuf_from_string() {\n    // Test path handling logic\n    let path_str = \"/tmp/test/vulnerable.py\";\n    let path = PathBuf::from(path_str);\n    \n    assert_eq!(path.to_string_lossy(), path_str);\n    assert!(path.is_absolute());\n    assert_eq!(path.extension().unwrap(), \"py\");\n}\n\n#[test]\nfn test_model_default_value() {\n    // Test that the default model is correctly set\n    let default_model = \"o4-mini\";\n    assert_eq!(default_model, \"o4-mini\");\n}\n\n#[test]\nfn test_verbosity_levels() {\n    // Test verbosity level handling\n    let verbosity_levels = [0u8, 1u8, 2u8, 3u8];\n    \n    for level in verbosity_levels {\n        match level {\n            0 =\u003e assert_eq!(level, 0), // No verbose output\n            1 =\u003e assert_eq!(level, 1), // Basic verbose output\n            2 =\u003e assert_eq!(level, 2), // More verbose output\n            _ =\u003e assert!(level \u003e= 3),  // Maximum verbosity\n        }\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","pattern_generator_test.rs"],"content":"use std::fs;\nuse std::path::PathBuf;\nuse tempfile::TempDir;\nuse vulnhuntrs::pattern_generator::{write_patterns_to_file, PatternClassification};\nuse vulnhuntrs::security_patterns::Language;\n\nfn create_test_python_file(dir: \u0026TempDir) -\u003e PathBuf {\n    let file_path = dir.path().join(\"test.py\");\n    let content = r#\"\nimport os\nimport subprocess\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\ndef get_user_input():\n    return request.args.get('input', '')\n\ndef execute_command(cmd):\n    return subprocess.run(cmd, shell=True, capture_output=True)\n\ndef write_to_file(filename, data):\n    with open(filename, 'w') as f:\n        f.write(data)\n\ndef validate_input(data):\n    import re\n    return re.match(r'^[a-zA-Z0-9]+$', data) is not None\n\ndef hash_password(password):\n    import hashlib\n    return hashlib.sha256(password.encode()).hexdigest()\n\"#;\n    fs::write(\u0026file_path, content).unwrap();\n    file_path\n}\n\nfn create_test_rust_file(dir: \u0026TempDir) -\u003e PathBuf {\n    let file_path = dir.path().join(\"test.rs\");\n    let content = r#\"\nuse std::process::Command;\nuse std::fs;\n\nfn get_user_data() -\u003e String {\n    std::env::args().nth(1).unwrap_or_default()\n}\n\nfn execute_shell_command(cmd: \u0026str) -\u003e String {\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(cmd)\n        .output()\n        .expect(\"Failed to execute\");\n    String::from_utf8_lossy(\u0026output.stdout).to_string()\n}\n\nfn read_file_contents(path: \u0026str) -\u003e Result\u003cString, std::io::Error\u003e {\n    fs::read_to_string(path)\n}\n\nfn sanitize_input(input: \u0026str) -\u003e String {\n    input.chars().filter(|c| c.is_alphanumeric()).collect()\n}\n\"#;\n    fs::write(\u0026file_path, content).unwrap();\n    file_path\n}\n\n// Note: LLM integration tests are commented out as they require real API keys\n// These would be integration tests that need actual LLM responses\n// \n// #[tokio::test]\n// async fn test_pattern_generation_python() {\n//     let temp_dir = TempDir::new().unwrap();\n//     create_test_python_file(\u0026temp_dir);\n//     \n//     let result = generate_custom_patterns(\u0026temp_dir.path().to_path_buf(), \"test-model\").await;\n//     assert!(result.is_ok());\n//     assert!(temp_dir.path().join(\"vuln-patterns.yml\").exists());\n// }\n//\n// #[tokio::test]\n// async fn test_pattern_generation_rust() {\n//     let temp_dir = TempDir::new().unwrap();\n//     create_test_rust_file(\u0026temp_dir);\n//     \n//     let result = generate_custom_patterns(\u0026temp_dir.path().to_path_buf(), \"test-model\").await;\n//     assert!(result.is_ok());\n//     assert!(temp_dir.path().join(\"vuln-patterns.yml\").exists());\n// }\n\n#[test]\nfn test_yaml_pattern_format() {\n    let temp_dir = TempDir::new().unwrap();\n    \n    let patterns = vec![\n        PatternClassification {\n            function_name: \"test_sink\".to_string(),\n            pattern_type: Some(\"sinks\".to_string()),\n            pattern: \"\\\\\\\\btest_sink\\\\\\\\s*\\\\\\\\(\".to_string(),\n            description: \"Test sink function\".to_string(),\n            reasoning: \"Test reasoning for sink\".to_string(),\n        },\n        PatternClassification {\n            function_name: \"test_source\".to_string(),\n            pattern_type: Some(\"sources\".to_string()),\n            pattern: \"\\\\\\\\btest_source\\\\\\\\s*\\\\\\\\(\".to_string(),\n            description: \"Test source function\".to_string(),\n            reasoning: \"Test reasoning for source\".to_string(),\n        },\n        PatternClassification {\n            function_name: \"test_validate\".to_string(),\n            pattern_type: Some(\"validate\".to_string()),\n            pattern: \"\\\\\\\\btest_validate\\\\\\\\s*\\\\\\\\(\".to_string(),\n            description: \"Test validation function\".to_string(),\n            reasoning: \"Test reasoning for validation\".to_string(),\n        },\n    ];\n    \n    let result = write_patterns_to_file(\u0026temp_dir.path().to_path_buf(), Language::Python, \u0026patterns);\n    assert!(result.is_ok());\n    \n    let yaml_path = temp_dir.path().join(\"vuln-patterns.yml\");\n    assert!(yaml_path.exists());\n    \n    let content = fs::read_to_string(\u0026yaml_path).unwrap();\n    assert!(content.contains(\"Python:\"));\n    assert!(content.contains(\"sources:\"));\n    assert!(content.contains(\"sinks:\"));\n    assert!(content.contains(\"validate:\"));\n    assert!(content.contains(\"test_sink\"));\n    assert!(content.contains(\"test_source\"));\n    assert!(content.contains(\"test_validate\"));\n}\n\n// Integration test that doesn't require API calls\n#[test]\nfn test_file_discovery() {\n    let temp_dir = TempDir::new().unwrap();\n    create_test_python_file(\u0026temp_dir);\n    create_test_rust_file(\u0026temp_dir);\n    \n    let repo = vulnhuntrs::repo::RepoOps::new(temp_dir.path().to_path_buf());\n    let files = repo.get_files_to_analyze(None).unwrap();\n    \n    assert_eq!(files.len(), 2);\n    assert!(files.iter().any(|f| f.file_name().unwrap() == \"test.py\"));\n    assert!(files.iter().any(|f| f.file_name().unwrap() == \"test.rs\"));\n}\n\n#[test]\nfn test_definition_extraction() {\n    let temp_dir = TempDir::new().unwrap();\n    create_test_python_file(\u0026temp_dir);\n    \n    let file_path = temp_dir.path().join(\"test.py\");\n    let mut parser = vulnhuntrs::parser::CodeParser::new().unwrap();\n    parser.add_file(\u0026file_path).unwrap();\n    \n    let context = parser.build_context_from_file(\u0026file_path).unwrap();\n    \n    // Should extract function definitions\n    assert!(!context.definitions.is_empty());\n    \n    // Check if expected functions are found\n    let function_names: Vec\u003c\u0026str\u003e = context.definitions.iter()\n        .map(|def| def.name.as_str())\n        .collect();\n    \n    assert!(function_names.contains(\u0026\"get_user_input\"));\n    assert!(function_names.contains(\u0026\"execute_command\"));\n    assert!(function_names.contains(\u0026\"write_to_file\"));\n    assert!(function_names.contains(\u0026\"validate_input\"));\n    assert!(function_names.contains(\u0026\"hash_password\"));\n}\n\n#[test]\nfn test_yaml_append_functionality() {\n    let temp_dir = TempDir::new().unwrap();\n    let yaml_path = temp_dir.path().join(\"vuln-patterns.yml\");\n    \n    // Write initial content\n    fs::write(\u0026yaml_path, \"Go:\\n  sinks:\\n    - pattern: \\\"existing_pattern\\\"\\n      description: \\\"Existing pattern\\\"\\n\").unwrap();\n    \n    let patterns = vec![\n        PatternClassification {\n            function_name: \"new_function\".to_string(),\n            pattern_type: Some(\"sinks\".to_string()),\n            pattern: \"\\\\\\\\bnew_function\\\\\\\\s*\\\\\\\\(\".to_string(),\n            description: \"New function pattern\".to_string(),\n            reasoning: \"Test reasoning\".to_string(),\n        },\n    ];\n    \n    let result = write_patterns_to_file(\u0026temp_dir.path().to_path_buf(), Language::Python, \u0026patterns);\n    assert!(result.is_ok());\n    \n    let content = fs::read_to_string(\u0026yaml_path).unwrap();\n    assert!(content.contains(\"Go:\"));\n    assert!(content.contains(\"existing_pattern\"));\n    assert!(content.contains(\"Python:\"));\n    assert!(content.contains(\"new_function\"));\n}\n\n#[test]\nfn test_empty_patterns_handling() {\n    let temp_dir = TempDir::new().unwrap();\n    \n    let patterns = vec![\n        PatternClassification {\n            function_name: \"non_security_function\".to_string(),\n            pattern_type: None,\n            pattern: \"\".to_string(),\n            description: \"\".to_string(),\n            reasoning: \"Not a security pattern\".to_string(),\n        },\n    ];\n    \n    let result = write_patterns_to_file(\u0026temp_dir.path().to_path_buf(), Language::Python, \u0026patterns);\n    assert!(result.is_ok());\n    \n    let yaml_path = temp_dir.path().join(\"vuln-patterns.yml\");\n    let content = fs::read_to_string(\u0026yaml_path).unwrap();\n    \n    // Should only contain the language header since no valid patterns were provided\n    assert_eq!(content.trim(), \"Python:\");\n}\n\n#[test]\nfn test_language_filtering() {\n    let temp_dir = TempDir::new().unwrap();\n    \n    let patterns = vec![\n        PatternClassification {\n            function_name: \"test_function\".to_string(),\n            pattern_type: Some(\"sinks\".to_string()),\n            pattern: \"test_pattern\".to_string(),\n            description: \"Test description\".to_string(),\n            reasoning: \"Test reasoning\".to_string(),\n        },\n    ];\n    \n    // Test that Other language is skipped\n    let result = write_patterns_to_file(\u0026temp_dir.path().to_path_buf(), Language::Other, \u0026patterns);\n    assert!(result.is_ok());\n    \n    let yaml_path = temp_dir.path().join(\"vuln-patterns.yml\");\n    assert!(!yaml_path.exists());\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","prompts_unit_test.rs"],"content":"use vulnhuntrs::prompts::{\n    SYS_PROMPT_TEMPLATE, \n    INITIAL_ANALYSIS_PROMPT_TEMPLATE,\n    ANALYSIS_APPROACH_TEMPLATE,\n    GUIDELINES_TEMPLATE,\n    vuln_specific\n};\nuse vulnhuntrs::response::VulnType;\n\n#[test]\nfn test_sys_prompt_template() {\n    assert!(!SYS_PROMPT_TEMPLATE.is_empty());\n    assert!(SYS_PROMPT_TEMPLATE.contains(\"セキュリティ研究者\"));\n    assert!(SYS_PROMPT_TEMPLATE.contains(\"脆弱性\"));\n    assert!(SYS_PROMPT_TEMPLATE.contains(\"入力値の検証\"));\n    assert!(SYS_PROMPT_TEMPLATE.contains(\"認証・認可\"));\n}\n\n#[test]\nfn test_initial_analysis_prompt_template() {\n    assert!(!INITIAL_ANALYSIS_PROMPT_TEMPLATE.is_empty());\n    assert!(INITIAL_ANALYSIS_PROMPT_TEMPLATE.contains(\"セキュリティ脆弱性\"));\n    assert!(INITIAL_ANALYSIS_PROMPT_TEMPLATE.contains(\"ユーザー入力\"));\n    assert!(INITIAL_ANALYSIS_PROMPT_TEMPLATE.contains(\"データベースクエリ\"));\n    assert!(INITIAL_ANALYSIS_PROMPT_TEMPLATE.contains(\"コマンド実行\"));\n}\n\n#[test]\nfn test_analysis_approach_template() {\n    assert!(!ANALYSIS_APPROACH_TEMPLATE.is_empty());\n    assert!(ANALYSIS_APPROACH_TEMPLATE.contains(\"手順\"));\n    assert!(ANALYSIS_APPROACH_TEMPLATE.contains(\"エントリポイント\"));\n    assert!(ANALYSIS_APPROACH_TEMPLATE.contains(\"データフロー\"));\n    assert!(ANALYSIS_APPROACH_TEMPLATE.contains(\"バイパス\"));\n    assert!(ANALYSIS_APPROACH_TEMPLATE.contains(\"影響を評価\"));\n}\n\n#[test]\nfn test_guidelines_template() {\n    assert!(!GUIDELINES_TEMPLATE.is_empty());\n    assert!(GUIDELINES_TEMPLATE.contains(\"ガイドライン\"));\n    assert!(GUIDELINES_TEMPLATE.contains(\"悪用可能\"));\n    assert!(GUIDELINES_TEMPLATE.contains(\"行番号\"));\n    assert!(GUIDELINES_TEMPLATE.contains(\"信頼度\"));\n    assert!(GUIDELINES_TEMPLATE.contains(\"日本語\"));\n}\n\n#[test]\nfn test_prompt_templates_are_non_empty() {\n    let templates = [\n        SYS_PROMPT_TEMPLATE,\n        INITIAL_ANALYSIS_PROMPT_TEMPLATE,\n        ANALYSIS_APPROACH_TEMPLATE,\n        GUIDELINES_TEMPLATE,\n    ];\n    \n    for template in templates {\n        assert!(!template.is_empty());\n        assert!(template.len() \u003e 10); // Reasonable minimum length\n    }\n}\n\n#[test]\nfn test_prompt_templates_contain_analysis_keywords() {\n    let analysis_keywords = [\n        \"分析\",\n        \"脆弱性\",\n        \"セキュリティ\",\n        \"コード\",\n    ];\n    \n    let templates = [\n        SYS_PROMPT_TEMPLATE,\n        INITIAL_ANALYSIS_PROMPT_TEMPLATE,\n        ANALYSIS_APPROACH_TEMPLATE,\n        GUIDELINES_TEMPLATE,\n    ];\n    \n    for template in templates {\n        let contains_analysis_keywords = analysis_keywords\n            .iter()\n            .any(|keyword| template.contains(keyword));\n        assert!(contains_analysis_keywords, \"Template should contain analysis keywords\");\n    }\n}\n\n#[test]\nfn test_vuln_specific_module_exists() {\n    // Test that the vuln_specific module can be accessed\n    // This verifies the module structure is correct\n    let vuln_info_map = vuln_specific::get_vuln_specific_info();\n    assert!(!vuln_info_map.is_empty());\n}\n\n#[test]\nfn test_vuln_info_map_contains_common_types() {\n    let vuln_info_map = vuln_specific::get_vuln_specific_info();\n    \n    // Test that common vulnerability types are present\n    let common_types = [\n        VulnType::RCE,\n        VulnType::SQLI,\n        VulnType::XSS,\n        VulnType::LFI,\n    ];\n    \n    for vuln_type in common_types {\n        assert!(vuln_info_map.contains_key(\u0026vuln_type), \n               \"Should contain vulnerability type: {:?}\", vuln_type);\n    }\n}\n\n#[test]\nfn test_vuln_info_structure() {\n    let vuln_info_map = vuln_specific::get_vuln_specific_info();\n    \n    for (vuln_type, vuln_info) in \u0026vuln_info_map {\n        // Each vulnerability type should have non-empty prompt\n        assert!(!vuln_info.prompt.is_empty(), \n               \"Prompt should not be empty for {:?}\", vuln_type);\n        \n        // Prompt should be reasonably long\n        assert!(vuln_info.prompt.len() \u003e 20, \n               \"Prompt should be substantial for {:?}\", vuln_type);\n        \n        // Bypasses can be empty but if present should be non-empty strings\n        for bypass in \u0026vuln_info.bypasses {\n            assert!(!bypass.is_empty(), \n                   \"Bypass strings should not be empty for {:?}\", vuln_type);\n        }\n    }\n}\n\n#[test]\nfn test_rce_specific_prompt() {\n    let vuln_info_map = vuln_specific::get_vuln_specific_info();\n    let rce_info = vuln_info_map.get(\u0026VulnType::RCE);\n    \n    assert!(rce_info.is_some());\n    let rce_info = rce_info.unwrap();\n    \n    // RCE prompt should contain relevant keywords (English or Japanese)\n    assert!(rce_info.prompt.contains(\"コマンド\") || \n           rce_info.prompt.contains(\"実行\") ||\n           rce_info.prompt.contains(\"Remote Code Execution\") ||\n           rce_info.prompt.contains(\"Code Execution\"));\n    assert!(!rce_info.prompt.is_empty());\n}\n\n#[test]\nfn test_sqli_specific_prompt() {\n    let vuln_info_map = vuln_specific::get_vuln_specific_info();\n    let sqli_info = vuln_info_map.get(\u0026VulnType::SQLI);\n    \n    assert!(sqli_info.is_some());\n    let sqli_info = sqli_info.unwrap();\n    \n    // SQL injection prompt should contain relevant keywords\n    assert!(sqli_info.prompt.contains(\"SQL\") || \n           sqli_info.prompt.contains(\"データベース\") ||\n           sqli_info.prompt.contains(\"クエリ\"));\n    assert!(!sqli_info.prompt.is_empty());\n}\n\n#[test]\nfn test_xss_specific_prompt() {\n    let vuln_info_map = vuln_specific::get_vuln_specific_info();\n    let xss_info = vuln_info_map.get(\u0026VulnType::XSS);\n    \n    assert!(xss_info.is_some());\n    let xss_info = xss_info.unwrap();\n    \n    // XSS prompt should contain relevant keywords (English or Japanese)\n    assert!(xss_info.prompt.contains(\"XSS\") || \n           xss_info.prompt.contains(\"スクリプト\") ||\n           xss_info.prompt.contains(\"HTML\") ||\n           xss_info.prompt.contains(\"Cross-Site Scripting\"));\n    assert!(!xss_info.prompt.is_empty());\n}\n\n#[test]\nfn test_lfi_specific_prompt() {\n    let vuln_info_map = vuln_specific::get_vuln_specific_info();\n    let lfi_info = vuln_info_map.get(\u0026VulnType::LFI);\n    \n    assert!(lfi_info.is_some());\n    let lfi_info = lfi_info.unwrap();\n    \n    // LFI prompt should contain relevant keywords (English or Japanese)\n    assert!(lfi_info.prompt.contains(\"ファイル\") || \n           lfi_info.prompt.contains(\"パス\") ||\n           lfi_info.prompt.contains(\"インクルード\") ||\n           lfi_info.prompt.contains(\"Local File Inclusion\") ||\n           lfi_info.prompt.contains(\"File\"));\n    assert!(!lfi_info.prompt.is_empty());\n}\n\n#[test]\nfn test_prompt_templates_formatting() {\n    let templates = [\n        SYS_PROMPT_TEMPLATE,\n        INITIAL_ANALYSIS_PROMPT_TEMPLATE,\n        ANALYSIS_APPROACH_TEMPLATE,\n        GUIDELINES_TEMPLATE,\n    ];\n    \n    for template in templates {\n        // Templates should contain meaningful content (allow leading/trailing whitespace)\n        assert!(!template.trim().is_empty());\n        \n        // Templates should contain proper line breaks\n        assert!(template.contains('\\n'));\n    }\n}\n\n#[test]\nfn test_evaluator_prompt_template() {\n    use vulnhuntrs::prompts::EVALUATOR_PROMPT_TEMPLATE;\n    \n    assert!(!EVALUATOR_PROMPT_TEMPLATE.is_empty());\n    // The evaluator prompt should be for evaluation purposes\n    assert!(EVALUATOR_PROMPT_TEMPLATE.len() \u003e 50); // Should be substantial\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","repo_test.rs"],"content":"use tempfile::tempdir;\nuse vulnhuntrs::repo::RepoOps;\n\n#[test]\nfn test_ruby_files_are_recognized() -\u003e anyhow::Result\u003c()\u003e {\n    let dir = tempdir()?;\n    let file_path = dir.path().join(\"test.rb\");\n    std::fs::write(\u0026file_path, \"puts 'hello'\")?;\n\n    let repo = RepoOps::new(dir.path().to_path_buf());\n    let files = repo.get_relevant_files();\n\n    assert!(files.contains(\u0026file_path));\n    Ok(())\n}\n\n#[test]\nfn test_matches_gitignore_leading_star() {\n    assert!(RepoOps::matches_gitignore_pattern(\"error.log\", \"*.log\"));\n    assert!(RepoOps::matches_gitignore_pattern(\"logs/error.log\", \"*.log\"));\n    assert!(!RepoOps::matches_gitignore_pattern(\"error.txt\", \"*.log\"));\n}\n\n#[test]\nfn test_matches_gitignore_trailing_star() {\n    assert!(RepoOps::matches_gitignore_pattern(\"build/output.o\", \"build/*\"));\n    assert!(RepoOps::matches_gitignore_pattern(\"build/sub/obj.o\", \"build/*\"));\n    assert!(!RepoOps::matches_gitignore_pattern(\"target/output.o\", \"build/*\"));\n}\n\n#[test]\nfn test_matches_gitignore_exact_match() {\n    assert!(RepoOps::matches_gitignore_pattern(\"src/main.rs\", \"src/main.rs\"));\n    assert!(!RepoOps::matches_gitignore_pattern(\"src/lib.rs\", \"src/main.rs\"));\n}\n\n#[test]\nfn test_matches_gitignore_nested_directory() {\n    assert!(RepoOps::matches_gitignore_pattern(\n        \"app/node_modules/package.json\",\n        \"node_modules\"\n    ));\n    assert!(!RepoOps::matches_gitignore_pattern(\n        \"app/modules/package.json\",\n        \"node_modules\"\n    ));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","response_unit_test.rs"],"content":"use std::path::PathBuf;\nuse vulnhuntrs::response::{Response, VulnType, ContextCode, AnalysisSummary, response_json_schema};\nuse serde_json::{json, Value};\n\n#[test]\nfn test_vuln_type_serialization() {\n    let vuln_types = vec![\n        VulnType::LFI,\n        VulnType::RCE,\n        VulnType::SSRF,\n        VulnType::AFO,\n        VulnType::SQLI,\n        VulnType::XSS,\n        VulnType::IDOR,\n        VulnType::Other(\"Custom\".to_string()),\n    ];\n    \n    let serialized = serde_json::to_string(\u0026vuln_types).unwrap();\n    let deserialized: Vec\u003cVulnType\u003e = serde_json::from_str(\u0026serialized).unwrap();\n    \n    assert_eq!(vuln_types, deserialized);\n}\n\n#[test]\nfn test_vuln_type_equality() {\n    assert_eq!(VulnType::LFI, VulnType::LFI);\n    assert_eq!(VulnType::Other(\"test\".to_string()), VulnType::Other(\"test\".to_string()));\n    assert_ne!(VulnType::LFI, VulnType::RCE);\n    assert_ne!(VulnType::Other(\"test1\".to_string()), VulnType::Other(\"test2\".to_string()));\n}\n\n#[test]\nfn test_context_code_creation() {\n    let context = ContextCode {\n        name: \"vulnerable_function\".to_string(),\n        reason: \"Uses unsafe eval() function\".to_string(),\n        code_line: \"eval(user_input)\".to_string(),\n        path: \"/src/vulnerable.py\".to_string(),\n    };\n    \n    assert_eq!(context.name, \"vulnerable_function\");\n    assert_eq!(context.reason, \"Uses unsafe eval() function\");\n    assert_eq!(context.code_line, \"eval(user_input)\");\n    assert_eq!(context.path, \"/src/vulnerable.py\");\n}\n\n#[test]\nfn test_response_creation() {\n    let response = Response {\n        scratchpad: \"Analysis notes\".to_string(),\n        analysis: \"Found RCE vulnerability\".to_string(),\n        poc: \"curl -X POST -d 'cmd=ls' /vulnerable-endpoint\".to_string(),\n        confidence_score: 9,\n        vulnerability_types: vec![VulnType::RCE],\n        context_code: vec![ContextCode {\n            name: \"process_command\".to_string(),\n            reason: \"Direct command execution\".to_string(),\n            code_line: \"os.system(command)\".to_string(),\n            path: \"/src/handlers.py\".to_string(),\n        }],\n    };\n    \n    assert_eq!(response.confidence_score, 9);\n    assert_eq!(response.vulnerability_types.len(), 1);\n    assert_eq!(response.context_code.len(), 1);\n    assert!(response.analysis.contains(\"RCE\"));\n}\n\n#[test]\nfn test_response_serialization() {\n    let response = Response {\n        scratchpad: \"Test scratchpad\".to_string(),\n        analysis: \"Test analysis\".to_string(),\n        poc: \"Test PoC\".to_string(),\n        confidence_score: 7,\n        vulnerability_types: vec![VulnType::SQLI, VulnType::XSS],\n        context_code: vec![],\n    };\n    \n    let serialized = serde_json::to_string(\u0026response).unwrap();\n    let deserialized: Response = serde_json::from_str(\u0026serialized).unwrap();\n    \n    assert_eq!(response.confidence_score, deserialized.confidence_score);\n    assert_eq!(response.vulnerability_types, deserialized.vulnerability_types);\n}\n\n#[test]\nfn test_response_json_schema() {\n    let schema = response_json_schema();\n    \n    // Verify schema structure\n    assert_eq!(schema[\"type\"], \"object\");\n    \n    let properties = \u0026schema[\"properties\"];\n    assert!(properties[\"scratchpad\"][\"type\"] == \"string\");\n    assert!(properties[\"analysis\"][\"type\"] == \"string\");\n    assert!(properties[\"poc\"][\"type\"] == \"string\");\n    assert!(properties[\"confidence_score\"][\"type\"] == \"integer\");\n    \n    // Check vulnerability types array schema\n    let vuln_types = \u0026properties[\"vulnerability_types\"];\n    assert_eq!(vuln_types[\"type\"], \"array\");\n    assert!(vuln_types[\"items\"][\"enum\"].as_array().unwrap().contains(\u0026json!(\"RCE\")));\n    assert!(vuln_types[\"items\"][\"enum\"].as_array().unwrap().contains(\u0026json!(\"SQLI\")));\n}\n\n#[test]\nfn test_analysis_summary_default() {\n    let summary = AnalysisSummary::default();\n    assert_eq!(summary.results.len(), 0);\n}\n\n#[test]\nfn test_analysis_summary_new() {\n    let summary = AnalysisSummary::new();\n    assert_eq!(summary.results.len(), 0);\n}\n\n#[test]\nfn test_markdown_generation() {\n    let response = Response {\n        scratchpad: \"Test scratchpad\".to_string(),\n        analysis: \"This is a test analysis with **bold** text\".to_string(),\n        poc: \"echo 'test'\".to_string(),\n        confidence_score: 8,\n        vulnerability_types: vec![VulnType::RCE, VulnType::SQLI],\n        context_code: vec![ContextCode {\n            name: \"test_function\".to_string(),\n            reason: \"Test reason\".to_string(),\n            code_line: \"test_code()\".to_string(),\n            path: \"/test/path.py\".to_string(),\n        }],\n    };\n    \n    let markdown = response.to_markdown();\n    \n    // Verify markdown contains expected sections\n    assert!(markdown.contains(\"# 解析レポート\"));\n    assert!(markdown.contains(\"信頼度スコア: 8\"));\n    assert!(markdown.contains(\"## 脆弱性タイプ\"));\n    assert!(markdown.contains(\"RCE\"));\n    assert!(markdown.contains(\"SQLI\"));\n    assert!(markdown.contains(\"## 解析結果\"));\n    assert!(markdown.contains(\"This is a test analysis\"));\n    assert!(markdown.contains(\"## PoC（概念実証コード）\"));\n    assert!(markdown.contains(\"echo 'test'\"));\n    assert!(markdown.contains(\"## 関連コードコンテキスト\"));\n}\n\n#[test]\nfn test_confidence_score_validation() {\n    // Test various confidence scores\n    let scores = [0, 1, 5, 10, -1, 15];\n    \n    for score in scores {\n        let response = Response {\n            scratchpad: String::new(),\n            analysis: String::new(),\n            poc: String::new(),\n            confidence_score: score,\n            vulnerability_types: vec![],\n            context_code: vec![],\n        };\n        \n        // Confidence score should be stored as-is (validation is handled elsewhere)\n        assert_eq!(response.confidence_score, score);\n    }\n}\n\n#[test]\nfn test_empty_response() {\n    let response = Response {\n        scratchpad: String::new(),\n        analysis: String::new(),\n        poc: String::new(),\n        confidence_score: 0,\n        vulnerability_types: vec![],\n        context_code: vec![],\n    };\n    \n    assert!(response.scratchpad.is_empty());\n    assert!(response.analysis.is_empty());\n    assert!(response.poc.is_empty());\n    assert_eq!(response.confidence_score, 0);\n    assert!(response.vulnerability_types.is_empty());\n    assert!(response.context_code.is_empty());\n}\n\n#[test]\nfn test_context_code_serialization() {\n    let context = ContextCode {\n        name: \"test_func\".to_string(),\n        reason: \"test reason\".to_string(),\n        code_line: \"print('test')\".to_string(),\n        path: \"/path/to/file.py\".to_string(),\n    };\n    \n    let serialized = serde_json::to_string(\u0026context).unwrap();\n    let deserialized: ContextCode = serde_json::from_str(\u0026serialized).unwrap();\n    \n    assert_eq!(context.name, deserialized.name);\n    assert_eq!(context.reason, deserialized.reason);\n    assert_eq!(context.code_line, deserialized.code_line);\n    assert_eq!(context.path, deserialized.path);\n}\n\n#[test]\nfn test_response_with_multiple_context_codes() {\n    let response = Response {\n        scratchpad: \"Multiple contexts\".to_string(),\n        analysis: \"Analysis with multiple context codes\".to_string(),\n        poc: \"PoC code\".to_string(),\n        confidence_score: 6,\n        vulnerability_types: vec![VulnType::XSS],\n        context_code: vec![\n            ContextCode {\n                name: \"func1\".to_string(),\n                reason: \"reason1\".to_string(),\n                code_line: \"code1\".to_string(),\n                path: \"/path1.py\".to_string(),\n            },\n            ContextCode {\n                name: \"func2\".to_string(),\n                reason: \"reason2\".to_string(),\n                code_line: \"code2\".to_string(),\n                path: \"/path2.py\".to_string(),\n            },\n        ],\n    };\n    \n    assert_eq!(response.context_code.len(), 2);\n    assert_eq!(response.context_code[0].name, \"func1\");\n    assert_eq!(response.context_code[1].name, \"func2\");\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","security_patterns_unit_test.rs"],"content":"use vulnhuntrs::security_patterns::{Language, PatternType, PatternConfig, LanguagePatterns, SecurityRiskPatterns};\nuse std::collections::HashMap;\n\n#[test]\nfn test_language_from_extension() {\n    // Test known extensions\n    assert_eq!(Language::from_extension(\"py\"), Language::Python);\n    assert_eq!(Language::from_extension(\"js\"), Language::JavaScript);\n    assert_eq!(Language::from_extension(\"rs\"), Language::Rust);\n    assert_eq!(Language::from_extension(\"ts\"), Language::TypeScript);\n    assert_eq!(Language::from_extension(\"java\"), Language::Java);\n    assert_eq!(Language::from_extension(\"go\"), Language::Go);\n    assert_eq!(Language::from_extension(\"rb\"), Language::Ruby);\n    \n    // Test unknown extensions\n    assert_eq!(Language::from_extension(\"txt\"), Language::Other);\n    assert_eq!(Language::from_extension(\"cpp\"), Language::Other);\n    assert_eq!(Language::from_extension(\"\"), Language::Other);\n    assert_eq!(Language::from_extension(\"unknown\"), Language::Other);\n}\n\n#[test]\nfn test_language_equality() {\n    assert_eq!(Language::Python, Language::Python);\n    assert_ne!(Language::Python, Language::JavaScript);\n    assert_ne!(Language::Rust, Language::TypeScript);\n}\n\n#[test]\nfn test_language_debug() {\n    let lang = Language::Python;\n    let debug_str = format!(\"{:?}\", lang);\n    assert_eq!(debug_str, \"Python\");\n}\n\n#[test]\nfn test_pattern_type_equality() {\n    assert_eq!(PatternType::Source, PatternType::Source);\n    assert_eq!(PatternType::Sink, PatternType::Sink);\n    assert_eq!(PatternType::Validate, PatternType::Validate);\n    \n    assert_ne!(PatternType::Source, PatternType::Sink);\n    assert_ne!(PatternType::Sink, PatternType::Validate);\n    assert_ne!(PatternType::Source, PatternType::Validate);\n}\n\n#[test]\nfn test_pattern_config_creation() {\n    let config = PatternConfig {\n        pattern: \"eval\\\\(\".to_string(),\n        description: \"Dynamic code execution\".to_string(),\n    };\n    \n    assert_eq!(config.pattern, \"eval\\\\(\");\n    assert_eq!(config.description, \"Dynamic code execution\");\n}\n\n#[test]\nfn test_language_patterns_creation() {\n    let sources = vec![\n        PatternConfig {\n            pattern: \"input\\\\(\".to_string(),\n            description: \"User input\".to_string(),\n        },\n        PatternConfig {\n            pattern: \"request\\\\.get\".to_string(),\n            description: \"HTTP request parameter\".to_string(),\n        },\n    ];\n    \n    let sinks = vec![\n        PatternConfig {\n            pattern: \"eval\\\\(\".to_string(),\n            description: \"Code execution\".to_string(),\n        },\n    ];\n    \n    let patterns = LanguagePatterns {\n        sources: Some(sources.clone()),\n        sinks: Some(sinks.clone()),\n        validate: None,\n    };\n    \n    assert!(patterns.sources.is_some());\n    assert!(patterns.sinks.is_some());\n    assert_eq!(patterns.sources.unwrap().len(), 2);\n    assert_eq!(patterns.sinks.unwrap().len(), 1);\n}\n\n#[test]\nfn test_language_patterns_empty() {\n    let patterns = LanguagePatterns {\n        sources: None,\n        sinks: None,\n        validate: None,\n    };\n    \n    assert!(patterns.sources.is_none());\n    assert!(patterns.sinks.is_none());\n}\n\n#[test]\nfn test_language_patterns_partial() {\n    let patterns = LanguagePatterns {\n        sources: Some(vec![PatternConfig {\n            pattern: \"test\".to_string(),\n            description: \"test description\".to_string(),\n        }]),\n        sinks: None,\n        validate: None,\n    };\n    \n    assert!(patterns.sources.is_some());\n    assert!(patterns.sinks.is_none());\n}\n\n#[test]\nfn test_security_risk_patterns_new() {\n    let patterns = SecurityRiskPatterns::new(Language::Python);\n    // The constructor doesn't return Result, it creates an instance directly\n    assert!(true); // Just test that it doesn't panic\n}\n\n// Note: SecurityRiskPatterns tests are skipped because they depend on patterns.yml file\n// which may not be available in the test environment. We focus on testing the basic types.\n\n// Note: PatternConfig and LanguagePatterns only derive Deserialize, not Serialize\n// So we skip serialization tests and focus on deserialization and basic functionality\n\n#[test]\nfn test_language_hash_and_equality() {\n    use std::collections::HashSet;\n    \n    let mut set = HashSet::new();\n    set.insert(Language::Python);\n    set.insert(Language::JavaScript);\n    set.insert(Language::Python); // Duplicate\n    \n    assert_eq!(set.len(), 2); // Should only contain 2 unique languages\n    assert!(set.contains(\u0026Language::Python));\n    assert!(set.contains(\u0026Language::JavaScript));\n    assert!(!set.contains(\u0026Language::Rust));\n}\n\n#[test]\nfn test_pattern_type_clone() {\n    let original = PatternType::Source;\n    let cloned = original.clone();\n    assert_eq!(original, cloned);\n}\n\n#[test]\nfn test_language_clone() {\n    let original = Language::Rust;\n    let cloned = original.clone();\n    assert_eq!(original, cloned);\n}\n\n#[test]\nfn test_pattern_config_deserialization() {\n    use serde_json;\n    \n    let json_data = r#\"{\"pattern\": \"test_pattern\", \"description\": \"test description\"}\"#;\n    let config: Result\u003cPatternConfig, _\u003e = serde_json::from_str(json_data);\n    \n    assert!(config.is_ok());\n    let config = config.unwrap();\n    assert_eq!(config.pattern, \"test_pattern\");\n    assert_eq!(config.description, \"test description\");\n}\n\n#[test]\nfn test_language_patterns_deserialization() {\n    use serde_json;\n    \n    let json_data = r#\"{\n        \"sources\": [{\"pattern\": \"input\", \"description\": \"User input\"}],\n        \"sinks\": [{\"pattern\": \"eval\", \"description\": \"Code execution\"}],\n        \"validate\": null\n    }\"#;\n    \n    let patterns: Result\u003cLanguagePatterns, _\u003e = serde_json::from_str(json_data);\n    assert!(patterns.is_ok());\n    \n    let patterns = patterns.unwrap();\n    assert!(patterns.sources.is_some());\n    assert!(patterns.sinks.is_some());\n    assert!(patterns.validate.is_none());\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-go","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config.std(\"c11\").include(src_dir);\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-go\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-go","bindings","rust","lib.rs"],"content":"//! This crate provides Go language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! func add(a, b int) int {\n//!     return a + b\n//! }\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_go::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading Go parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_go() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_go) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading Go parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-java","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config.std(\"c11\").include(src_dir);\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-java\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-java","bindings","rust","lib.rs"],"content":"//! This crate provides Java language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! class Test {\n//!     int double(int x) {\n//!         return x * 2;\n//!     }\n//! }\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_java::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading Java parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_java() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_java) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading Java parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-javascript","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config\n        .std(\"c11\")\n        .include(src_dir)\n        .flag_if_supported(\"-Wno-unused-parameter\");\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    let scanner_path = src_dir.join(\"scanner.c\");\n    c_config.file(\u0026scanner_path);\n    println!(\"cargo:rerun-if-changed={}\", scanner_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-javascript\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-javascript","bindings","rust","lib.rs"],"content":"//! This crate provides JavaScript language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! function double(x) {\n//!     return x * 2;\n//! }\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_javascript::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading JavaScript parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_javascript() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_javascript) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHT_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The syntax highlighting query for languages injected into this one.\npub const INJECTIONS_QUERY: \u0026str = include_str!(\"../../queries/injections.scm\");\n\n/// The syntax highlighting query for JSX.\npub const JSX_HIGHLIGHT_QUERY: \u0026str = include_str!(\"../../queries/highlights-jsx.scm\");\n\n/// The local-variable syntax highlighting query for this language.\npub const LOCALS_QUERY: \u0026str = include_str!(\"../../queries/locals.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading JavaScript parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-python","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config\n        .std(\"c11\")\n        .include(src_dir)\n        .flag_if_supported(\"-Wno-unused-value\");\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    let scanner_path = src_dir.join(\"scanner.c\");\n    c_config.file(\u0026scanner_path);\n    println!(\"cargo:rerun-if-changed={}\", scanner_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-python\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-python","bindings","rust","lib.rs"],"content":"//! This crate provides Python language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//!     def double(x):\n//!         return x * 2\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_python::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading Python parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_python() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_python) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading Python parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-ruby","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config\n        .std(\"c11\")\n        .include(src_dir)\n        .flag_if_supported(\"-Wno-unused-value\");\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    let scanner_path = src_dir.join(\"scanner.c\");\n    c_config.file(\u0026scanner_path);\n    println!(\"cargo:rerun-if-changed={}\", scanner_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-ruby\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-ruby","bindings","rust","lib.rs"],"content":"//! This crate provides Ruby language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! def hello(name)\n//!  puts \"Hello, #{name}!\"\n//! end\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_ruby::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading Ruby parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_ruby() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_ruby) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The local-variable syntax highlighting query for this language.\npub const LOCALS_QUERY: \u0026str = include_str!(\"../../queries/locals.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading Ruby parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-rust","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config.std(\"c11\").include(src_dir);\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    let scanner_path = src_dir.join(\"scanner.c\");\n    c_config.file(\u0026scanner_path);\n    println!(\"cargo:rerun-if-changed={}\", scanner_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-rust\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-rust","bindings","rust","lib.rs"],"content":"//! This crate provides Rust language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! fn double(x: i32) -\u003e i32 {\n//!     x * 2\n//! }\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_rust::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading Rust parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_rust() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_rust) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The injections query for this language.\npub const INJECTIONS_QUERY: \u0026str = include_str!(\"../../queries/injections.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading Rust parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-rust","examples","ast.rs"],"content":"// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 \u003cLICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0\u003e or the MIT license\n// \u003cLICENSE-MIT or http://opensource.org/licenses/MIT\u003e, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n// The Rust abstract syntax tree.\n\npub use self::PathParameters::*;\npub use self::TyParamBound::*;\npub use self::UnsafeSource::*;\npub use symbol::{Ident, Symbol as Name};\npub use util::parser::ExprPrecedence;\npub use util::ThinVec;\n\nuse abi::Abi;\nuse codemap::{respan, Spanned};\nuse ext::hygiene::{Mark, SyntaxContext};\nuse print::pprust;\nuse ptr::P;\nuse rustc_data_structures::indexed_vec;\nuse symbol::{keywords, Symbol};\nuse syntax_pos::{Span, DUMMY_SP};\nuse tokenstream::{ThinTokenStream, TokenStream};\n\nuse serialize::{self, Decoder, Encoder};\nuse std::collections::HashSet;\nuse std::fmt;\nuse std::rc::Rc;\nuse std::u32;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\npub struct Lifetime {\n    pub id: NodeId,\n    pub span: Span,\n    pub ident: Ident,\n}\n\nimpl fmt::Debug for Lifetime {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(\n            f,\n            \"lifetime({}: {})\",\n            self.id,\n            pprust::lifetime_to_string(self)\n        )\n    }\n}\n\n/// A lifetime definition, e.g. `'a: 'b+'c+'d`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct LifetimeDef {\n    pub attrs: ThinVec\u003cAttribute\u003e,\n    pub lifetime: Lifetime,\n    pub bounds: Vec\u003cLifetime\u003e,\n}\n\n/// A \"Path\" is essentially Rust's notion of a name.\n///\n/// It's represented as a sequence of identifiers,\n/// along with a bunch of supporting information.\n///\n/// E.g. `std::cmp::PartialEq`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub struct Path {\n    pub span: Span,\n    /// The segments in the path: the things separated by `::`.\n    /// Global paths begin with `keywords::CrateRoot`.\n    pub segments: Vec\u003cPathSegment\u003e,\n}\n\nimpl\u003c'a\u003e PartialEq\u003c\u0026'a str\u003e for Path {\n    fn eq(\u0026self, string: \u0026\u0026'a str) -\u003e bool {\n        self.segments.len() == 1 \u0026\u0026 self.segments[0].identifier.name == *string\n    }\n}\n\nimpl fmt::Debug for Path {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"path({})\", pprust::path_to_string(self))\n    }\n}\n\nimpl fmt::Display for Path {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", pprust::path_to_string(self))\n    }\n}\n\nimpl Path {\n    // convert a span and an identifier to the corresponding\n    // 1-segment path\n    pub fn from_ident(s: Span, identifier: Ident) -\u003e Path {\n        Path {\n            span: s,\n            segments: vec![PathSegment::from_ident(identifier, s)],\n        }\n    }\n\n    // Add starting \"crate root\" segment to all paths except those that\n    // already have it or start with `self`, `super`, `Self` or `$crate`.\n    pub fn default_to_global(mut self) -\u003e Path {\n        if !self.is_global() {\n            let ident = self.segments[0].identifier;\n            if !::parse::token::Ident(ident).is_path_segment_keyword()\n                || ident.name == keywords::Crate.name()\n            {\n                self.segments.insert(0, PathSegment::crate_root(self.span));\n            }\n        }\n        self\n    }\n\n    pub fn is_global(\u0026self) -\u003e bool {\n        !self.segments.is_empty() \u0026\u0026 self.segments[0].identifier.name == keywords::CrateRoot.name()\n    }\n}\n\n/// A segment of a path: an identifier, an optional lifetime, and a set of types.\n///\n/// E.g. `std`, `String` or `Box\u003cT\u003e`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct PathSegment {\n    /// The identifier portion of this path segment.\n    pub identifier: Ident,\n    /// Span of the segment identifier.\n    pub span: Span,\n\n    /// Type/lifetime parameters attached to this path. They come in\n    /// two flavors: `Path\u003cA,B,C\u003e` and `Path(A,B) -\u003e C`.\n    /// `None` means that no parameter list is supplied (`Path`),\n    /// `Some` means that parameter list is supplied (`Path\u003cX, Y\u003e`)\n    /// but it can be empty (`Path\u003c\u003e`).\n    /// `P` is used as a size optimization for the common case with no parameters.\n    pub parameters: Option\u003cP\u003cPathParameters\u003e\u003e,\n}\n\nimpl PathSegment {\n    pub fn from_ident(ident: Ident, span: Span) -\u003e Self {\n        PathSegment {\n            identifier: ident,\n            span: span,\n            parameters: None,\n        }\n    }\n    pub fn crate_root(span: Span) -\u003e Self {\n        PathSegment {\n            identifier: Ident {\n                ctxt: span.ctxt(),\n                ..keywords::CrateRoot.ident()\n            },\n            span,\n            parameters: None,\n        }\n    }\n}\n\n/// Parameters of a path segment.\n///\n/// E.g. `\u003cA, B\u003e` as in `Foo\u003cA, B\u003e` or `(A, B)` as in `Foo(A, B)`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum PathParameters {\n    /// The `\u003c'a, A,B,C\u003e` in `foo::bar::baz::\u003c'a, A,B,C\u003e`\n    AngleBracketed(AngleBracketedParameterData),\n    /// The `(A,B)` and `C` in `Foo(A,B) -\u003e C`\n    Parenthesized(ParenthesizedParameterData),\n}\n\nimpl PathParameters {\n    pub fn span(\u0026self) -\u003e Span {\n        match *self {\n            AngleBracketed(ref data) =\u003e data.span,\n            Parenthesized(ref data) =\u003e data.span,\n        }\n    }\n}\n\n/// A path like `Foo\u003c'a, T\u003e`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Default)]\npub struct AngleBracketedParameterData {\n    /// Overall span\n    pub span: Span,\n    /// The lifetime parameters for this path segment.\n    pub lifetimes: Vec\u003cLifetime\u003e,\n    /// The type parameters for this path segment, if present.\n    pub types: Vec\u003cP\u003cTy\u003e\u003e,\n    /// Bindings (equality constraints) on associated types, if present.\n    ///\n    /// E.g., `Foo\u003cA=Bar\u003e`.\n    pub bindings: Vec\u003cTypeBinding\u003e,\n}\n\nimpl Into\u003cOption\u003cP\u003cPathParameters\u003e\u003e\u003e for AngleBracketedParameterData {\n    fn into(self) -\u003e Option\u003cP\u003cPathParameters\u003e\u003e {\n        Some(P(PathParameters::AngleBracketed(self)))\n    }\n}\n\nimpl Into\u003cOption\u003cP\u003cPathParameters\u003e\u003e\u003e for ParenthesizedParameterData {\n    fn into(self) -\u003e Option\u003cP\u003cPathParameters\u003e\u003e {\n        Some(P(PathParameters::Parenthesized(self)))\n    }\n}\n\n/// A path like `Foo(A,B) -\u003e C`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct ParenthesizedParameterData {\n    /// Overall span\n    pub span: Span,\n\n    /// `(A,B)`\n    pub inputs: Vec\u003cP\u003cTy\u003e\u003e,\n\n    /// `C`\n    pub output: Option\u003cP\u003cTy\u003e\u003e,\n}\n\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Debug)]\npub struct NodeId(u32);\n\nimpl NodeId {\n    pub fn new(x: usize) -\u003e NodeId {\n        assert!(x \u003c (u32::MAX as usize));\n        NodeId(x as u32)\n    }\n\n    pub fn from_u32(x: u32) -\u003e NodeId {\n        NodeId(x)\n    }\n\n    pub fn as_usize(\u0026self) -\u003e usize {\n        self.0 as usize\n    }\n\n    pub fn as_u32(\u0026self) -\u003e u32 {\n        self.0\n    }\n\n    pub fn placeholder_from_mark(mark: Mark) -\u003e Self {\n        NodeId(mark.as_u32())\n    }\n\n    pub fn placeholder_to_mark(self) -\u003e Mark {\n        Mark::from_u32(self.0)\n    }\n}\n\nimpl fmt::Display for NodeId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(\u0026self.0, f)\n    }\n}\n\nimpl serialize::UseSpecializedEncodable for NodeId {\n    fn default_encode\u003cS: Encoder\u003e(\u0026self, s: \u0026mut S) -\u003e Result\u003c(), S::Error\u003e {\n        s.emit_u32(self.0)\n    }\n}\n\nimpl serialize::UseSpecializedDecodable for NodeId {\n    fn default_decode\u003cD: Decoder\u003e(d: \u0026mut D) -\u003e Result\u003cNodeId, D::Error\u003e {\n        d.read_u32().map(NodeId)\n    }\n}\n\nimpl indexed_vec::Idx for NodeId {\n    fn new(idx: usize) -\u003e Self {\n        NodeId::new(idx)\n    }\n\n    fn index(self) -\u003e usize {\n        self.as_usize()\n    }\n}\n\n/// Node id used to represent the root of the crate.\npub const CRATE_NODE_ID: NodeId = NodeId(0);\n\n/// When parsing and doing expansions, we initially give all AST nodes this AST\n/// node value. Then later, in the renumber pass, we renumber them to have\n/// small, positive ids.\npub const DUMMY_NODE_ID: NodeId = NodeId(!0);\n\n/// The AST represents all type param bounds as types.\n/// typeck::collect::compute_bounds matches these against\n/// the \"special\" built-in traits (see middle::lang_items) and\n/// detects Copy, Send and Sync.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum TyParamBound {\n    TraitTyParamBound(PolyTraitRef, TraitBoundModifier),\n    RegionTyParamBound(Lifetime),\n}\n\n/// A modifier on a bound, currently this is only used for `?Sized`, where the\n/// modifier is `Maybe`. Negative bounds should also be handled here.\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum TraitBoundModifier {\n    None,\n    Maybe,\n}\n\npub type TyParamBounds = Vec\u003cTyParamBound\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct TyParam {\n    pub attrs: ThinVec\u003cAttribute\u003e,\n    pub ident: Ident,\n    pub id: NodeId,\n    pub bounds: TyParamBounds,\n    pub default: Option\u003cP\u003cTy\u003e\u003e,\n    pub span: Span,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum GenericParam {\n    Lifetime(LifetimeDef),\n    Type(TyParam),\n}\n\nimpl GenericParam {\n    pub fn is_lifetime_param(\u0026self) -\u003e bool {\n        match *self {\n            GenericParam::Lifetime(_) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn is_type_param(\u0026self) -\u003e bool {\n        match *self {\n            GenericParam::Type(_) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n/// Represents lifetime, type and const parameters attached to a declaration of\n/// a function, enum, trait, etc.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Generics {\n    pub params: Vec\u003cGenericParam\u003e,\n    pub where_clause: WhereClause,\n    pub span: Span,\n}\n\nimpl Generics {\n    pub fn is_lt_parameterized(\u0026self) -\u003e bool {\n        self.params.iter().any(|param| param.is_lifetime_param())\n    }\n\n    pub fn is_type_parameterized(\u0026self) -\u003e bool {\n        self.params.iter().any(|param| param.is_type_param())\n    }\n\n    pub fn is_parameterized(\u0026self) -\u003e bool {\n        !self.params.is_empty()\n    }\n\n    pub fn span_for_name(\u0026self, name: \u0026str) -\u003e Option\u003cSpan\u003e {\n        for param in \u0026self.params {\n            if let GenericParam::Type(ref t) = *param {\n                if t.ident.name == name {\n                    return Some(t.span);\n                }\n            }\n        }\n        None\n    }\n}\n\nimpl Default for Generics {\n    /// Creates an instance of `Generics`.\n    fn default() -\u003e Generics {\n        Generics {\n            params: Vec::new(),\n            where_clause: WhereClause {\n                id: DUMMY_NODE_ID,\n                predicates: Vec::new(),\n                span: DUMMY_SP,\n            },\n            span: DUMMY_SP,\n        }\n    }\n}\n\n/// A `where` clause in a definition\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct WhereClause {\n    pub id: NodeId,\n    pub predicates: Vec\u003cWherePredicate\u003e,\n    pub span: Span,\n}\n\n/// A single predicate in a `where` clause\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum WherePredicate {\n    /// A type binding, e.g. `for\u003c'c\u003e Foo: Send+Clone+'c`\n    BoundPredicate(WhereBoundPredicate),\n    /// A lifetime predicate, e.g. `'a: 'b+'c`\n    RegionPredicate(WhereRegionPredicate),\n    /// An equality predicate (unsupported)\n    EqPredicate(WhereEqPredicate),\n}\n\n/// A type bound.\n///\n/// E.g. `for\u003c'c\u003e Foo: Send+Clone+'c`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct WhereBoundPredicate {\n    pub span: Span,\n    /// Any generics from a `for` binding\n    pub bound_generic_params: Vec\u003cGenericParam\u003e,\n    /// The type being bounded\n    pub bounded_ty: P\u003cTy\u003e,\n    /// Trait and lifetime bounds (`Clone+Send+'static`)\n    pub bounds: TyParamBounds,\n}\n\n/// A lifetime predicate.\n///\n/// E.g. `'a: 'b+'c`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct WhereRegionPredicate {\n    pub span: Span,\n    pub lifetime: Lifetime,\n    pub bounds: Vec\u003cLifetime\u003e,\n}\n\n/// An equality predicate (unsupported).\n///\n/// E.g. `T=int`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct WhereEqPredicate {\n    pub id: NodeId,\n    pub span: Span,\n    pub lhs_ty: P\u003cTy\u003e,\n    pub rhs_ty: P\u003cTy\u003e,\n}\n\n/// The set of MetaItems that define the compilation environment of the crate,\n/// used to drive conditional compilation\npub type CrateConfig = HashSet\u003c(Name, Option\u003cSymbol\u003e)\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Crate {\n    pub module: Mod,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub span: Span,\n}\n\n/// A spanned compile-time attribute list item.\npub type NestedMetaItem = Spanned\u003cNestedMetaItemKind\u003e;\n\n/// Possible values inside of compile-time attribute lists.\n///\n/// E.g. the '..' in `#[name(..)]`.\n#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialEq)]\npub enum NestedMetaItemKind {\n    /// A full MetaItem, for recursive meta items.\n    MetaItem(MetaItem),\n    /// A literal.\n    ///\n    /// E.g. \"foo\", 64, true\n    Literal(Lit),\n}\n\n/// A spanned compile-time attribute item.\n///\n/// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct MetaItem {\n    pub name: Name,\n    pub node: MetaItemKind,\n    pub span: Span,\n}\n\n/// A compile-time attribute item.\n///\n/// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum MetaItemKind {\n    /// Word meta item.\n    ///\n    /// E.g. `test` as in `#[test]`\n    Word,\n    /// List meta item.\n    ///\n    /// E.g. `derive(..)` as in `#[derive(..)]`\n    List(Vec\u003cNestedMetaItem\u003e),\n    /// Name value meta item.\n    ///\n    /// E.g. `feature = \"foo\"` as in `#[feature = \"foo\"]`\n    NameValue(Lit),\n}\n\n/// A Block (`{ .. }`).\n///\n/// E.g. `{ .. }` as in `fn foo() { .. }`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Block {\n    /// Statements in a block\n    pub stmts: Vec\u003cStmt\u003e,\n    pub id: NodeId,\n    /// Distinguishes between `unsafe { ... }` and `{ ... }`\n    pub rules: BlockCheckMode,\n    pub span: Span,\n    pub recovered: bool,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub struct Pat {\n    pub id: NodeId,\n    pub node: PatKind,\n    pub span: Span,\n}\n\nimpl fmt::Debug for Pat {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"pat({}: {})\", self.id, pprust::pat_to_string(self))\n    }\n}\n\nimpl Pat {\n    pub(super) fn to_ty(\u0026self) -\u003e Option\u003cP\u003cTy\u003e\u003e {\n        let node = match \u0026self.node {\n            PatKind::Wild =\u003e TyKind::Infer,\n            PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None) =\u003e {\n                TyKind::Path(None, Path::from_ident(ident.span, ident.node))\n            }\n            PatKind::Path(qself, path) =\u003e TyKind::Path(qself.clone(), path.clone()),\n            PatKind::Mac(mac) =\u003e TyKind::Mac(mac.clone()),\n            PatKind::Ref(pat, mutbl) =\u003e pat\n                .to_ty()\n                .map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n            PatKind::Slice(pats, None, _) if pats.len() == 1 =\u003e {\n                pats[0].to_ty().map(TyKind::Slice)?\n            }\n            PatKind::Tuple(pats, None) =\u003e {\n                let mut tys = Vec::new();\n                for pat in pats {\n                    tys.push(pat.to_ty()?);\n                }\n                TyKind::Tup(tys)\n            }\n            _ =\u003e return None,\n        };\n\n        Some(P(Ty {\n            node,\n            id: self.id,\n            span: self.span,\n        }))\n    }\n\n    pub fn walk\u003cF\u003e(\u0026self, it: \u0026mut F) -\u003e bool\n    where\n        F: FnMut(\u0026Pat) -\u003e bool,\n    {\n        if !it(self) {\n            return false;\n        }\n\n        match self.node {\n            PatKind::Ident(_, _, Some(ref p)) =\u003e p.walk(it),\n            PatKind::Struct(_, ref fields, _) =\u003e fields.iter().all(|field| field.node.pat.walk(it)),\n            PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) =\u003e {\n                s.iter().all(|p| p.walk(it))\n            }\n            PatKind::Box(ref s) | PatKind::Ref(ref s, _) =\u003e s.walk(it),\n            PatKind::Slice(ref before, ref slice, ref after) =\u003e {\n                before.iter().all(|p| p.walk(it))\n                    \u0026\u0026 slice.iter().all(|p| p.walk(it))\n                    \u0026\u0026 after.iter().all(|p| p.walk(it))\n            }\n            PatKind::Wild\n            | PatKind::Lit(_)\n            | PatKind::Range(..)\n            | PatKind::Ident(..)\n            | PatKind::Path(..)\n            | PatKind::Mac(_) =\u003e true,\n        }\n    }\n}\n\n/// A single field in a struct pattern\n///\n/// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n/// are treated the same as` x: x, y: ref y, z: ref mut z`,\n/// except is_shorthand is true\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct FieldPat {\n    /// The identifier for the field\n    pub ident: Ident,\n    /// The pattern the field is destructured to\n    pub pat: P\u003cPat\u003e,\n    pub is_shorthand: bool,\n    pub attrs: ThinVec\u003cAttribute\u003e,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum BindingMode {\n    ByRef(Mutability),\n    ByValue(Mutability),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum RangeEnd {\n    Included(RangeSyntax),\n    Excluded,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum RangeSyntax {\n    DotDotDot,\n    DotDotEq,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum PatKind {\n    /// Represents a wildcard pattern (`_`)\n    Wild,\n\n    /// A `PatKind::Ident` may either be a new bound variable (`ref mut binding @ OPT_SUBPATTERN`),\n    /// or a unit struct/variant pattern, or a const pattern (in the last two cases the third\n    /// field must be `None`). Disambiguation cannot be done with parser alone, so it happens\n    /// during name resolution.\n    Ident(BindingMode, SpannedIdent, Option\u003cP\u003cPat\u003e\u003e),\n\n    /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n    /// The `bool` is `true` in the presence of a `..`.\n    Struct(Path, Vec\u003cSpanned\u003cFieldPat\u003e\u003e, bool),\n\n    /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n    /// If the `..` pattern fragment is present, then `Option\u003cusize\u003e` denotes its position.\n    /// 0 \u003c= position \u003c= subpats.len()\n    TupleStruct(Path, Vec\u003cP\u003cPat\u003e\u003e, Option\u003cusize\u003e),\n\n    /// A possibly qualified path pattern.\n    /// Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants\n    /// or associated constants. Qualified path patterns `\u003cA\u003e::B::C`/`\u003cA as Trait\u003e::B::C` can\n    /// only legally refer to associated constants.\n    Path(Option\u003cQSelf\u003e, Path),\n\n    /// A tuple pattern `(a, b)`.\n    /// If the `..` pattern fragment is present, then `Option\u003cusize\u003e` denotes its position.\n    /// 0 \u003c= position \u003c= subpats.len()\n    Tuple(Vec\u003cP\u003cPat\u003e\u003e, Option\u003cusize\u003e),\n    /// A `box` pattern\n    Box(P\u003cPat\u003e),\n    /// A reference pattern, e.g. `\u0026mut (a, b)`\n    Ref(P\u003cPat\u003e, Mutability),\n    /// A literal\n    Lit(P\u003cExpr\u003e),\n    /// A range pattern, e.g. `1...2`, `1..=2` or `1..2`\n    Range(P\u003cExpr\u003e, P\u003cExpr\u003e, RangeEnd),\n    /// `[a, b, ..i, y, z]` is represented as:\n    ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n    Slice(Vec\u003cP\u003cPat\u003e\u003e, Option\u003cP\u003cPat\u003e\u003e, Vec\u003cP\u003cPat\u003e\u003e),\n    /// A macro pattern; pre-expansion\n    Mac(Mac),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum Mutability {\n    Mutable,\n    Immutable,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum BinOpKind {\n    /// The `+` operator (addition)\n    Add,\n    /// The `-` operator (subtraction)\n    Sub,\n    /// The `*` operator (multiplication)\n    Mul,\n    /// The `/` operator (division)\n    Div,\n    /// The `%` operator (modulus)\n    Rem,\n    /// The `\u0026\u0026` operator (logical and)\n    And,\n    /// The `||` operator (logical or)\n    Or,\n    /// The `^` operator (bitwise xor)\n    BitXor,\n    /// The `\u0026` operator (bitwise and)\n    BitAnd,\n    /// The `|` operator (bitwise or)\n    BitOr,\n    /// The `\u003c\u003c` operator (shift left)\n    Shl,\n    /// The `\u003e\u003e` operator (shift right)\n    Shr,\n    /// The `==` operator (equality)\n    Eq,\n    /// The `\u003c` operator (less than)\n    Lt,\n    /// The `\u003c=` operator (less than or equal to)\n    Le,\n    /// The `!=` operator (not equal to)\n    Ne,\n    /// The `\u003e=` operator (greater than or equal to)\n    Ge,\n    /// The `\u003e` operator (greater than)\n    Gt,\n}\n\nimpl BinOpKind {\n    pub fn to_string(\u0026self) -\u003e \u0026'static str {\n        use self::BinOpKind::*;\n        match *self {\n            Add =\u003e \"+\",\n            Sub =\u003e \"-\",\n            Mul =\u003e \"*\",\n            Div =\u003e \"/\",\n            Rem =\u003e \"%\",\n            And =\u003e \"\u0026\u0026\",\n            Or =\u003e \"||\",\n            BitXor =\u003e \"^\",\n            BitAnd =\u003e \"\u0026\",\n            BitOr =\u003e \"|\",\n            Shl =\u003e \"\u003c\u003c\",\n            Shr =\u003e \"\u003e\u003e\",\n            Eq =\u003e \"==\",\n            Lt =\u003e \"\u003c\",\n            Le =\u003e \"\u003c=\",\n            Ne =\u003e \"!=\",\n            Ge =\u003e \"\u003e=\",\n            Gt =\u003e \"\u003e\",\n        }\n    }\n    pub fn lazy(\u0026self) -\u003e bool {\n        match *self {\n            BinOpKind::And | BinOpKind::Or =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn is_shift(\u0026self) -\u003e bool {\n        match *self {\n            BinOpKind::Shl | BinOpKind::Shr =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn is_comparison(\u0026self) -\u003e bool {\n        use self::BinOpKind::*;\n        match *self {\n            Eq | Lt | Le | Ne | Gt | Ge =\u003e true,\n            And | Or | Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr =\u003e false,\n        }\n    }\n\n    /// Returns `true` if the binary operator takes its arguments by value\n    pub fn is_by_value(\u0026self) -\u003e bool {\n        !self.is_comparison()\n    }\n}\n\npub type BinOp = Spanned\u003cBinOpKind\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum UnOp {\n    /// The `*` operator for dereferencing\n    Deref,\n    /// The `!` operator for logical inversion\n    Not,\n    /// The `-` operator for negation\n    Neg,\n}\n\nimpl UnOp {\n    /// Returns `true` if the unary operator takes its argument by value\n    pub fn is_by_value(u: UnOp) -\u003e bool {\n        match u {\n            UnOp::Neg | UnOp::Not =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn to_string(op: UnOp) -\u003e \u0026'static str {\n        match op {\n            UnOp::Deref =\u003e \"*\",\n            UnOp::Not =\u003e \"!\",\n            UnOp::Neg =\u003e \"-\",\n        }\n    }\n}\n\n/// A statement\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub struct Stmt {\n    pub id: NodeId,\n    pub node: StmtKind,\n    pub span: Span,\n}\n\nimpl Stmt {\n    pub fn add_trailing_semicolon(mut self) -\u003e Self {\n        self.node = match self.node {\n            StmtKind::Expr(expr) =\u003e StmtKind::Semi(expr),\n            StmtKind::Mac(mac) =\u003e {\n                StmtKind::Mac(mac.map(|(mac, _style, attrs)| (mac, MacStmtStyle::Semicolon, attrs)))\n            }\n            node =\u003e node,\n        };\n        self\n    }\n\n    pub fn is_item(\u0026self) -\u003e bool {\n        match self.node {\n            StmtKind::Local(_) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl fmt::Debug for Stmt {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(\n            f,\n            \"stmt({}: {})\",\n            self.id.to_string(),\n            pprust::stmt_to_string(self)\n        )\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub enum StmtKind {\n    /// A local (let) binding.\n    Local(P\u003cLocal\u003e),\n\n    /// An item definition.\n    Item(P\u003cItem\u003e),\n\n    /// Expr without trailing semi-colon.\n    Expr(P\u003cExpr\u003e),\n    /// Expr with a trailing semi-colon.\n    Semi(P\u003cExpr\u003e),\n    /// Macro.\n    Mac(P\u003c(Mac, MacStmtStyle, ThinVec\u003cAttribute\u003e)\u003e),\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum MacStmtStyle {\n    /// The macro statement had a trailing semicolon, e.g. `foo! { ... };`\n    /// `foo!(...);`, `foo![...];`\n    Semicolon,\n    /// The macro statement had braces; e.g. foo! { ... }\n    Braces,\n    /// The macro statement had parentheses or brackets and no semicolon; e.g.\n    /// `foo!(...)`. All of these will end up being converted into macro\n    /// expressions.\n    NoBraces,\n}\n\n/// Local represents a `let` statement, e.g., `let \u003cpat\u003e:\u003cty\u003e = \u003cexpr\u003e;`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Local {\n    pub pat: P\u003cPat\u003e,\n    pub ty: Option\u003cP\u003cTy\u003e\u003e,\n    /// Initializer expression to set the value, if any\n    pub init: Option\u003cP\u003cExpr\u003e\u003e,\n    pub id: NodeId,\n    pub span: Span,\n    pub attrs: ThinVec\u003cAttribute\u003e,\n}\n\n/// An arm of a 'match'.\n///\n/// E.g. `0...10 =\u003e { println!(\"match!\") }` as in\n///\n/// ```\n/// match 123 {\n///     0...10 =\u003e { println!(\"match!\") },\n///     _ =\u003e { println!(\"no match!\") },\n/// }\n/// ```\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Arm {\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub pats: Vec\u003cP\u003cPat\u003e\u003e,\n    pub guard: Option\u003cP\u003cExpr\u003e\u003e,\n    pub body: P\u003cExpr\u003e,\n    pub beginning_vert: Option\u003cSpan\u003e, // For RFC 1925 feature gate\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Field {\n    pub ident: SpannedIdent,\n    pub expr: P\u003cExpr\u003e,\n    pub span: Span,\n    pub is_shorthand: bool,\n    pub attrs: ThinVec\u003cAttribute\u003e,\n}\n\npub type SpannedIdent = Spanned\u003cIdent\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum BlockCheckMode {\n    Default,\n    Unsafe(UnsafeSource),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum UnsafeSource {\n    CompilerGenerated,\n    UserProvided,\n}\n\n/// An expression\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub struct Expr {\n    pub id: NodeId,\n    pub node: ExprKind,\n    pub span: Span,\n    pub attrs: ThinVec\u003cAttribute\u003e,\n}\n\nimpl Expr {\n    /// Wether this expression would be valid somewhere that expects a value, for example, an `if`\n    /// condition.\n    pub fn returns(\u0026self) -\u003e bool {\n        if let ExprKind::Block(ref block) = self.node {\n            match block.stmts.last().map(|last_stmt| \u0026last_stmt.node) {\n                // implicit return\n                Some(\u0026StmtKind::Expr(_)) =\u003e true,\n                Some(\u0026StmtKind::Semi(ref expr)) =\u003e {\n                    if let ExprKind::Ret(_) = expr.node {\n                        // last statement is explicit return\n                        true\n                    } else {\n                        false\n                    }\n                }\n                // This is a block that doesn't end in either an implicit or explicit return\n                _ =\u003e false,\n            }\n        } else {\n            // This is not a block, it is a value\n            true\n        }\n    }\n\n    fn to_bound(\u0026self) -\u003e Option\u003cTyParamBound\u003e {\n        match \u0026self.node {\n            ExprKind::Path(None, path) =\u003e Some(TraitTyParamBound(\n                PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n                TraitBoundModifier::None,\n            )),\n            _ =\u003e None,\n        }\n    }\n\n    pub(super) fn to_ty(\u0026self) -\u003e Option\u003cP\u003cTy\u003e\u003e {\n        let node = match \u0026self.node {\n            ExprKind::Path(qself, path) =\u003e TyKind::Path(qself.clone(), path.clone()),\n            ExprKind::Mac(mac) =\u003e TyKind::Mac(mac.clone()),\n            ExprKind::Paren(expr) =\u003e expr.to_ty().map(TyKind::Paren)?,\n            ExprKind::AddrOf(mutbl, expr) =\u003e expr\n                .to_ty()\n                .map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n            ExprKind::Repeat(expr, expr_len) =\u003e {\n                expr.to_ty().map(|ty| TyKind::Array(ty, expr_len.clone()))?\n            }\n            ExprKind::Array(exprs) if exprs.len() == 1 =\u003e exprs[0].to_ty().map(TyKind::Slice)?,\n            ExprKind::Tup(exprs) =\u003e {\n                let mut tys = Vec::new();\n                for expr in exprs {\n                    tys.push(expr.to_ty()?);\n                }\n                TyKind::Tup(tys)\n            }\n            ExprKind::Binary(binop, lhs, rhs) if binop.node == BinOpKind::Add =\u003e {\n                if let (Some(lhs), Some(rhs)) = (lhs.to_bound(), rhs.to_bound()) {\n                    TyKind::TraitObject(vec![lhs, rhs], TraitObjectSyntax::None)\n                } else {\n                    return None;\n                }\n            }\n            _ =\u003e return None,\n        };\n\n        Some(P(Ty {\n            node,\n            id: self.id,\n            span: self.span,\n        }))\n    }\n\n    pub fn precedence(\u0026self) -\u003e ExprPrecedence {\n        match self.node {\n            ExprKind::Box(_) =\u003e ExprPrecedence::Box,\n            ExprKind::InPlace(..) =\u003e ExprPrecedence::InPlace,\n            ExprKind::Array(_) =\u003e ExprPrecedence::Array,\n            ExprKind::Call(..) =\u003e ExprPrecedence::Call,\n            ExprKind::MethodCall(..) =\u003e ExprPrecedence::MethodCall,\n            ExprKind::Tup(_) =\u003e ExprPrecedence::Tup,\n            ExprKind::Binary(op, ..) =\u003e ExprPrecedence::Binary(op.node),\n            ExprKind::Unary(..) =\u003e ExprPrecedence::Unary,\n            ExprKind::Lit(_) =\u003e ExprPrecedence::Lit,\n            ExprKind::Type(..) | ExprKind::Cast(..) =\u003e ExprPrecedence::Cast,\n            ExprKind::If(..) =\u003e ExprPrecedence::If,\n            ExprKind::IfLet(..) =\u003e ExprPrecedence::IfLet,\n            ExprKind::While(..) =\u003e ExprPrecedence::While,\n            ExprKind::WhileLet(..) =\u003e ExprPrecedence::WhileLet,\n            ExprKind::ForLoop(..) =\u003e ExprPrecedence::ForLoop,\n            ExprKind::Loop(..) =\u003e ExprPrecedence::Loop,\n            ExprKind::Match(..) =\u003e ExprPrecedence::Match,\n            ExprKind::Closure(..) =\u003e ExprPrecedence::Closure,\n            ExprKind::Block(..) =\u003e ExprPrecedence::Block,\n            ExprKind::Catch(..) =\u003e ExprPrecedence::Catch,\n            ExprKind::Assign(..) =\u003e ExprPrecedence::Assign,\n            ExprKind::AssignOp(..) =\u003e ExprPrecedence::AssignOp,\n            ExprKind::Field(..) =\u003e ExprPrecedence::Field,\n            ExprKind::TupField(..) =\u003e ExprPrecedence::TupField,\n            ExprKind::Index(..) =\u003e ExprPrecedence::Index,\n            ExprKind::Range(..) =\u003e ExprPrecedence::Range,\n            ExprKind::Path(..) =\u003e ExprPrecedence::Path,\n            ExprKind::AddrOf(..) =\u003e ExprPrecedence::AddrOf,\n            ExprKind::Break(..) =\u003e ExprPrecedence::Break,\n            ExprKind::Continue(..) =\u003e ExprPrecedence::Continue,\n            ExprKind::Ret(..) =\u003e ExprPrecedence::Ret,\n            ExprKind::InlineAsm(..) =\u003e ExprPrecedence::InlineAsm,\n            ExprKind::Mac(..) =\u003e ExprPrecedence::Mac,\n            ExprKind::Struct(..) =\u003e ExprPrecedence::Struct,\n            ExprKind::Repeat(..) =\u003e ExprPrecedence::Repeat,\n            ExprKind::Paren(..) =\u003e ExprPrecedence::Paren,\n            ExprKind::Try(..) =\u003e ExprPrecedence::Try,\n            ExprKind::Yield(..) =\u003e ExprPrecedence::Yield,\n        }\n    }\n}\n\nimpl fmt::Debug for Expr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"expr({}: {})\", self.id, pprust::expr_to_string(self))\n    }\n}\n\n/// Limit types of a range (inclusive or exclusive)\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum RangeLimits {\n    /// Inclusive at the beginning, exclusive at the end\n    HalfOpen,\n    /// Inclusive at the beginning and end\n    Closed,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum ExprKind {\n    /// A `box x` expression.\n    Box(P\u003cExpr\u003e),\n    /// First expr is the place; second expr is the value.\n    InPlace(P\u003cExpr\u003e, P\u003cExpr\u003e),\n    /// An array (`[a, b, c, d]`)\n    Array(Vec\u003cP\u003cExpr\u003e\u003e),\n    /// A function call\n    ///\n    /// The first field resolves to the function itself,\n    /// and the second field is the list of arguments.\n    /// This also represents calling the constructor of\n    /// tuple-like ADTs such as tuple structs and enum variants.\n    Call(P\u003cExpr\u003e, Vec\u003cP\u003cExpr\u003e\u003e),\n    /// A method call (`x.foo::\u003c'static, Bar, Baz\u003e(a, b, c, d)`)\n    ///\n    /// The `PathSegment` represents the method name and its generic arguments\n    /// (within the angle brackets).\n    /// The first element of the vector of `Expr`s is the expression that evaluates\n    /// to the object on which the method is being called on (the receiver),\n    /// and the remaining elements are the rest of the arguments.\n    /// Thus, `x.foo::\u003cBar, Baz\u003e(a, b, c, d)` is represented as\n    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n    MethodCall(PathSegment, Vec\u003cP\u003cExpr\u003e\u003e),\n    /// A tuple (`(a, b, c ,d)`)\n    Tup(Vec\u003cP\u003cExpr\u003e\u003e),\n    /// A binary operation (For example: `a + b`, `a * b`)\n    Binary(BinOp, P\u003cExpr\u003e, P\u003cExpr\u003e),\n    /// A unary operation (For example: `!x`, `*x`)\n    Unary(UnOp, P\u003cExpr\u003e),\n    /// A literal (For example: `1`, `\"foo\"`)\n    Lit(P\u003cLit\u003e),\n    /// A cast (`foo as f64`)\n    Cast(P\u003cExpr\u003e, P\u003cTy\u003e),\n    Type(P\u003cExpr\u003e, P\u003cTy\u003e),\n    /// An `if` block, with an optional else block\n    ///\n    /// `if expr { block } else { expr }`\n    If(P\u003cExpr\u003e, P\u003cBlock\u003e, Option\u003cP\u003cExpr\u003e\u003e),\n    /// An `if let` expression with an optional else block\n    ///\n    /// `if let pat = expr { block } else { expr }`\n    ///\n    /// This is desugared to a `match` expression.\n    IfLet(P\u003cPat\u003e, P\u003cExpr\u003e, P\u003cBlock\u003e, Option\u003cP\u003cExpr\u003e\u003e),\n    /// A while loop, with an optional label\n    ///\n    /// `'label: while expr { block }`\n    While(P\u003cExpr\u003e, P\u003cBlock\u003e, Option\u003cSpannedIdent\u003e),\n    /// A while-let loop, with an optional label\n    ///\n    /// `'label: while let pat = expr { block }`\n    ///\n    /// This is desugared to a combination of `loop` and `match` expressions.\n    WhileLet(P\u003cPat\u003e, P\u003cExpr\u003e, P\u003cBlock\u003e, Option\u003cSpannedIdent\u003e),\n    /// A for loop, with an optional label\n    ///\n    /// `'label: for pat in expr { block }`\n    ///\n    /// This is desugared to a combination of `loop` and `match` expressions.\n    ForLoop(P\u003cPat\u003e, P\u003cExpr\u003e, P\u003cBlock\u003e, Option\u003cSpannedIdent\u003e),\n    /// Conditionless loop (can be exited with break, continue, or return)\n    ///\n    /// `'label: loop { block }`\n    Loop(P\u003cBlock\u003e, Option\u003cSpannedIdent\u003e),\n    /// A `match` block.\n    Match(P\u003cExpr\u003e, Vec\u003cArm\u003e),\n    /// A closure (for example, `move |a, b, c| a + b + c`)\n    ///\n    /// The final span is the span of the argument block `|...|`\n    Closure(CaptureBy, P\u003cFnDecl\u003e, P\u003cExpr\u003e, Span),\n    /// A block (`{ ... }`)\n    Block(P\u003cBlock\u003e),\n    /// A catch block (`catch { ... }`)\n    Catch(P\u003cBlock\u003e),\n\n    /// An assignment (`a = foo()`)\n    Assign(P\u003cExpr\u003e, P\u003cExpr\u003e),\n    /// An assignment with an operator\n    ///\n    /// For example, `a += 1`.\n    AssignOp(BinOp, P\u003cExpr\u003e, P\u003cExpr\u003e),\n    /// Access of a named struct field (`obj.foo`)\n    Field(P\u003cExpr\u003e, SpannedIdent),\n    /// Access of an unnamed field of a struct or tuple-struct\n    ///\n    /// For example, `foo.0`.\n    TupField(P\u003cExpr\u003e, Spanned\u003cusize\u003e),\n    /// An indexing operation (`foo[2]`)\n    Index(P\u003cExpr\u003e, P\u003cExpr\u003e),\n    /// A range (`1..2`, `1..`, `..2`, `1...2`, `1...`, `...2`)\n    Range(Option\u003cP\u003cExpr\u003e\u003e, Option\u003cP\u003cExpr\u003e\u003e, RangeLimits),\n\n    /// Variable reference, possibly containing `::` and/or type\n    /// parameters, e.g. foo::bar::\u003cbaz\u003e.\n    ///\n    /// Optionally \"qualified\",\n    /// E.g. `\u003cVec\u003cT\u003e as SomeTrait\u003e::SomeType`.\n    Path(Option\u003cQSelf\u003e, Path),\n\n    /// A referencing operation (`\u0026a` or `\u0026mut a`)\n    AddrOf(Mutability, P\u003cExpr\u003e),\n    /// A `break`, with an optional label to break, and an optional expression\n    Break(Option\u003cSpannedIdent\u003e, Option\u003cP\u003cExpr\u003e\u003e),\n    /// A `continue`, with an optional label\n    Continue(Option\u003cSpannedIdent\u003e),\n    /// A `return`, with an optional value to be returned\n    Ret(Option\u003cP\u003cExpr\u003e\u003e),\n\n    /// Output of the `asm!()` macro\n    InlineAsm(P\u003cInlineAsm\u003e),\n\n    /// A macro invocation; pre-expansion\n    Mac(Mac),\n\n    /// A struct literal expression.\n    ///\n    /// For example, `Foo {x: 1, y: 2}`, or\n    /// `Foo {x: 1, .. base}`, where `base` is the `Option\u003cExpr\u003e`.\n    Struct(Path, Vec\u003cField\u003e, Option\u003cP\u003cExpr\u003e\u003e),\n\n    /// An array literal constructed from one repeated element.\n    ///\n    /// For example, `[1; 5]`. The first expression is the element\n    /// to be repeated; the second is the number of times to repeat it.\n    Repeat(P\u003cExpr\u003e, P\u003cExpr\u003e),\n\n    /// No-op: used solely so we can pretty-print faithfully\n    Paren(P\u003cExpr\u003e),\n\n    /// `expr?`\n    Try(P\u003cExpr\u003e),\n\n    /// A `yield`, with an optional value to be yielded\n    Yield(Option\u003cP\u003cExpr\u003e\u003e),\n}\n\n/// The explicit Self type in a \"qualified path\". The actual\n/// path, including the trait and the associated item, is stored\n/// separately. `position` represents the index of the associated\n/// item qualified with this Self type.\n///\n/// ```ignore (only-for-syntax-highlight)\n/// \u003cVec\u003cT\u003e as a::b::Trait\u003e::AssociatedItem\n///  ^~~~~     ~~~~~~~~~~~~~~^\n///  ty        position = 3\n///\n/// \u003cVec\u003cT\u003e\u003e::AssociatedItem\n///  ^~~~~    ^\n///  ty       position = 0\n/// ```\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct QSelf {\n    pub ty: P\u003cTy\u003e,\n    pub position: usize,\n}\n\n/// A capture clause\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum CaptureBy {\n    Value,\n    Ref,\n}\n\npub type Mac = Spanned\u003cMac_\u003e;\n\n/// Represents a macro invocation. The Path indicates which macro\n/// is being invoked, and the vector of token-trees contains the source\n/// of the macro invocation.\n///\n/// NB: the additional ident for a macro_rules-style macro is actually\n/// stored in the enclosing item. Oog.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Mac_ {\n    pub path: Path,\n    pub tts: ThinTokenStream,\n}\n\nimpl Mac_ {\n    pub fn stream(\u0026self) -\u003e TokenStream {\n        self.tts.clone().into()\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct MacroDef {\n    pub tokens: ThinTokenStream,\n    pub legacy: bool,\n}\n\nimpl MacroDef {\n    pub fn stream(\u0026self) -\u003e TokenStream {\n        self.tokens.clone().into()\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum StrStyle {\n    /// A regular string, like `\"foo\"`\n    Cooked,\n    /// A raw string, like `r##\"foo\"##`\n    ///\n    /// The uint is the number of `#` symbols used\n    Raw(usize),\n}\n\n/// A literal\npub type Lit = Spanned\u003cLitKind\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum LitIntType {\n    Signed(IntTy),\n    Unsigned(UintTy),\n    Unsuffixed,\n}\n\n/// Literal kind.\n///\n/// E.g. `\"foo\"`, `42`, `12.34` or `bool`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum LitKind {\n    /// A string literal (`\"foo\"`)\n    Str(Symbol, StrStyle),\n    /// A byte string (`b\"foo\"`)\n    ByteStr(Rc\u003cVec\u003cu8\u003e\u003e),\n    /// A byte char (`b'f'`)\n    Byte(u8),\n    /// A character literal (`'a'`)\n    Char(char),\n    /// An integer literal (`1`)\n    Int(u128, LitIntType),\n    /// A float literal (`1f64` or `1E10f64`)\n    Float(Symbol, FloatTy),\n    /// A float literal without a suffix (`1.0 or 1.0E10`)\n    FloatUnsuffixed(Symbol),\n    /// A boolean literal\n    Bool(bool),\n}\n\nimpl LitKind {\n    /// Returns true if this literal is a string and false otherwise.\n    pub fn is_str(\u0026self) -\u003e bool {\n        match *self {\n            LitKind::Str(..) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    /// Returns true if this literal has no suffix. Note: this will return true\n    /// for literals with prefixes such as raw strings and byte strings.\n    pub fn is_unsuffixed(\u0026self) -\u003e bool {\n        match *self {\n            // unsuffixed variants\n            LitKind::Str(..)\n            | LitKind::ByteStr(..)\n            | LitKind::Byte(..)\n            | LitKind::Char(..)\n            | LitKind::Int(_, LitIntType::Unsuffixed)\n            | LitKind::FloatUnsuffixed(..)\n            | LitKind::Bool(..) =\u003e true,\n            // suffixed variants\n            LitKind::Int(_, LitIntType::Signed(..))\n            | LitKind::Int(_, LitIntType::Unsigned(..))\n            | LitKind::Float(..) =\u003e false,\n        }\n    }\n\n    /// Returns true if this literal has a suffix.\n    pub fn is_suffixed(\u0026self) -\u003e bool {\n        !self.is_unsuffixed()\n    }\n}\n\n// NB: If you change this, you'll probably want to change the corresponding\n// type structure in middle/ty.rs as well.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct MutTy {\n    pub ty: P\u003cTy\u003e,\n    pub mutbl: Mutability,\n}\n\n/// Represents a method's signature in a trait declaration,\n/// or in an implementation.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct MethodSig {\n    pub unsafety: Unsafety,\n    pub constness: Spanned\u003cConstness\u003e,\n    pub abi: Abi,\n    pub decl: P\u003cFnDecl\u003e,\n}\n\n/// Represents an item declaration within a trait declaration,\n/// possibly including a default implementation. A trait item is\n/// either required (meaning it doesn't have an implementation, just a\n/// signature) or provided (meaning it has a default implementation).\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct TraitItem {\n    pub id: NodeId,\n    pub ident: Ident,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub generics: Generics,\n    pub node: TraitItemKind,\n    pub span: Span,\n    /// See `Item::tokens` for what this is\n    pub tokens: Option\u003cTokenStream\u003e,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum TraitItemKind {\n    Const(P\u003cTy\u003e, Option\u003cP\u003cExpr\u003e\u003e),\n    Method(MethodSig, Option\u003cP\u003cBlock\u003e\u003e),\n    Type(TyParamBounds, Option\u003cP\u003cTy\u003e\u003e),\n    Macro(Mac),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct ImplItem {\n    pub id: NodeId,\n    pub ident: Ident,\n    pub vis: Visibility,\n    pub defaultness: Defaultness,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub generics: Generics,\n    pub node: ImplItemKind,\n    pub span: Span,\n    /// See `Item::tokens` for what this is\n    pub tokens: Option\u003cTokenStream\u003e,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum ImplItemKind {\n    Const(P\u003cTy\u003e, P\u003cExpr\u003e),\n    Method(MethodSig, P\u003cBlock\u003e),\n    Type(P\u003cTy\u003e),\n    Macro(Mac),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, PartialOrd, Ord)]\npub enum IntTy {\n    Isize,\n    I8,\n    I16,\n    I32,\n    I64,\n    I128,\n}\n\nimpl fmt::Debug for IntTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}\n\nimpl fmt::Display for IntTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.ty_to_string())\n    }\n}\n\nimpl IntTy {\n    pub fn ty_to_string(\u0026self) -\u003e \u0026'static str {\n        match *self {\n            IntTy::Isize =\u003e \"isize\",\n            IntTy::I8 =\u003e \"i8\",\n            IntTy::I16 =\u003e \"i16\",\n            IntTy::I32 =\u003e \"i32\",\n            IntTy::I64 =\u003e \"i64\",\n            IntTy::I128 =\u003e \"i128\",\n        }\n    }\n\n    pub fn val_to_string(\u0026self, val: i128) -\u003e String {\n        // cast to a u128 so we can correctly print INT128_MIN. All integral types\n        // are parsed as u128, so we wouldn't want to print an extra negative\n        // sign.\n        format!(\"{}{}\", val as u128, self.ty_to_string())\n    }\n\n    pub fn bit_width(\u0026self) -\u003e Option\u003cusize\u003e {\n        Some(match *self {\n            IntTy::Isize =\u003e return None,\n            IntTy::I8 =\u003e 8,\n            IntTy::I16 =\u003e 16,\n            IntTy::I32 =\u003e 32,\n            IntTy::I64 =\u003e 64,\n            IntTy::I128 =\u003e 128,\n        })\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, PartialOrd, Ord)]\npub enum UintTy {\n    Usize,\n    U8,\n    U16,\n    U32,\n    U64,\n    U128,\n}\n\nimpl UintTy {\n    pub fn ty_to_string(\u0026self) -\u003e \u0026'static str {\n        match *self {\n            UintTy::Usize =\u003e \"usize\",\n            UintTy::U8 =\u003e \"u8\",\n            UintTy::U16 =\u003e \"u16\",\n            UintTy::U32 =\u003e \"u32\",\n            UintTy::U64 =\u003e \"u64\",\n            UintTy::U128 =\u003e \"u128\",\n        }\n    }\n\n    pub fn val_to_string(\u0026self, val: u128) -\u003e String {\n        format!(\"{}{}\", val, self.ty_to_string())\n    }\n\n    pub fn bit_width(\u0026self) -\u003e Option\u003cusize\u003e {\n        Some(match *self {\n            UintTy::Usize =\u003e return None,\n            UintTy::U8 =\u003e 8,\n            UintTy::U16 =\u003e 16,\n            UintTy::U32 =\u003e 32,\n            UintTy::U64 =\u003e 64,\n            UintTy::U128 =\u003e 128,\n        })\n    }\n}\n\nimpl fmt::Debug for UintTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}\n\nimpl fmt::Display for UintTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.ty_to_string())\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, PartialOrd, Ord)]\npub enum FloatTy {\n    F32,\n    F64,\n}\n\nimpl fmt::Debug for FloatTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}\n\nimpl fmt::Display for FloatTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.ty_to_string())\n    }\n}\n\nimpl FloatTy {\n    pub fn ty_to_string(\u0026self) -\u003e \u0026'static str {\n        match *self {\n            FloatTy::F32 =\u003e \"f32\",\n            FloatTy::F64 =\u003e \"f64\",\n        }\n    }\n\n    pub fn bit_width(\u0026self) -\u003e usize {\n        match *self {\n            FloatTy::F32 =\u003e 32,\n            FloatTy::F64 =\u003e 64,\n        }\n    }\n}\n\n// Bind a type to an associated type: `A=Foo`.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct TypeBinding {\n    pub id: NodeId,\n    pub ident: Ident,\n    pub ty: P\u003cTy\u003e,\n    pub span: Span,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub struct Ty {\n    pub id: NodeId,\n    pub node: TyKind,\n    pub span: Span,\n}\n\nimpl fmt::Debug for Ty {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"type({})\", pprust::ty_to_string(self))\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct BareFnTy {\n    pub unsafety: Unsafety,\n    pub abi: Abi,\n    pub generic_params: Vec\u003cGenericParam\u003e,\n    pub decl: P\u003cFnDecl\u003e,\n}\n\n/// The different kinds of types recognized by the compiler\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum TyKind {\n    /// A variable-length slice (`[T]`)\n    Slice(P\u003cTy\u003e),\n    /// A fixed length array (`[T; n]`)\n    Array(P\u003cTy\u003e, P\u003cExpr\u003e),\n    /// A raw pointer (`*const T` or `*mut T`)\n    Ptr(MutTy),\n    /// A reference (`\u0026'a T` or `\u0026'a mut T`)\n    Rptr(Option\u003cLifetime\u003e, MutTy),\n    /// A bare function (e.g. `fn(usize) -\u003e bool`)\n    BareFn(P\u003cBareFnTy\u003e),\n    /// The never type (`!`)\n    Never,\n    /// A tuple (`(A, B, C, D,...)`)\n    Tup(Vec\u003cP\u003cTy\u003e\u003e),\n    /// A path (`module::module::...::Type`), optionally\n    /// \"qualified\", e.g. `\u003cVec\u003cT\u003e as SomeTrait\u003e::SomeType`.\n    ///\n    /// Type parameters are stored in the Path itself\n    Path(Option\u003cQSelf\u003e, Path),\n    /// A trait object type `Bound1 + Bound2 + Bound3`\n    /// where `Bound` is a trait or a lifetime.\n    TraitObject(TyParamBounds, TraitObjectSyntax),\n    /// An `impl Bound1 + Bound2 + Bound3` type\n    /// where `Bound` is a trait or a lifetime.\n    ImplTrait(TyParamBounds),\n    /// No-op; kept solely so that we can pretty-print faithfully\n    Paren(P\u003cTy\u003e),\n    /// Unused for now\n    Typeof(P\u003cExpr\u003e),\n    /// TyKind::Infer means the type should be inferred instead of it having been\n    /// specified. This can appear anywhere in a type.\n    Infer,\n    /// Inferred type of a `self` or `\u0026self` argument in a method.\n    ImplicitSelf,\n    // A macro in the type position.\n    Mac(Mac),\n    /// Placeholder for a kind that has failed to be defined.\n    Err,\n}\n\n/// Syntax used to declare a trait object.\n#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum TraitObjectSyntax {\n    Dyn,\n    None,\n}\n\n/// Inline assembly dialect.\n///\n/// E.g. `\"intel\"` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum AsmDialect {\n    Att,\n    Intel,\n}\n\n/// Inline assembly.\n///\n/// E.g. `\"={eax}\"(result)` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct InlineAsmOutput {\n    pub constraint: Symbol,\n    pub expr: P\u003cExpr\u003e,\n    pub is_rw: bool,\n    pub is_indirect: bool,\n}\n\n/// Inline assembly.\n///\n/// E.g. `asm!(\"NOP\");`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct InlineAsm {\n    pub asm: Symbol,\n    pub asm_str_style: StrStyle,\n    pub outputs: Vec\u003cInlineAsmOutput\u003e,\n    pub inputs: Vec\u003c(Symbol, P\u003cExpr\u003e)\u003e,\n    pub clobbers: Vec\u003cSymbol\u003e,\n    pub volatile: bool,\n    pub alignstack: bool,\n    pub dialect: AsmDialect,\n    pub ctxt: SyntaxContext,\n}\n\n/// An argument in a function header.\n///\n/// E.g. `bar: usize` as in `fn foo(bar: usize)`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Arg {\n    pub ty: P\u003cTy\u003e,\n    pub pat: P\u003cPat\u003e,\n    pub id: NodeId,\n}\n\n/// Alternative representation for `Arg`s describing `self` parameter of methods.\n///\n/// E.g. `\u0026mut self` as in `fn foo(\u0026mut self)`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum SelfKind {\n    /// `self`, `mut self`\n    Value(Mutability),\n    /// `\u0026'lt self`, `\u0026'lt mut self`\n    Region(Option\u003cLifetime\u003e, Mutability),\n    /// `self: TYPE`, `mut self: TYPE`\n    Explicit(P\u003cTy\u003e, Mutability),\n}\n\npub type ExplicitSelf = Spanned\u003cSelfKind\u003e;\n\nimpl Arg {\n    pub fn to_self(\u0026self) -\u003e Option\u003cExplicitSelf\u003e {\n        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n            if ident.node.name == keywords::SelfValue.name() {\n                return match self.ty.node {\n                    TyKind::ImplicitSelf =\u003e Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n                    TyKind::Rptr(lt, MutTy { ref ty, mutbl })\n                        if ty.node == TyKind::ImplicitSelf =\u003e\n                    {\n                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                    }\n                    _ =\u003e Some(respan(\n                        self.pat.span.to(self.ty.span),\n                        SelfKind::Explicit(self.ty.clone(), mutbl),\n                    )),\n                };\n            }\n        }\n        None\n    }\n\n    pub fn is_self(\u0026self) -\u003e bool {\n        if let PatKind::Ident(_, ident, _) = self.pat.node {\n            ident.node.name == keywords::SelfValue.name()\n        } else {\n            false\n        }\n    }\n\n    pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -\u003e Arg {\n        let span = eself.span.to(eself_ident.span);\n        let infer_ty = P(Ty {\n            id: DUMMY_NODE_ID,\n            node: TyKind::ImplicitSelf,\n            span,\n        });\n        let arg = |mutbl, ty| Arg {\n            pat: P(Pat {\n                id: DUMMY_NODE_ID,\n                node: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n                span,\n            }),\n            ty,\n            id: DUMMY_NODE_ID,\n        };\n        match eself.node {\n            SelfKind::Explicit(ty, mutbl) =\u003e arg(mutbl, ty),\n            SelfKind::Value(mutbl) =\u003e arg(mutbl, infer_ty),\n            SelfKind::Region(lt, mutbl) =\u003e arg(\n                Mutability::Immutable,\n                P(Ty {\n                    id: DUMMY_NODE_ID,\n                    node: TyKind::Rptr(\n                        lt,\n                        MutTy {\n                            ty: infer_ty,\n                            mutbl: mutbl,\n                        },\n                    ),\n                    span,\n                }),\n            ),\n        }\n    }\n}\n\n/// Header (not the body) of a function declaration.\n///\n/// E.g. `fn foo(bar: baz)`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct FnDecl {\n    pub inputs: Vec\u003cArg\u003e,\n    pub output: FunctionRetTy,\n    pub variadic: bool,\n}\n\nimpl FnDecl {\n    pub fn get_self(\u0026self) -\u003e Option\u003cExplicitSelf\u003e {\n        self.inputs.get(0).and_then(Arg::to_self)\n    }\n    pub fn has_self(\u0026self) -\u003e bool {\n        self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n    }\n}\n\n/// Is the trait definition an auto trait?\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum IsAuto {\n    Yes,\n    No,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum Unsafety {\n    Unsafe,\n    Normal,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum Constness {\n    Const,\n    NotConst,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum Defaultness {\n    Default,\n    Final,\n}\n\nimpl fmt::Display for Unsafety {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(\n            match *self {\n                Unsafety::Normal =\u003e \"normal\",\n                Unsafety::Unsafe =\u003e \"unsafe\",\n            },\n            f,\n        )\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub enum ImplPolarity {\n    /// `impl Trait for Type`\n    Positive,\n    /// `impl !Trait for Type`\n    Negative,\n}\n\nimpl fmt::Debug for ImplPolarity {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match *self {\n            ImplPolarity::Positive =\u003e \"positive\".fmt(f),\n            ImplPolarity::Negative =\u003e \"negative\".fmt(f),\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum FunctionRetTy {\n    /// Return type is not specified.\n    ///\n    /// Functions default to `()` and\n    /// closures default to inference. Span points to where return\n    /// type would be inserted.\n    Default(Span),\n    /// Everything else\n    Ty(P\u003cTy\u003e),\n}\n\nimpl FunctionRetTy {\n    pub fn span(\u0026self) -\u003e Span {\n        match *self {\n            FunctionRetTy::Default(span) =\u003e span,\n            FunctionRetTy::Ty(ref ty) =\u003e ty.span,\n        }\n    }\n}\n\n/// Module declaration.\n///\n/// E.g. `mod foo;` or `mod foo { .. }`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Mod {\n    /// A span from the first token past `{` to the last token until `}`.\n    /// For `mod foo;`, the inner span ranges from the first token\n    /// to the last token in the external file.\n    pub inner: Span,\n    pub items: Vec\u003cP\u003cItem\u003e\u003e,\n}\n\n/// Foreign module declaration.\n///\n/// E.g. `extern { .. }` or `extern C { .. }`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct ForeignMod {\n    pub abi: Abi,\n    pub items: Vec\u003cForeignItem\u003e,\n}\n\n/// Global inline assembly\n///\n/// aka module-level assembly or file-scoped assembly\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub struct GlobalAsm {\n    pub asm: Symbol,\n    pub ctxt: SyntaxContext,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct EnumDef {\n    pub variants: Vec\u003cVariant\u003e,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Variant_ {\n    pub name: Ident,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub data: VariantData,\n    /// Explicit discriminant, e.g. `Foo = 1`\n    pub disr_expr: Option\u003cP\u003cExpr\u003e\u003e,\n}\n\npub type Variant = Spanned\u003cVariant_\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum UseTreeKind {\n    Simple(Ident),\n    Glob,\n    Nested(Vec\u003c(UseTree, NodeId)\u003e),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct UseTree {\n    pub kind: UseTreeKind,\n    pub prefix: Path,\n    pub span: Span,\n}\n\n/// Distinguishes between Attributes that decorate items and Attributes that\n/// are contained as statements within items. These two cases need to be\n/// distinguished for pretty-printing.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum AttrStyle {\n    Outer,\n    Inner,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub struct AttrId(pub usize);\n\n/// Meta-data associated with an item\n/// Doc-comments are promoted to attributes that have is_sugared_doc = true\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Attribute {\n    pub id: AttrId,\n    pub style: AttrStyle,\n    pub path: Path,\n    pub tokens: TokenStream,\n    pub is_sugared_doc: bool,\n    pub span: Span,\n}\n\n/// TraitRef's appear in impls.\n///\n/// resolve maps each TraitRef's ref_id to its defining trait; that's all\n/// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n/// If this impl is an ItemKind::Impl, the impl_id is redundant (it could be the\n/// same as the impl's node id).\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct TraitRef {\n    pub path: Path,\n    pub ref_id: NodeId,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct PolyTraitRef {\n    /// The `'a` in `\u003c'a\u003e Foo\u003c\u0026'a T\u003e`\n    pub bound_generic_params: Vec\u003cGenericParam\u003e,\n\n    /// The `Foo\u003c\u0026'a T\u003e` in `\u003c'a\u003e Foo\u003c\u0026'a T\u003e`\n    pub trait_ref: TraitRef,\n\n    pub span: Span,\n}\n\nimpl PolyTraitRef {\n    pub fn new(generic_params: Vec\u003cGenericParam\u003e, path: Path, span: Span) -\u003e Self {\n        PolyTraitRef {\n            bound_generic_params: generic_params,\n            trait_ref: TraitRef {\n                path: path,\n                ref_id: DUMMY_NODE_ID,\n            },\n            span,\n        }\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum CrateSugar {\n    /// Source is `pub(crate)`\n    PubCrate,\n\n    /// Source is (just) `crate`\n    JustCrate,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum Visibility {\n    Public,\n    Crate(Span, CrateSugar),\n    Restricted { path: P\u003cPath\u003e, id: NodeId },\n    Inherited,\n}\n\n/// Field of a struct.\n///\n/// E.g. `bar: usize` as in `struct Foo { bar: usize }`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct StructField {\n    pub span: Span,\n    pub ident: Option\u003cIdent\u003e,\n    pub vis: Visibility,\n    pub id: NodeId,\n    pub ty: P\u003cTy\u003e,\n    pub attrs: Vec\u003cAttribute\u003e,\n}\n\n/// Fields and Ids of enum variants and structs\n///\n/// For enum variants: `NodeId` represents both an Id of the variant itself (relevant for all\n/// variant kinds) and an Id of the variant's constructor (not relevant for `Struct`-variants).\n/// One shared Id can be successfully used for these two purposes.\n/// Id of the whole enum lives in `Item`.\n///\n/// For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually\n/// used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of\n/// the variant itself\" from enum variants.\n/// Id of the whole struct lives in `Item`.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum VariantData {\n    /// Struct variant.\n    ///\n    /// E.g. `Bar { .. }` as in `enum Foo { Bar { .. } }`\n    Struct(Vec\u003cStructField\u003e, NodeId),\n    /// Tuple variant.\n    ///\n    /// E.g. `Bar(..)` as in `enum Foo { Bar(..) }`\n    Tuple(Vec\u003cStructField\u003e, NodeId),\n    /// Unit variant.\n    ///\n    /// E.g. `Bar = ..` as in `enum Foo { Bar = .. }`\n    Unit(NodeId),\n}\n\nimpl VariantData {\n    pub fn fields(\u0026self) -\u003e \u0026[StructField] {\n        match *self {\n            VariantData::Struct(ref fields, _) | VariantData::Tuple(ref fields, _) =\u003e fields,\n            _ =\u003e \u0026[],\n        }\n    }\n    pub fn id(\u0026self) -\u003e NodeId {\n        match *self {\n            VariantData::Struct(_, id) | VariantData::Tuple(_, id) | VariantData::Unit(id) =\u003e id,\n        }\n    }\n    pub fn is_struct(\u0026self) -\u003e bool {\n        if let VariantData::Struct(..) = *self {\n            true\n        } else {\n            false\n        }\n    }\n    pub fn is_tuple(\u0026self) -\u003e bool {\n        if let VariantData::Tuple(..) = *self {\n            true\n        } else {\n            false\n        }\n    }\n    pub fn is_unit(\u0026self) -\u003e bool {\n        if let VariantData::Unit(..) = *self {\n            true\n        } else {\n            false\n        }\n    }\n}\n\n/// An item\n///\n/// The name might be a dummy name in case of anonymous items\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Item {\n    pub ident: Ident,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub id: NodeId,\n    pub node: ItemKind,\n    pub vis: Visibility,\n    pub span: Span,\n\n    /// Original tokens this item was parsed from. This isn't necessarily\n    /// available for all items, although over time more and more items should\n    /// have this be `Some`. Right now this is primarily used for procedural\n    /// macros, notably custom attributes.\n    ///\n    /// Note that the tokens here do not include the outer attributes, but will\n    /// include inner attributes.\n    pub tokens: Option\u003cTokenStream\u003e,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum ItemKind {\n    /// An `extern crate` item, with optional original crate name.\n    ///\n    /// E.g. `extern crate foo` or `extern crate foo_bar as foo`\n    ExternCrate(Option\u003cName\u003e),\n    /// A use declaration (`use` or `pub use`) item.\n    ///\n    /// E.g. `use foo;`, `use foo::bar;` or `use foo::bar as FooBar;`\n    Use(P\u003cUseTree\u003e),\n    /// A static item (`static` or `pub static`).\n    ///\n    /// E.g. `static FOO: i32 = 42;` or `static FOO: \u0026'static str = \"bar\";`\n    Static(P\u003cTy\u003e, Mutability, P\u003cExpr\u003e),\n    /// A constant item (`const` or `pub const`).\n    ///\n    /// E.g. `const FOO: i32 = 42;`\n    Const(P\u003cTy\u003e, P\u003cExpr\u003e),\n    /// A function declaration (`fn` or `pub fn`).\n    ///\n    /// E.g. `fn foo(bar: usize) -\u003e usize { .. }`\n    Fn(\n        P\u003cFnDecl\u003e,\n        Unsafety,\n        Spanned\u003cConstness\u003e,\n        Abi,\n        Generics,\n        P\u003cBlock\u003e,\n    ),\n    /// A module declaration (`mod` or `pub mod`).\n    ///\n    /// E.g. `mod foo;` or `mod foo { .. }`\n    Mod(Mod),\n    /// An external module (`extern` or `pub extern`).\n    ///\n    /// E.g. `extern {}` or `extern \"C\" {}`\n    ForeignMod(ForeignMod),\n    /// Module-level inline assembly (from `global_asm!()`)\n    GlobalAsm(P\u003cGlobalAsm\u003e),\n    /// A type alias (`type` or `pub type`).\n    ///\n    /// E.g. `type Foo = Bar\u003cu8\u003e;`\n    Ty(P\u003cTy\u003e, Generics),\n    /// An enum definition (`enum` or `pub enum`).\n    ///\n    /// E.g. `enum Foo\u003cA, B\u003e { C\u003cA\u003e, D\u003cB\u003e }`\n    Enum(EnumDef, Generics),\n    /// A struct definition (`struct` or `pub struct`).\n    ///\n    /// E.g. `struct Foo\u003cA\u003e { x: A }`\n    Struct(VariantData, Generics),\n    /// A union definition (`union` or `pub union`).\n    ///\n    /// E.g. `union Foo\u003cA, B\u003e { x: A, y: B }`\n    Union(VariantData, Generics),\n    /// A Trait declaration (`trait` or `pub trait`).\n    ///\n    /// E.g. `trait Foo { .. }`, `trait Foo\u003cT\u003e { .. }` or `auto trait Foo {}`\n    Trait(IsAuto, Unsafety, Generics, TyParamBounds, Vec\u003cTraitItem\u003e),\n    /// Trait alias\n    ///\n    /// E.g. `trait Foo = Bar + Quux;`\n    TraitAlias(Generics, TyParamBounds),\n    /// An implementation.\n    ///\n    /// E.g. `impl\u003cA\u003e Foo\u003cA\u003e { .. }` or `impl\u003cA\u003e Trait for Foo\u003cA\u003e { .. }`\n    Impl(\n        Unsafety,\n        ImplPolarity,\n        Defaultness,\n        Generics,\n        Option\u003cTraitRef\u003e, // (optional) trait this impl implements\n        P\u003cTy\u003e,            // self\n        Vec\u003cImplItem\u003e,\n    ),\n    /// A macro invocation.\n    ///\n    /// E.g. `macro_rules! foo { .. }` or `foo!(..)`\n    Mac(Mac),\n\n    /// A macro definition.\n    MacroDef(MacroDef),\n}\n\nimpl ItemKind {\n    pub fn descriptive_variant(\u0026self) -\u003e \u0026str {\n        match *self {\n            ItemKind::ExternCrate(..) =\u003e \"extern crate\",\n            ItemKind::Use(..) =\u003e \"use\",\n            ItemKind::Static(..) =\u003e \"static item\",\n            ItemKind::Const(..) =\u003e \"constant item\",\n            ItemKind::Fn(..) =\u003e \"function\",\n            ItemKind::Mod(..) =\u003e \"module\",\n            ItemKind::ForeignMod(..) =\u003e \"foreign module\",\n            ItemKind::GlobalAsm(..) =\u003e \"global asm\",\n            ItemKind::Ty(..) =\u003e \"type alias\",\n            ItemKind::Enum(..) =\u003e \"enum\",\n            ItemKind::Struct(..) =\u003e \"struct\",\n            ItemKind::Union(..) =\u003e \"union\",\n            ItemKind::Trait(..) =\u003e \"trait\",\n            ItemKind::TraitAlias(..) =\u003e \"trait alias\",\n            ItemKind::Mac(..) | ItemKind::MacroDef(..) | ItemKind::Impl(..) =\u003e \"item\",\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct ForeignItem {\n    pub ident: Ident,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub node: ForeignItemKind,\n    pub id: NodeId,\n    pub span: Span,\n    pub vis: Visibility,\n}\n\n/// An item within an `extern` block\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum ForeignItemKind {\n    /// A foreign function\n    Fn(P\u003cFnDecl\u003e, Generics),\n    /// A foreign static item (`static ext: u8`), with optional mutability\n    /// (the boolean is true when mutable)\n    Static(P\u003cTy\u003e, bool),\n    /// A foreign type\n    Ty,\n}\n\nimpl ForeignItemKind {\n    pub fn descriptive_variant(\u0026self) -\u003e \u0026str {\n        match *self {\n            ForeignItemKind::Fn(..) =\u003e \"foreign function\",\n            ForeignItemKind::Static(..) =\u003e \"foreign static item\",\n            ForeignItemKind::Ty =\u003e \"foreign type\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serialize;\n\n    // are ASTs encodable?\n    #[test]\n    fn check_asts_encodable() {\n        fn assert_encodable\u003cT: serialize::Encodable\u003e() {}\n        assert_encodable::\u003cCrate\u003e();\n    }\n}\n","traces":[{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-rust","examples","weird-exprs.rs"],"content":"//@ run-pass\n\n#![feature(coroutines)]\n\n#![allow(non_camel_case_types)]\n#![allow(dead_code)]\n#![allow(redundant_semicolons)]\n#![allow(unreachable_code)]\n#![allow(unused_braces, unused_must_use, unused_parens)]\n#![allow(uncommon_codepoints, confusable_idents)]\n#![allow(unused_imports)]\n#![allow(unreachable_patterns)]\n\n#![recursion_limit = \"256\"]\n\nextern crate core;\nuse std::cell::Cell;\nuse std::mem::swap;\nuse std::ops::Deref;\n\n// Just a grab bag of stuff that you wouldn't want to actually write.\n\nfn strange() -\u003e bool { let _x: bool = return true; }\n\nfn funny() {\n    fn f(_x: ()) { }\n    f(return);\n}\n\nfn what() {\n    fn the(x: \u0026Cell\u003cbool\u003e) {\n        return while !x.get() { x.set(true); };\n    }\n    let i = \u0026Cell::new(false);\n    let dont = {||the(i)};\n    dont();\n    assert!((i.get()));\n}\n\nfn zombiejesus() {\n    loop {\n        while (return) {\n            if (return) {\n                match (return) {\n                    1 =\u003e {\n                        if (return) {\n                            return\n                        } else {\n                            return\n                        }\n                    }\n                    _ =\u003e { return }\n                };\n            } else if (return) {\n                return;\n            }\n        }\n        if (return) { break; }\n    }\n}\n\nfn notsure() {\n    let mut _x: isize;\n    let mut _y = (_x = 0) == (_x = 0);\n    let mut _z = (_x = 0) \u003c (_x = 0);\n    let _a = (_x += 0) == (_x = 0);\n    let _b = swap(\u0026mut _y, \u0026mut _z) == swap(\u0026mut _y, \u0026mut _z);\n}\n\nfn canttouchthis() -\u003e usize {\n    fn p() -\u003e bool { true }\n    let _a = (assert!((true)) == (assert!(p())));\n    let _c = (assert!((p())) == ());\n    let _b: bool = (println!(\"{}\", 0) == (return 0));\n}\n\nfn angrydome() {\n    loop { if break { } }\n    let mut i = 0;\n    loop { i += 1; if i == 1 { match (continue) { 1 =\u003e { }, _ =\u003e panic!(\"wat\") } }\n      break; }\n}\n\nfn evil_lincoln() { let _evil: () = println!(\"lincoln\"); }\n\nfn dots() {\n    assert_eq!(String::from(\"..................................................\"),\n               format!(\"{:?}\", .. .. .. .. .. .. .. .. .. .. .. .. ..\n                               .. .. .. .. .. .. .. .. .. .. .. ..));\n}\n\nfn u8(u8: u8) {\n    if u8 != 0u8 {\n        assert_eq!(8u8, {\n            macro_rules! u8 {\n                (u8) =\u003e {\n                    mod u8 {\n                        pub fn u8\u003c'u8: 'u8 + 'u8\u003e(u8: \u0026'u8 u8) -\u003e \u0026'u8 u8 {\n                            \"u8\";\n                            u8\n                        }\n                    }\n                };\n            }\n\n            u8!(u8);\n            let \u0026u8: \u0026u8 = u8::u8(\u00268u8);\n            ::u8(0u8);\n            u8\n        });\n    }\n}\n\nfn fishy() {\n    assert_eq!(String::from(\"\u003e\u003c\u003e\"),\n               String::\u003c\u003e::from::\u003c\u003e(\"\u003e\u003c\u003e\").chars::\u003c\u003e().rev::\u003c\u003e().collect::\u003cString\u003e());\n}\n\nfn union() {\n    union union\u003c'union\u003e { union: \u0026'union union\u003c'union\u003e, }\n}\n\nfn special_characters() {\n    let val = !((|(..):(_,_),(|__@_|__)|__)((\u0026*\"\\\\\",'🤔')/**/,{})=={\u0026[..=..][..];})//\n    ;\n    assert!(!val);\n}\n\nfn punch_card() -\u003e impl std::fmt::Debug {\n    ..=..=.. ..    .. .. .. ..    .. .. .. ..    .. ..=.. ..\n    ..=.. ..=..    .. .. .. ..    .. .. .. ..    ..=..=..=..\n    ..=.. ..=..    ..=.. ..=..    .. ..=..=..    .. ..=.. ..\n    ..=..=.. ..    ..=.. ..=..    ..=.. .. ..    .. ..=.. ..\n    ..=.. ..=..    ..=.. ..=..    .. ..=.. ..    .. ..=.. ..\n    ..=.. ..=..    ..=.. ..=..    .. .. ..=..    .. ..=.. ..\n    ..=.. ..=..    .. ..=..=..    ..=..=.. ..    .. ..=.. ..\n}\n\nfn r#match() {\n    let val: () = match match match match match () {\n        () =\u003e ()\n    } {\n        () =\u003e ()\n    } {\n        () =\u003e ()\n    } {\n        () =\u003e ()\n    } {\n        () =\u003e ()\n    };\n    assert_eq!(val, ());\n}\n\nfn i_yield() {\n    static || {\n        yield yield yield yield yield yield yield yield yield;\n    };\n}\n\nfn match_nested_if() {\n    let val = match () {\n        () if if if if true {true} else {false} {true} else {false} {true} else {false} =\u003e true,\n        _ =\u003e false,\n    };\n    assert!(val);\n}\n\nfn monkey_barrel() {\n    let val: () = ()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=();\n    assert_eq!(val, ());\n}\n\nfn 𝚌𝚘𝚗𝚝𝚒𝚗𝚞𝚎() {\n    type 𝚕𝚘𝚘𝚙 = i32;\n    fn 𝚋𝚛𝚎𝚊𝚔() -\u003e 𝚕𝚘𝚘𝚙 {\n        let 𝚛𝚎𝚝𝚞𝚛𝚗 = 42;\n        return 𝚛𝚎𝚝𝚞𝚛𝚗;\n    }\n    assert_eq!(loop {\n        break 𝚋𝚛𝚎𝚊𝚔 ();\n    }, 42);\n}\n\nfn function() {\n    struct foo;\n    impl Deref for foo {\n        type Target = fn() -\u003e Self;\n        fn deref(\u0026self) -\u003e \u0026Self::Target {\n            \u0026((|| foo) as _)\n        }\n    }\n    let foo = foo () ()() ()()() ()()()() ()()()()();\n}\n\nfn bathroom_stall() {\n    let mut i = 1;\n    matches!(2, _|_|_|_|_|_ if (i+=1) != (i+=1));\n    assert_eq!(i, 13);\n}\n\nfn closure_matching() {\n    let x = |_| Some(1);\n    let (|x| x) = match x(..) {\n        |_| Some(2) =\u003e |_| Some(3),\n        |_| _ =\u003e unreachable!(),\n    };\n    assert!(matches!(x(..), |_| Some(4)));\n}\n\nfn semisemisemisemisemi() {\n    ;;;;;;; ;;;;;;; ;;;    ;;; ;;\n    ;;      ;;      ;;;;  ;;;; ;;\n    ;;;;;;; ;;;;;   ;; ;;;; ;; ;;\n         ;; ;;      ;;  ;;  ;; ;;\n    ;;;;;;; ;;;;;;; ;;      ;; ;;\n}\n\nfn useful_syntax() {\n    use {{std::{{collections::{{HashMap}}}}}};\n    use ::{{{{core}, {std}}}};\n    use {{::{{core as core2}}}};\n}\n\nfn infcx() {\n    pub mod cx {\n        pub mod cx {\n            pub use super::cx;\n            pub struct Cx;\n        }\n    }\n    let _cx: cx::cx::Cx = cx::cx::cx::cx::cx::Cx;\n}\n\nfn return_already() -\u003e impl std::fmt::Debug {\n    loop {\n        return !!!!!!!\n        break !!!!!!1111\n    }\n}\n\nfn fake_macros() -\u003e impl std::fmt::Debug {\n    loop {\n        if! {\n            match! (\n                break! {\n                    return! {\n                        1337\n                    }\n                }\n            )\n\n            {}\n        }\n\n        {}\n    }\n}\n\npub fn main() {\n    strange();\n    funny();\n    what();\n    zombiejesus();\n    notsure();\n    canttouchthis();\n    angrydome();\n    evil_lincoln();\n    dots();\n    u8(8u8);\n    fishy();\n    union();\n    special_characters();\n    punch_card();\n    r#match();\n    i_yield();\n    match_nested_if();\n    monkey_barrel();\n    𝚌𝚘𝚗𝚝𝚒𝚗𝚞𝚎();\n    function();\n    bathroom_stall();\n    closure_matching();\n    semisemisemisemisemi();\n    useful_syntax();\n    infcx();\n    return_already();\n    fake_macros();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-typescript","bindings","rust","build.rs"],"content":"fn main() {\n    let root_dir = std::path::Path::new(\".\");\n    let typescript_dir = root_dir.join(\"typescript\").join(\"src\");\n    let tsx_dir = root_dir.join(\"tsx\").join(\"src\");\n    let common_dir = root_dir.join(\"common\");\n\n    let mut config = cc::Build::new();\n    config.include(\u0026typescript_dir);\n    config\n        .flag_if_supported(\"-std=c11\")\n        .flag_if_supported(\"-Wno-unused-parameter\");\n\n    for path in \u0026[\n        typescript_dir.join(\"parser.c\"),\n        typescript_dir.join(\"scanner.c\"),\n        tsx_dir.join(\"parser.c\"),\n        tsx_dir.join(\"scanner.c\"),\n    ] {\n        config.file(path);\n        println!(\"cargo:rerun-if-changed={}\", path.to_str().unwrap());\n    }\n\n    println!(\n        \"cargo:rerun-if-changed={}\",\n        common_dir.join(\"scanner.h\").to_str().unwrap()\n    );\n\n    config.compile(\"tree-sitter-typescript\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-typescript","bindings","rust","lib.rs"],"content":"//! This crate provides TypeScript and TSX language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE_TYPESCRIPT] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! function double(x: number): number {\n//!     return x * 2;\n//! }\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_typescript::LANGUAGE_TYPESCRIPT;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading TypeScript parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_typescript() -\u003e *const ();\n    fn tree_sitter_tsx() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`] for TypeScript.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE_TYPESCRIPT: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_typescript) };\n\n/// The tree-sitter [`LanguageFn`] for TSX.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE_TSX: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_tsx) };\n\n/// The content of the [`node-types.json`][] file for TypeScript.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const TYPESCRIPT_NODE_TYPES: \u0026str = include_str!(\"../../typescript/src/node-types.json\");\n\n/// The content of the [`node-types.json`][] file for TSX.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const TSX_NODE_TYPES: \u0026str = include_str!(\"../../tsx/src/node-types.json\");\n\n/// The syntax highlighting query for TypeScript.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The local-variable syntax highlighting query for TypeScript.\npub const LOCALS_QUERY: \u0026str = include_str!(\"../../queries/locals.scm\");\n\n/// The symbol tagging query for TypeScript.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_typescript_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE_TYPESCRIPT.into())\n            .expect(\"Error loading TypeScript parser\");\n    }\n\n    #[test]\n    fn test_can_load_tsx_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE_TSX.into())\n            .expect(\"Error loading TSX parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","build.rs"],"content":"use std::path::PathBuf;\n\nfn main() {\n    let dir = PathBuf::from(std::env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n    let out_dir = PathBuf::from(std::env::var(\"OUT_DIR\").unwrap());\n\n    // Get tree-sitter include path from the tree-sitter crate\n    let tree_sitter_dir = PathBuf::from(\n        std::env::var(\"DEP_TREE_SITTER_RUNTIME_INCLUDE\").unwrap_or_else(|_| {\n            // Fallback to a common location if the env var is not set\n            format!(\"{}/target/debug/build/tree-sitter-*/out\", dir.display())\n        }),\n    );\n\n    // Compile tree-sitter parsers\n    println!(\"cargo:rerun-if-changed=build.rs\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-go/src/parser.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-go\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-java/src/parser.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-java\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-javascript/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-javascript/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-javascript\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-python/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-python/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-python\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-rust/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-rust/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-rust\");\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .include(dir.join(\"tree-sitter-typescript/typescript/src\"))\n        .include(dir.join(\"tree-sitter-typescript/common\"))\n        .file(dir.join(\"tree-sitter-typescript/typescript/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-typescript/typescript/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-typescript\");\n\n    // Add build step for TSX parser\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .include(dir.join(\"tree-sitter-typescript/tsx/src\"))\n        .include(dir.join(\"tree-sitter-typescript/common\"))\n        .file(dir.join(\"tree-sitter-typescript/tsx/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-typescript/tsx/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-tsx\");\n\n\n    cc::Build::new()\n        .include(\u0026dir)\n        .include(\u0026tree_sitter_dir)\n        .file(dir.join(\"tree-sitter-ruby/src/parser.c\"))\n        .file(dir.join(\"tree-sitter-ruby/src/scanner.c\"))\n        .flag(\"-Wno-unused-parameter\")\n        .compile(\"tree-sitter-ruby\");\n\n\n    // Add library search path\n    println!(\"cargo:rustc-link-search=native={}\", out_dir.display());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","example","rust-vulnerable-app","src","main.rs"],"content":"use actix_web::{get, web, App, HttpResponse, HttpServer, Responder};\nuse rusqlite::{Connection, Result as SqliteResult};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::process::Command;\n\n// Vulnerable database initialization\nfn init_db() -\u003e SqliteResult\u003c()\u003e {\n    let conn = Connection::open(\"users.db\")?;\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS users ( \\\n            id INTEGER PRIMARY KEY, \\\n            username TEXT NOT NULL, \\\n            password TEXT NOT NULL \\\n        )\",\n        [],\n    )?;\n\n    // Insert default user if not exists\n    conn.execute(\n        \"INSERT OR IGNORE INTO users (id, username, password) VALUES (1, 'admin', 'admin123')\",\n        [],\n    )?;\n\n    Ok(())\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct User {\n    id: i32,\n    username: String,\n    password: String,\n}\n\n// Vulnerability 1: SQL Injection\n#[get(\"/sqli\")]\nasync fn sql_injection(query: web::Query\u003cHashMap\u003cString, String\u003e\u003e) -\u003e impl Responder {\n    let username = query\n        .get(\"username\")\n        .cloned()\n        .unwrap_or_else(|| String::from(\"\"));\n\n    // Vulnerable SQL query - DO NOT USE IN PRODUCTION\n    let query_str = format!(\"SELECT * FROM users WHERE username = '{}'\", username);\n\n    let conn = Connection::open(\"users.db\").unwrap();\n    let mut stmt = conn.prepare(\u0026query_str).unwrap();\n\n    let users: Vec\u003cUser\u003e = stmt\n        .query_map([], |row| {\n            Ok(User {\n                id: row.get(0)?,\n                username: row.get(1)?,\n                password: row.get(2)?,\n            })\n        })\n        .unwrap()\n        .filter_map(|u| u.ok())\n        .collect();\n\n    HttpResponse::Ok().json(users)\n}\n\n// Vulnerability 2: Command Injection\n#[get(\"/cmdi\")]\nasync fn command_injection(query: web::Query\u003cHashMap\u003cString, String\u003e\u003e) -\u003e impl Responder {\n    let hostname = query\n        .get(\"hostname\")\n        .cloned()\n        .unwrap_or_else(|| String::from(\"localhost\"));\n\n    // Vulnerable command execution - DO NOT USE IN PRODUCTION\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(format!(\"ping -c 1 {}\", hostname))\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let result = String::from_utf8_lossy(\u0026output.stdout);\n\n    HttpResponse::Ok().body(result.to_string())\n}\n\n// Vulnerability 3: Path Traversal\n#[get(\"/file\")]\nasync fn file_read(query: web::Query\u003cHashMap\u003cString, String\u003e\u003e) -\u003e impl Responder {\n    let filename = query\n        .get(\"name\")\n        .cloned()\n        .unwrap_or_else(|| String::from(\"default.txt\"));\n\n    // Vulnerable file read - DO NOT USE IN PRODUCTION\n    match std::fs::read_to_string(\u0026filename) {\n        Ok(content) =\u003e HttpResponse::Ok().body(content),\n        Err(e) =\u003e HttpResponse::InternalServerError().body(e.to_string()),\n    }\n}\n\n#[actix_web::main]\nasync fn main() -\u003e std::io::Result\u003c()\u003e {\n    // Initialize database\n    init_db().expect(\"Failed to initialize database\");\n\n    println!(\"Starting server at http://127.0.0.1:8080\");\n\n    HttpServer::new(|| {\n        App::new()\n            .service(sql_injection)\n            .service(command_injection)\n            .service(file_read)\n            .route(\n                \"/\",\n                web::get().to(|| async {\n                    HttpResponse::Ok().body(\n                        r#\"\n                    \u003ch1\u003eVulnerable Rust Application\u003c/h1\u003e\n                    \u003cul\u003e\n                        \u003cli\u003e\u003ca href=\"/sqli?username=admin\"\u003eSQL Injection\u003c/a\u003e\u003c/li\u003e\n                        \u003cli\u003e\u003ca href=\"/cmdi?hostname=localhost\"\u003eCommand Injection\u003c/a\u003e\u003c/li\u003e\n                        \u003cli\u003e\u003ca href=\"/file?name=README.md\"\u003ePath Traversal\u003c/a\u003e\u003c/li\u003e\n                    \u003c/ul\u003e\n                    \"#,\n                    )\n                }),\n            )\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","analyzer.rs"],"content":"use anyhow::{Error, Result};\nuse genai::chat::{ChatMessage, ChatOptions, ChatRequest, JsonSpec};\nuse genai::{Client, ClientConfig};\nuse log::{debug, error, info, warn};\nuse regex::escape;\nuse serde::de::DeserializeOwned;\nuse std::path::PathBuf;\n\nuse crate::parser::CodeParser;\nuse crate::prompts::{self, vuln_specific};\nuse crate::response::{response_json_schema, Response};\nuse crate::security_patterns::{SecurityRiskPatterns, PatternType, Language};\n\nfn create_api_client() -\u003e Client {\n    let client_config = ClientConfig::default().with_chat_options(\n        ChatOptions::default()\n            .with_response_format(JsonSpec::new(\"json_object\", response_json_schema())),\n    );\n    Client::builder().with_config(client_config).build()\n}\n\nasync fn execute_chat_request(\n    client: \u0026Client,\n    model: \u0026str,\n    chat_req: ChatRequest,\n) -\u003e Result\u003cString\u003e {\n    let chat_res = client.exec_chat(model, chat_req, None).await?;\n    match chat_res.content_text_as_str() {\n        Some(content) =\u003e Ok(content.to_string()),\n        None =\u003e {\n            error!(\"Failed to get content text from chat response\");\n            Err(anyhow::anyhow!(\n                \"Failed to get content text from chat response\"\n            ))\n        }\n    }\n}\n\nfn parse_json_response\u003cT: DeserializeOwned\u003e(chat_content: \u0026str) -\u003e Result\u003cT\u003e {\n    match serde_json::from_str(chat_content) {\n        Ok(response) =\u003e Ok(response),\n        Err(e) =\u003e {\n            debug!(\"Failed to parse JSON response: {}\", e);\n            debug!(\"Response content: {}\", chat_content);\n            Err(anyhow::anyhow!(\"Failed to parse JSON response: {}\", e))\n        }\n    }\n}\n\npub async fn analyze_file(\n    file_path: \u0026PathBuf,\n    model: \u0026str,\n    files: \u0026[PathBuf],\n    verbosity: u8,\n    context: \u0026crate::parser::Context,\n    min_confidence: i32,\n) -\u003e Result\u003cResponse, Error\u003e {\n    info!(\"Performing initial analysis of {}\", file_path.display());\n\n    let mut parser = CodeParser::new()?;\n\n    for file in files {\n        if let Err(e) = parser.add_file(file) {\n            warn!(\n                \"Failed to add file to parser {}: {}. Skipping file.\",\n                file.display(),\n                e\n            );\n        }\n    }\n\n    let content = std::fs::read_to_string(file_path)?;\n    if content.is_empty() {\n        return Ok(Response {\n            scratchpad: String::new(),\n            analysis: String::new(),\n            poc: String::new(),\n            confidence_score: 0,\n            vulnerability_types: vec![],\n            context_code: vec![],\n        });\n    }\n\n    let mut context_text = String::new();\n    if !context.definitions.is_empty() {\n        context_text.push_str(\"\\nContext Definitions:\\n\");\n        for def in \u0026context.definitions {\n            context_text.push_str(\u0026format!(\n                \"\\nFunction/Definition: {}\\nCode:\\n{}\\n\",\n                def.name, def.source\n            ));\n        }\n    }\n\n    let prompt = format!(\n        \"File: {}\\n\\nContent:\\n{}\\n{}\\n\\n{}\\n{}\\n{}\",\n        file_path.display(),\n        content,\n        context_text,\n        prompts::INITIAL_ANALYSIS_PROMPT_TEMPLATE,\n        prompts::ANALYSIS_APPROACH_TEMPLATE,\n        prompts::GUIDELINES_TEMPLATE,\n    );\n    debug!(\"[PROMPT]\\n{}\", prompt);\n\n    let chat_req = ChatRequest::new(vec![\n        ChatMessage::system(\"You are a security vulnerability analyzer. You must reply with exactly one JSON object that matches this schema: { \\\"scratchpad\\\": string, \\\"analysis\\\": string, \\\"poc\\\": string, \\\"confidence_score\\\": integer, \\\"vulnerability_types\\\": array of strings, \\\"context_code\\\": array of objects with { \\\"name\\\": string, \\\"reason\\\": string, \\\"code_line\\\": string } }. Do not include any explanatory text outside the JSON object.\"),\n        ChatMessage::user(\u0026prompt),\n    ]);\n\n    let json_client = create_api_client();\n    let chat_content = execute_chat_request(\u0026json_client, model, chat_req).await?;\n    debug!(\"[LLM Response]\\n{}\", chat_content);\n    let mut response: Response = parse_json_response(\u0026chat_content)?;\n    \n    response.confidence_score = crate::response::Response::normalize_confidence_score(response.confidence_score);\n\n    info!(\"Initial analysis complete\");\n\n    if response.confidence_score \u003e= min_confidence \u0026\u0026 !response.vulnerability_types.is_empty() {\n        let vuln_info_map = vuln_specific::get_vuln_specific_info();\n\n        for vuln_type in response.vulnerability_types.clone() {\n            let vuln_info = vuln_info_map.get(\u0026vuln_type).unwrap();\n\n            let mut stored_code_definitions: Vec\u003c(PathBuf, crate::parser::Definition)\u003e = Vec::new();\n            let previous_analysis = String::new();\n\n            {\n                info!(\n                    \"Performing vuln-specific analysis for {:?}\",\n                    vuln_type\n                );\n                if verbosity \u003e 0 {\n                    println!(\n                        \"🔎 [{}] 脆弱性タイプ: {:?} の詳細解析\",\n                        file_path.display(),\n                        vuln_type\n                    );\n                    if !stored_code_definitions.is_empty() {\n                        println!(\"  解析コンテキスト関数:\");\n                        for (_, def) in \u0026stored_code_definitions {\n                            println!(\"    - {} ({}行)\", def.name, def.source.lines().count());\n                        }\n                    }\n                    println!(\"  考慮バイパス: {}\", vuln_info.bypasses.join(\", \"));\n                    println!(\n                        \"  追加プロンプト: {}\",\n                        \u0026vuln_info.prompt.chars().take(40).collect::\u003cString\u003e()\n                    );\n                }\n\n                let mut context_code = String::new();\n                for (_, def) in \u0026stored_code_definitions {\n                    context_code.push_str(\u0026format!(\n                        \"\\nFunction: {}\\nSource:\\n{}\\n\",\n                        def.name, def.source\n                    ));\n                }\n\n                let prompt = format!(\n                    \"File: {}\\n\\nContent:\\n{}\\n\\nContext Code:\\n{}\\n\\nVulnerability Type: {:?}\\n\\nBypasses to Consider:\\n{}\\n\\n{}\\n{}\\n{}\\nPrevious Analysis:\\n{}\",\n                    file_path.display(),\n                    content,\n                    context_code,\n                    vuln_type,\n                    vuln_info.bypasses.join(\"\\n\"),\n                    vuln_info.prompt,\n                    prompts::ANALYSIS_APPROACH_TEMPLATE,\n                    prompts::GUIDELINES_TEMPLATE,\n                    previous_analysis,\n                );\n\n                let chat_req = ChatRequest::new(vec![\n                    ChatMessage::system(\n                        \"You are a security vulnerability analyzer. You must reply with exactly one JSON object that matches this schema: { \\\"scratchpad\\\": string, \\\"analysis\\\": string, \\\"poc\\\": string, \\\"confidence_score\\\": integer, \\\"vulnerability_types\\\": array of strings, \\\"context_code\\\": array of objects with { \\\"name\\\": string, \\\"reason\\\": string, \\\"code_line\\\": string } }. Do not include any explanatory text outside the JSON object.\",\n                    ),\n                    ChatMessage::user(\u0026prompt),\n                ]);\n\n                let json_client = create_api_client();\n                let chat_content = execute_chat_request(\u0026json_client, model, chat_req).await?;\n                debug!(\"[LLM Response]\\n{}\", chat_content);\n                let mut vuln_response: Response = parse_json_response(\u0026chat_content)?;\n                \n                vuln_response.confidence_score = crate::response::Response::normalize_confidence_score(vuln_response.confidence_score);\n\n                if verbosity \u003e 0 {\n                    debug!(\n                        \"  LLM応答: confidence_score={}, vulnerability_types={:?}\",\n                        vuln_response.confidence_score, vuln_response.vulnerability_types\n                    );\n                    println!(\n                        \"  analysis要約: {}\",\n                        \u0026vuln_response.analysis.chars().take(60).collect::\u003cString\u003e()\n                    );\n                    if !vuln_response.context_code.is_empty() {\n                        println!(\"  context_code:\");\n                        for ctx in \u0026vuln_response.context_code {\n                            println!(\"    - {}: {}\", ctx.name, ctx.reason);\n                        }\n                    }\n                    return Ok(vuln_response);\n                }\n\n                if vuln_response.context_code.is_empty() {\n                    if verbosity == 0 {\n                        return Ok(vuln_response);\n                    }\n                    break;\n                }\n\n                // Get language for pattern detection\n                let file_extension = file_path.extension()\n                    .and_then(|ext| ext.to_str())\n                    .unwrap_or(\"\");\n                let language = Language::from_extension(file_extension);\n                let patterns = SecurityRiskPatterns::new(language);\n\n                for context in vuln_response.context_code {\n                    let escaped_name = escape(\u0026context.name);\n                    if !stored_code_definitions\n                        .iter()\n                        .any(|(_, def)| def.name == escaped_name)\n                    {\n                        // Determine pattern type to choose appropriate search method\n                        let pattern_type = patterns.get_pattern_type(\u0026context.name);\n                        \n                        match pattern_type {\n                            Some(PatternType::Source) =\u003e {\n                                // For sources, use find_references to track data flow forward\n                                match parser.find_references(\u0026escaped_name) {\n                                    Ok(refs) =\u003e {\n                                        stored_code_definitions.extend(refs);\n                                    }\n                                    Err(e) =\u003e {\n                                        warn!(\n                                            \"Failed to find references for source context {}: {}\",\n                                            escaped_name, e\n                                        );\n                                    }\n                                }\n                            }\n                            Some(PatternType::Sink) | Some(PatternType::Validate) | None =\u003e {\n                                // For sinks, validate patterns, or unknown patterns, use find_definition\n                                match parser.find_definition(\u0026escaped_name, file_path) {\n                                    Ok(Some(def)) =\u003e {\n                                        stored_code_definitions.push(def);\n                                    }\n                                    Ok(None) =\u003e {\n                                        debug!(\"No definition found for context: {}\", escaped_name);\n                                    }\n                                    Err(e) =\u003e {\n                                        warn!(\n                                            \"Failed to find definition for context {}: {}\",\n                                            escaped_name, e\n                                        );\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // previous_analysis = vuln_response.analysis; // TODO: Use this variable or remove it\n\n            }\n        }\n    }\n    Ok(response)\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":145},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","lib.rs"],"content":"pub mod analyzer;\npub mod parser;\npub mod pattern_generator;\npub mod prompts;\npub mod repo;\npub mod repo_clone;\npub mod response;\npub mod security_patterns;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","main.rs"],"content":"use anyhow::Result;\nuse clap::Parser;\nuse dotenv::dotenv;\nuse std::path::PathBuf;\nuse vulnhuntrs::analyzer::analyze_file;\nuse vulnhuntrs::pattern_generator::generate_custom_patterns;\nuse vulnhuntrs::security_patterns::Language;\nuse vulnhuntrs::security_patterns::SecurityRiskPatterns;\n\nuse vulnhuntrs::repo::RepoOps;\nuse vulnhuntrs::repo_clone::clone_github_repo;\nuse vulnhuntrs::response::{AnalysisSummary, VulnType};\n\nuse futures::future::join_all;\nuse std::sync::Arc;\n\n#[derive(Parser, Debug)]\n#[command(\n    author,\n    version,\n    about,\n    long_about = None,\n    group = clap::ArgGroup::new(\"target\")\n        .required(true)\n        .args(\u0026[\"root\", \"repo\"])\n)]\nstruct Args {\n    /// Path to the root directory of the project\n    #[arg(short, long, group = \"target\")]\n    root: Option\u003cPathBuf\u003e,\n\n    /// GitHub repository (owner/repo or URL)\n    #[arg(long, group = \"target\")]\n    repo: Option\u003cString\u003e,\n\n    /// Specific path or file within the project to analyze\n    #[arg(short, long)]\n    analyze: Option\u003cPathBuf\u003e,\n\n    /// LLM model to use (default: o4-mini)\n    #[arg(short, long, default_value = \"o4-mini\")]\n    model: String,\n\n    /// Increase output verbosity\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    verbosity: u8,\n\n    /// Enable evaluation mode for example vulnerable apps\n    #[arg(short, long)]\n    evaluate: bool,\n\n    /// Output directory for markdown reports\n    #[arg(long)]\n    output_dir: Option\u003cPathBuf\u003e,\n    \n    /// 最小信頼度スコア（これ以上のスコアを持つ脆弱性のみ表示）\n    #[arg(long, default_value = \"0\")]\n    min_confidence: i32,\n    \n    /// 特定の脆弱性タイプでフィルタリング（カンマ区切りで複数指定可）\n    #[arg(long)]\n    vuln_types: Option\u003cString\u003e,\n    \n    /// サマリーレポートを生成する\n    #[arg(long)]\n    summary: bool,\n    \n    /// カスタムパターンを生成する（現在のディレクトリを解析してセキュリティパターンを自動検出）\n    #[arg(long)]\n    generate_patterns: bool,\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    env_logger::init();\n    dotenv().ok();\n\n    let args = Args::parse();\n\n    let root_dir = if let Some(repo) = \u0026args.repo {\n        let dest = PathBuf::from(\"repo\");\n        if dest.exists() {\n            std::fs::remove_dir_all(\u0026dest)\n                .map_err(|e| anyhow::anyhow!(\"クローン先ディレクトリの削除に失敗: {}\", e))?;\n        }\n        println!(\n            \"🛠️  GitHubリポジトリをクローン中: {} → {}\",\n            repo,\n            dest.display()\n        );\n        clone_github_repo(repo, \u0026dest)\n            .map_err(|e| anyhow::anyhow!(\"GitHubリポジトリのクローンに失敗: {}\", e))?;\n        dest\n    } else if let Some(root) = \u0026args.root {\n        root.clone()\n    } else {\n        panic!(\"root path or repo must be set\");\n    };\n\n    let repo = RepoOps::new(root_dir.clone());\n\n    println!(\"🔍 Vulnhuntrs - セキュリティ解析ツール\");\n\n    // Handle pattern generation mode\n    if args.generate_patterns {\n        println!(\"🔧 カスタムパターン生成モードを開始します\");\n        return generate_custom_patterns(\u0026root_dir, \u0026args.model).await;\n    }\n\n    let files = repo.get_relevant_files();\n    println!(\n        \"📁 関連するソースファイルを検出しました ({}件)\",\n        files.len()\n    );\n    for (i, f) in files.iter().enumerate() {\n        println!(\"  [{}] {}\", i + 1, f.display());\n    }\n\n    let mut pattern_files = Vec::new();\n    for file_path in \u0026files {\n        if let Ok(content) = std::fs::read_to_string(file_path) {\n            let ext = file_path\n                .extension()\n                .and_then(|e| e.to_str())\n                .unwrap_or(\"\");\n            let lang = Language::from_extension(ext);\n            let patterns = SecurityRiskPatterns::new(lang);\n            if patterns.matches(\u0026content) {\n                pattern_files.push(file_path.clone());\n            }\n        }\n    }\n\n    println!(\n        \"🔎 セキュリティパターン該当ファイルを検出しました ({}件)\",\n        pattern_files.len()\n    );\n    for (i, f) in pattern_files.iter().enumerate() {\n        println!(\"  [P{}] {}\", i + 1, f.display());\n    }\n\n    let total = pattern_files.len();\n    let root_dir = Arc::new(root_dir);\n    let output_dir = args.output_dir.clone();\n    let model = args.model.clone();\n    let files = files.clone();\n    let verbosity = args.verbosity;\n\n    let mut summary = AnalysisSummary::new();\n\n    let tasks = pattern_files.iter().enumerate().map(|(idx, file_path)| {\n        let file_path = file_path.clone();\n        let root_dir = Arc::clone(\u0026root_dir);\n        let output_dir = output_dir.clone();\n        let model = model.clone();\n        let files = files.clone();\n\n        tokio::spawn(async move {\n            let file_name = file_path.display().to_string();\n            println!(\"📄 解析対象: {} ({} / {})\", file_name, idx + 1, total);\n            println!(\"{}\", \"=\".repeat(80));\n\n            let mut repo = RepoOps::new((*root_dir).clone());\n            if let Err(e) = repo.add_file_to_parser(\u0026file_path) {\n                println!(\"❌ ファイルのパース追加に失敗: {}: {}\", file_path.display(), e);\n                return None;\n            }\n            let context = match repo.collect_context_for_security_pattern(\u0026file_path) {\n                Ok(ctx) =\u003e ctx,\n                Err(e) =\u003e {\n                    println!(\"❌ コンテキスト収集に失敗: {}: {}\", file_path.display(), e);\n                    return None;\n                }\n            };\n\n            let analysis_result = match analyze_file(\u0026file_path, \u0026model, \u0026files, verbosity, \u0026context, 0).await {\n                Ok(res) =\u003e res,\n                Err(e) =\u003e {\n                    println!(\"❌ 解析に失敗: {}: {}\", file_path.display(), e);\n                    return None;\n                }\n            };\n\n            if let Some(ref output_dir) = output_dir {\n                if let Err(e) = std::fs::create_dir_all(output_dir) {\n                    println!(\"❌ 出力ディレクトリ作成に失敗: {}: {}\", output_dir.display(), e);\n                    return None;\n                }\n                let fname = file_path\n                    .file_name()\n                    .map(|n| n.to_string_lossy().to_string() + \".md\")\n                    .unwrap_or_else(|| \"report.md\".to_string());\n                let mut out_path = output_dir.clone();\n                out_path.push(fname);\n                if let Err(e) = std::fs::write(\u0026out_path, analysis_result.to_markdown()) {\n                    println!(\"❌ Markdownレポート出力に失敗: {}: {}\", out_path.display(), e);\n                    return None;\n                }\n                println!(\"📝 Markdownレポートを出力: {}\", out_path.display());\n            }\n\n            analysis_result.print_readable();\n            \n            Some((file_path, analysis_result))\n        })\n    });\n\n    let results = join_all(tasks).await;\n    for (file_path, response) in results.into_iter().flatten().flatten() {\n        summary.add_result(file_path, response);\n    }\n    \n    summary.sort_by_confidence();\n    \n    let mut filtered_summary = if args.min_confidence \u003e 0 {\n        summary.filter_by_min_confidence(args.min_confidence)\n    } else {\n        summary\n    };\n    \n    if let Some(types_str) = args.vuln_types {\n        let vuln_types: Vec\u003cVulnType\u003e = types_str\n            .split(',')\n            .map(|s| match s.trim() {\n                \"LFI\" =\u003e VulnType::LFI,\n                \"RCE\" =\u003e VulnType::RCE,\n                \"SSRF\" =\u003e VulnType::SSRF,\n                \"AFO\" =\u003e VulnType::AFO,\n                \"SQLI\" =\u003e VulnType::SQLI,\n                \"XSS\" =\u003e VulnType::XSS,\n                \"IDOR\" =\u003e VulnType::IDOR,\n                other =\u003e VulnType::Other(other.to_string()),\n            })\n            .collect();\n        \n        filtered_summary = filtered_summary.filter_by_vuln_types(\u0026vuln_types);\n    }\n    \n    if args.summary {\n        if let Some(ref output_dir) = args.output_dir {\n            if let Err(e) = std::fs::create_dir_all(output_dir) {\n                println!(\"❌ 出力ディレクトリ作成に失敗: {}: {}\", output_dir.display(), e);\n            } else {\n                let mut summary_path = output_dir.clone();\n                summary_path.push(\"summary.md\");\n                if let Err(e) = std::fs::write(\u0026summary_path, filtered_summary.to_markdown()) {\n                    println!(\"❌ サマリーレポート出力に失敗: {}: {}\", summary_path.display(), e);\n                } else {\n                    println!(\"📊 サマリーレポートを出力: {}\", summary_path.display());\n                }\n            }\n        } else {\n            println!(\"⚠ サマリーレポートを出力するには --output-dir オプションが必要です\");\n        }\n    }\n\n    println!(\"✅ 解析が完了しました\");\n\n    Ok(())\n}\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":122},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","parser.rs"],"content":"use anyhow::{anyhow, Result};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse streaming_iterator::StreamingIterator;\nunsafe extern \"C\" {\n    fn tree_sitter_rust() -\u003e tree_sitter::Language;\n}\nuse tree_sitter::{Language, Node, Parser, Query, QueryCursor};\n\nunsafe extern \"C\" {\n    fn tree_sitter_python() -\u003e Language;\n    fn tree_sitter_javascript() -\u003e Language;\n    fn tree_sitter_typescript() -\u003e Language;\n    fn tree_sitter_tsx() -\u003e Language;\n    fn tree_sitter_java() -\u003e Language;\n    fn tree_sitter_go() -\u003e Language;\n    fn tree_sitter_ruby() -\u003e Language;\n\n}\n\n#[derive(Debug, Clone)]\npub struct Definition {\n    pub name: String,\n    pub start_byte: usize,\n    pub end_byte: usize,\n    pub source: String,\n}\n\n#[derive(Debug, Clone)]\npub struct Context {\n    pub definitions: Vec\u003cDefinition\u003e,\n}\n\npub struct CodeParser {\n    pub files: HashMap\u003cPathBuf, String\u003e,\n    pub parser: Parser,\n}\n\nimpl CodeParser {\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        Ok(Self {\n            files: HashMap::new(),\n            parser: Parser::new(),\n        })\n    }\n\n    pub fn add_file(\u0026mut self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        let content = fs::read_to_string(path).map_err(|e| {\n            anyhow!(\n                \"ファイルの読み込みに失敗しました: {}: {}\",\n                path.display(),\n                e\n            )\n        })?;\n        self.files.insert(path.to_path_buf(), content.clone());\n        Ok(())\n    }\n\n    fn get_language(\u0026self, path: \u0026Path) -\u003e Option\u003cLanguage\u003e {\n        let extension = path.extension().and_then(|ext| ext.to_str());\n        match extension {\n            Some(\"py\") =\u003e Some(unsafe { tree_sitter_python() }),\n            Some(\"js\") =\u003e Some(unsafe { tree_sitter_javascript() }),\n            Some(\"ts\") =\u003e Some(unsafe { tree_sitter_typescript() }),\n            Some(\"tsx\") =\u003e Some(unsafe { tree_sitter_tsx() }),\n            Some(\"java\") =\u003e Some(unsafe { tree_sitter_java() }),\n            Some(\"rs\") =\u003e Some(unsafe { tree_sitter_rust() }),\n            Some(\"go\") =\u003e Some(unsafe { tree_sitter_go() }),\n            Some(\"rb\") =\u003e Some(unsafe { tree_sitter_ruby() }),\n            _ =\u003e None,\n        }\n    }\n\n    fn get_query_path(\u0026self, language: \u0026Language, query_name: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        let lang_name = if language == \u0026unsafe { tree_sitter_python() } {\n            \"python\"\n        } else if language == \u0026unsafe { tree_sitter_javascript() } {\n            \"javascript\"\n        } else if language == \u0026unsafe { tree_sitter_typescript() }\n            || language == \u0026unsafe { tree_sitter_tsx() }\n        {\n            \"typescript\"\n        } else if language == \u0026unsafe { tree_sitter_java() } {\n            \"java\"\n        }\n        else if language == \u0026unsafe { tree_sitter_go() } {\n            \"go\"\n        } else if language == \u0026unsafe { tree_sitter_rust() } {\n            \"rust\"\n        } else if language == \u0026unsafe { tree_sitter_ruby() } {\n            \"ruby\"\n        } else {\n            return Err(anyhow!(\"クエリに対応していない言語です\"));\n        };\n\n        if lang_name.contains('/') || lang_name.contains('\\\\') || lang_name.contains(\"..\") {\n            return Err(anyhow!(\"クエリパスの言語名が不正です: {}\", lang_name));\n        }\n        if query_name.contains('/') || query_name.contains('\\\\') || query_name.contains(\"..\") {\n            return Err(anyhow!(\"クエリパスのクエリ名が不正です: {}\", query_name));\n        }\n\n        let manifest_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        let query_file_name = format!(\"{}.scm\", query_name);\n        let query_path = manifest_dir\n            .join(\"custom_queries\")\n            .join(lang_name)\n            .join(\u0026query_file_name);\n\n        if !query_path.exists() {\n            return Err(anyhow!(\n                \"クエリファイルが見つかりません: {}\",\n                query_path.display()\n            ));\n        }\n\n        Ok(query_path)\n    }\n\n    pub fn find_definition(\n        \u0026mut self,\n        name: \u0026str,\n        source_file: \u0026Path,\n    ) -\u003e Result\u003cOption\u003c(PathBuf, Definition)\u003e\u003e {\n        let content = self.files.get(source_file).ok_or_else(|| {\n            anyhow!(\n                \"パーサーにファイルが見つかりません: {}\",\n                source_file.display()\n            )\n        })?;\n\n        let language = match self.get_language(source_file) {\n            Some(lang) =\u003e lang,\n            None =\u003e return Ok(None),\n        };\n\n        self.parser\n            .set_language(\u0026language)\n            .map_err(|e| anyhow!(\"言語の設定に失敗しました: {}\", e))?;\n\n        let tree = self\n            .parser\n            .parse(content, None)\n            .ok_or_else(|| anyhow!(\"ファイルのパースに失敗しました: {}\", source_file.display()))?;\n\n        let query_path = self.get_query_path(\u0026language, \"definitions\")?;\n        let query_str = fs::read_to_string(\u0026query_path).map_err(|e| {\n            anyhow!(\n                \"クエリファイルの読み込みに失敗しました: {}: {}\",\n                query_path.display(),\n                e\n            )\n        })?;\n\n        let query = Query::new(\u0026language, \u0026query_str).map_err(|e| {\n            anyhow!(\n                \"クエリの生成に失敗しました: {}: {}\",\n                query_path.display(),\n                e\n            )\n        })?;\n\n        let mut query_cursor = QueryCursor::new();\n        let mut matches = query_cursor.matches(\u0026query, tree.root_node(), content.as_bytes());\n\n        while let Some(mat) = matches.next() {\n            let mut definition_node: Option\u003cNode\u003e = None;\n            let mut name_node: Option\u003cNode\u003e = None;\n\n            for cap in mat.captures {\n                let capture_name = \u0026query.capture_names()[cap.index as usize];\n                match capture_name {\n                    s if *s == \"definition\" =\u003e definition_node = Some(cap.node),\n                    s if *s == \"name\" =\u003e name_node = Some(cap.node),\n                    _ =\u003e {}\n                }\n            }\n\n            if let (Some(def_node), Some(name_node_inner)) = (definition_node, name_node) {\n                if name_node_inner.utf8_text(content.as_bytes())? == name {\n                    let start_byte = def_node.start_byte();\n                    let end_byte = def_node.end_byte();\n                    let source = def_node.utf8_text(content.as_bytes())?.to_string();\n\n                    let definition = Definition {\n                        name: name.to_string(),\n                        start_byte,\n                        end_byte,\n                        source,\n                    };\n                    return Ok(Some((source_file.to_path_buf(), definition)));\n                }\n            }\n        }\n\n        Ok(None)\n    }\n\n    pub fn find_references(\u0026mut self, name: \u0026str) -\u003e Result\u003cVec\u003c(PathBuf, Definition)\u003e\u003e {\n        let mut results = Vec::new();\n\n        for (file_path, content) in \u0026self.files {\n            let language = match self.get_language(file_path) {\n                Some(lang) =\u003e lang,\n                None =\u003e continue,\n            };\n\n            self.parser.set_language(\u0026language).map_err(|e| {\n                anyhow!(\"Failed to set language for {}: {}\", file_path.display(), e)\n            })?;\n\n            let tree = match self.parser.parse(content, None) {\n                Some(t) =\u003e t,\n                None =\u003e {\n                    eprintln!(\n                        \"警告: ファイルのパースに失敗しました: {}\",\n                        file_path.display()\n                    );\n                    continue;\n                }\n            };\n\n            let query_path = match self.get_query_path(\u0026language, \"references\") {\n                Ok(p) =\u003e p,\n                Err(e) =\u003e {\n                    eprintln!(\n                        \"警告: 参照クエリパスの取得に失敗しました: {}: {}\",\n                        file_path.display(),\n                        e\n                    );\n                    continue;\n                }\n            };\n            let query_str = match fs::read_to_string(\u0026query_path) {\n                Ok(s) =\u003e s,\n                Err(e) =\u003e {\n                    eprintln!(\n                        \"警告: 参照クエリファイルの読み込みに失敗しました: {}: {}\",\n                        query_path.display(),\n                        e\n                    );\n                    continue;\n                }\n            };\n\n            let query = match Query::new(\u0026language, \u0026query_str) {\n                Ok(q) =\u003e q,\n                Err(e) =\u003e {\n                    eprintln!(\n                        \"警告: 参照クエリの生成に失敗しました: {}: {}\",\n                        query_path.display(),\n                        e\n                    );\n                    continue;\n                }\n            };\n\n            let mut query_cursor = QueryCursor::new();\n            let mut matches = query_cursor.matches(\u0026query, tree.root_node(), content.as_bytes());\n\n            while let Some(mat) = matches.next() {\n                for cap in mat.captures {\n                    if query.capture_names()[cap.index as usize] == \"reference\" {\n                        let node = cap.node;\n                        if node.utf8_text(content.as_bytes())? == name {\n                            let start_byte = node.start_byte();\n                            let end_byte = node.end_byte();\n                            let source = name.to_string();\n\n                            results.push((\n                                file_path.clone(),\n                                Definition {\n                                    name: name.to_string(),\n                                    start_byte,\n                                    end_byte,\n                                    source,\n                                },\n                            ));\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(results)\n    }\n    pub fn build_context_from_file(\u0026mut self, start_path: \u0026Path) -\u003e Result\u003cContext\u003e {\n        use std::collections::HashSet;\n\n        let mut collected: HashSet\u003cString\u003e = HashSet::new();\n        let mut definitions: Vec\u003cDefinition\u003e = Vec::new();\n\n        let file_content = self\n            .files\n            .get(start_path)\n            .ok_or_else(|| anyhow::anyhow!(\"ファイルが見つかりません: {}\", start_path.display()))?;\n        let language = self\n            .get_language(start_path)\n            .ok_or_else(|| anyhow::anyhow!(\"言語が特定できません: {}\", start_path.display()))?;\n        self.parser\n            .set_language(\u0026language)\n            .map_err(|e| anyhow::anyhow!(\"言語の設定に失敗: {}\", e))?;\n        let tree = self\n            .parser\n            .parse(file_content, None)\n            .ok_or_else(|| anyhow::anyhow!(\"パース失敗: {}\", start_path.display()))?;\n\n        let query_path = self.get_query_path(\u0026language, \"definitions\")?;\n        let query_str = std::fs::read_to_string(\u0026query_path)?;\n        let query = tree_sitter::Query::new(\u0026language, \u0026query_str)?;\n\n        let mut query_cursor = tree_sitter::QueryCursor::new();\n        let mut matches = query_cursor.matches(\u0026query, tree.root_node(), file_content.as_bytes());\n\n        let mut to_visit: Vec\u003c(PathBuf, String)\u003e = Vec::new();\n\n        while let Some(mat) = matches.next() {\n            let mut def_node: Option\u003ctree_sitter::Node\u003e = None;\n            let mut name_node: Option\u003ctree_sitter::Node\u003e = None;\n            for cap in mat.captures {\n                let capture_name = \u0026query.capture_names()[cap.index as usize];\n                match \u0026capture_name[..] {\n                    \"definition\" =\u003e def_node = Some(cap.node),\n                    \"name\" =\u003e name_node = Some(cap.node),\n                    _ =\u003e {}\n                }\n            }\n            if let (Some(def_node), Some(name_node)) = (def_node, name_node) {\n                let name = name_node.utf8_text(file_content.as_bytes())?.to_string();\n                if !collected.contains(\u0026name) {\n                    let start_byte = def_node.start_byte();\n                    let end_byte = def_node.end_byte();\n                    let source = def_node.utf8_text(file_content.as_bytes())?.to_string();\n                    definitions.push(Definition {\n                        name: name.clone(),\n                        start_byte,\n                        end_byte,\n                        source,\n                    });\n                    collected.insert(name.clone());\n                    to_visit.push((start_path.to_path_buf(), name));\n                }\n            }\n        }\n\n        while let Some((file_path, func_name)) = to_visit.pop() {\n            if let Some((_, def)) = self.find_definition(\u0026func_name, \u0026file_path)? {\n                // referencesクエリで呼び出し先を抽出\n                let refs = self.find_references(\u0026def.name)?;\n                for (ref_file, ref_def) in refs {\n                    if !collected.contains(\u0026ref_def.name) {\n                        definitions.push(ref_def.clone());\n                        collected.insert(ref_def.name.clone());\n                        to_visit.push((ref_file, ref_def.name.clone()));\n                    }\n                }\n            }\n        }\n\n        Ok(Context { definitions })\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":22}},{"line":61,"address":[],"length":0,"stats":{"Line":66}},{"line":62,"address":[],"length":0,"stats":{"Line":22}},{"line":63,"address":[],"length":0,"stats":{"Line":44}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":22}},{"line":76,"address":[],"length":0,"stats":{"Line":44}},{"line":77,"address":[],"length":0,"stats":{"Line":22}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":44}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":66}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":22}},{"line":105,"address":[],"length":0,"stats":{"Line":22}},{"line":106,"address":[],"length":0,"stats":{"Line":22}},{"line":108,"address":[],"length":0,"stats":{"Line":22}},{"line":109,"address":[],"length":0,"stats":{"Line":22}},{"line":111,"address":[],"length":0,"stats":{"Line":22}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":22}},{"line":121,"address":[],"length":0,"stats":{"Line":10}},{"line":126,"address":[],"length":0,"stats":{"Line":20}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":10}},{"line":134,"address":[],"length":0,"stats":{"Line":10}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":10}},{"line":140,"address":[],"length":0,"stats":{"Line":20}},{"line":142,"address":[],"length":0,"stats":{"Line":20}},{"line":143,"address":[],"length":0,"stats":{"Line":10}},{"line":144,"address":[],"length":0,"stats":{"Line":10}},{"line":145,"address":[],"length":0,"stats":{"Line":10}},{"line":147,"address":[],"length":0,"stats":{"Line":10}},{"line":148,"address":[],"length":0,"stats":{"Line":10}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":10}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":60}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":150}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":60}},{"line":175,"address":[],"length":0,"stats":{"Line":90}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":60}},{"line":181,"address":[],"length":0,"stats":{"Line":60}},{"line":182,"address":[],"length":0,"stats":{"Line":10}},{"line":183,"address":[],"length":0,"stats":{"Line":10}},{"line":184,"address":[],"length":0,"stats":{"Line":20}},{"line":187,"address":[],"length":0,"stats":{"Line":10}},{"line":192,"address":[],"length":0,"stats":{"Line":10}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":10}},{"line":201,"address":[],"length":0,"stats":{"Line":10}},{"line":203,"address":[],"length":0,"stats":{"Line":30}},{"line":204,"address":[],"length":0,"stats":{"Line":10}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":20}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":10}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":10}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":10}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":850}},{"line":263,"address":[],"length":0,"stats":{"Line":1260}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":420}},{"line":266,"address":[],"length":0,"stats":{"Line":850}},{"line":267,"address":[],"length":0,"stats":{"Line":10}},{"line":268,"address":[],"length":0,"stats":{"Line":10}},{"line":269,"address":[],"length":0,"stats":{"Line":10}},{"line":271,"address":[],"length":0,"stats":{"Line":10}},{"line":272,"address":[],"length":0,"stats":{"Line":10}},{"line":273,"address":[],"length":0,"stats":{"Line":10}},{"line":274,"address":[],"length":0,"stats":{"Line":10}},{"line":275,"address":[],"length":0,"stats":{"Line":10}},{"line":276,"address":[],"length":0,"stats":{"Line":10}},{"line":277,"address":[],"length":0,"stats":{"Line":10}},{"line":286,"address":[],"length":0,"stats":{"Line":10}},{"line":288,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":2}},{"line":292,"address":[],"length":0,"stats":{"Line":2}},{"line":294,"address":[],"length":0,"stats":{"Line":4}},{"line":295,"address":[],"length":0,"stats":{"Line":2}},{"line":296,"address":[],"length":0,"stats":{"Line":2}},{"line":297,"address":[],"length":0,"stats":{"Line":4}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":2}},{"line":306,"address":[],"length":0,"stats":{"Line":2}},{"line":307,"address":[],"length":0,"stats":{"Line":2}},{"line":309,"address":[],"length":0,"stats":{"Line":2}},{"line":310,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":22}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":50}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":10}},{"line":325,"address":[],"length":0,"stats":{"Line":20}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":20}},{"line":330,"address":[],"length":0,"stats":{"Line":20}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":10}},{"line":333,"address":[],"length":0,"stats":{"Line":10}},{"line":334,"address":[],"length":0,"stats":{"Line":20}},{"line":335,"address":[],"length":0,"stats":{"Line":10}},{"line":336,"address":[],"length":0,"stats":{"Line":10}},{"line":337,"address":[],"length":0,"stats":{"Line":10}},{"line":338,"address":[],"length":0,"stats":{"Line":10}},{"line":339,"address":[],"length":0,"stats":{"Line":10}},{"line":341,"address":[],"length":0,"stats":{"Line":10}},{"line":342,"address":[],"length":0,"stats":{"Line":10}},{"line":347,"address":[],"length":0,"stats":{"Line":22}},{"line":348,"address":[],"length":0,"stats":{"Line":10}},{"line":350,"address":[],"length":0,"stats":{"Line":20}},{"line":351,"address":[],"length":0,"stats":{"Line":30}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":2}}],"covered":106,"coverable":210},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","pattern_generator.rs"],"content":"use anyhow::Result;\nuse genai::chat::{ChatMessage, ChatOptions, ChatRequest, JsonSpec};\nuse genai::{Client, ClientConfig};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n#[allow(unused_imports)]\nuse std::path::{Path, PathBuf};\n\nuse crate::repo::RepoOps;\nuse crate::security_patterns::Language;\n\n#[derive(Serialize, Deserialize, Debug)]\npub struct PatternClassification {\n    pub function_name: String,\n    pub pattern_type: Option\u003cString\u003e,\n    pub pattern: String,\n    pub description: String,\n    pub reasoning: String,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct PatternAnalysisResponse {\n    patterns: Vec\u003cPatternClassification\u003e,\n}\n\npub async fn generate_custom_patterns(root_dir: \u0026Path, model: \u0026str) -\u003e Result\u003c()\u003e {\n    println!(\"📂 ディレクトリを解析してdefinitionsを抽出中: {}\", root_dir.display());\n    \n    let repo = RepoOps::new(root_dir.to_path_buf());\n    let files = repo.get_files_to_analyze(None)?;\n    \n    println!(\"📁 検出されたファイル数: {}\", files.len());\n    for file in \u0026files {\n        println!(\"   - {}\", file.display());\n    }\n    \n    let mut all_definitions = Vec::new();\n    let mut languages_found = HashMap::new();\n    \n    for file_path in \u0026files {\n        let mut parser = crate::parser::CodeParser::new()?;\n        if let Err(e) = parser.add_file(file_path) {\n            eprintln!(\"⚠️  ファイルのパース追加に失敗: {}: {}\", file_path.display(), e);\n            continue;\n        }\n        \n        match parser.build_context_from_file(file_path) {\n            Ok(context) =\u003e {\n                let ext = file_path.extension().and_then(|e| e.to_str()).unwrap_or(\"\");\n                let language = Language::from_extension(ext);\n                languages_found.insert(language, true);\n                \n                println!(\"📄 {} (言語: {:?}) から {}個のdefinitionsを検出\", file_path.display(), language, context.definitions.len());\n                if context.definitions.is_empty() {\n                    println!(\"   ⚠️  定義が見つかりませんでした。tree-sitterクエリが適切に動作していない可能性があります。\");\n                } else {\n                    for def in \u0026context.definitions {\n                        println!(\"   - {}\", def.name);\n                    }\n                }\n                for def in context.definitions {\n                    all_definitions.push((def, language));\n                }\n            }\n            Err(e) =\u003e {\n                eprintln!(\"⚠️  コンテキスト収集に失敗: {}: {}\", file_path.display(), e);\n                continue;\n            }\n        }\n    }\n    \n    println!(\"🔍 総計 {}個のdefinitionsを抽出しました\", all_definitions.len());\n    \n    for (language, _) in languages_found {\n        let lang_definitions: Vec\u003c_\u003e = all_definitions.iter()\n            .filter(|(_, lang)| *lang == language)\n            .map(|(def, _)| def)\n            .collect();\n            \n        if lang_definitions.is_empty() {\n            continue;\n        }\n        \n        println!(\"🧠 {:?}言語の{}個のdefinitionsをLLMで分析中...\", language, lang_definitions.len());\n        \n        let patterns = analyze_definitions_for_security_patterns(model, \u0026lang_definitions, language).await?;\n        \n        if !patterns.is_empty() {\n            write_patterns_to_file(root_dir, language, \u0026patterns)?;\n            println!(\"✅ {:?}言語用の{}個のパターンを生成しました\", language, patterns.len());\n        } else {\n            println!(\"ℹ️  {:?}言語でセキュリティパターンは検出されませんでした\", language);\n        }\n    }\n    \n    println!(\"🎉 カスタムパターン生成が完了しました\");\n    Ok(())\n}\n\nasync fn analyze_definitions_for_security_patterns(\n    model: \u0026str,\n    definitions: \u0026[\u0026crate::parser::Definition],\n    language: Language,\n) -\u003e Result\u003cVec\u003cPatternClassification\u003e\u003e {\n    let definitions_text = definitions.iter()\n        .map(|def| format!(\"Function: {}\\nCode:\\n{}\\n---\", def.name, def.source))\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\\n\\n\");\n    \n    let prompt = format!(\n        r#\"Analyze the following function definitions from a {:?} codebase and classify them as security patterns.\n\nFor each function, determine if it should be classified as:\n- \"sources\": Functions that introduce user input, external data, or untrusted data into the application\n- \"sinks\": Functions that can execute, write, or perform dangerous operations with data\n- \"validate\": Functions that validate, sanitize, or secure data\n- null: Functions that don't fit any security pattern category\n\nFor each function that IS a security pattern, generate a regex pattern that would match similar functions.\n\nFunction Definitions:\n{}\n\nReturn a JSON object with this exact structure:\n{{\n  \"patterns\": [\n    {{\n      \"function_name\": \"example_function\",\n      \"pattern_type\": \"sources\",\n      \"pattern\": \"\\\\\\\\bexample_function\\\\\\\\s*\\\\\\\\(\",\n      \"description\": \"Example function description\",\n      \"reasoning\": \"Why this function is classified as this pattern type\"\n    }}\n  ]\n}}\n\nOnly include functions that ARE security patterns (sources, sinks, or validate). Do not include functions that are not security-related.\"#,\n        language, definitions_text\n    );\n    \n    let pattern_schema = serde_json::json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"patterns\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"function_name\": {\"type\": \"string\"},\n                        \"pattern_type\": {\"type\": \"string\", \"enum\": [\"sources\", \"sinks\", \"validate\"]},\n                        \"pattern\": {\"type\": \"string\"},\n                        \"description\": {\"type\": \"string\"},\n                        \"reasoning\": {\"type\": \"string\"}\n                    },\n                    \"required\": [\"function_name\", \"pattern_type\", \"pattern\", \"description\", \"reasoning\"]\n                }\n            }\n        },\n        \"required\": [\"patterns\"]\n    });\n    \n    let client_config = ClientConfig::default().with_chat_options(\n        ChatOptions::default()\n            .with_response_format(JsonSpec::new(\"json_object\", pattern_schema)),\n    );\n    let client = Client::builder().with_config(client_config).build();\n    \n    let chat_req = ChatRequest::new(vec![\n        ChatMessage::system(\"You are a security pattern analyzer. You must reply with exactly one JSON object that matches the specified schema. Do not include any explanatory text outside the JSON object.\"),\n        ChatMessage::user(\u0026prompt),\n    ]);\n    \n    let chat_res = client.exec_chat(model, chat_req, None).await?;\n    let content = chat_res.content_text_as_str()\n        .ok_or_else(|| anyhow::anyhow!(\"Failed to get response content\"))?;\n    \n    println!(\"🔍 LLM Response: {}\", content);\n    \n    let response: PatternAnalysisResponse = serde_json::from_str(content)\n        .map_err(|e| anyhow::anyhow!(\"Failed to parse LLM response: {}. Content: {}\", e, content))?;\n    \n    Ok(response.patterns)\n}\n\npub fn write_patterns_to_file(\n    root_dir: \u0026Path,\n    language: Language,\n    patterns: \u0026[PatternClassification],\n) -\u003e Result\u003c()\u003e {\n    let mut vuln_patterns_path = root_dir.to_path_buf();\n    vuln_patterns_path.push(\"vuln-patterns.yml\");\n    \n    let lang_name = match language {\n        Language::Python =\u003e \"Python\",\n        Language::JavaScript =\u003e \"JavaScript\", \n        Language::TypeScript =\u003e \"TypeScript\",\n        Language::Rust =\u003e \"Rust\",\n        Language::Java =\u003e \"Java\",\n        Language::Go =\u003e \"Go\",\n        Language::Ruby =\u003e \"Ruby\",\n        Language::Other =\u003e return Ok(()),\n    };\n    \n    let mut sources = Vec::new();\n    let mut sinks = Vec::new();\n    let mut validate = Vec::new();\n    \n    for pattern in patterns {\n        match pattern.pattern_type.as_deref() {\n            Some(\"sources\") =\u003e sources.push(pattern),\n            Some(\"sinks\") =\u003e sinks.push(pattern),\n            Some(\"validate\") =\u003e validate.push(pattern),\n            _ =\u003e {}\n        }\n    }\n    \n    let mut yaml_content = format!(\"{}:\\n\", lang_name);\n    \n    if !sources.is_empty() {\n        yaml_content.push_str(\"  sources:\\n\");\n        for pattern in sources {\n            yaml_content.push_str(\u0026format!(\n                \"    - pattern: \\\"{}\\\"\\n      description: \\\"{}\\\"\\n\",\n                pattern.pattern, pattern.description\n            ));\n        }\n    }\n    \n    if !validate.is_empty() {\n        yaml_content.push_str(\"  validate:\\n\");\n        for pattern in validate {\n            yaml_content.push_str(\u0026format!(\n                \"    - pattern: \\\"{}\\\"\\n      description: \\\"{}\\\"\\n\",\n                pattern.pattern, pattern.description\n            ));\n        }\n    }\n    \n    if !sinks.is_empty() {\n        yaml_content.push_str(\"  sinks:\\n\");\n        for pattern in sinks {\n            yaml_content.push_str(\u0026format!(\n                \"    - pattern: \\\"{}\\\"\\n      description: \\\"{}\\\"\\n\",\n                pattern.pattern, pattern.description\n            ));\n        }\n    }\n    \n    if vuln_patterns_path.exists() {\n        let existing_content = std::fs::read_to_string(\u0026vuln_patterns_path)?;\n        let updated_content = format!(\"{}\\n{}\", existing_content, yaml_content);\n        std::fs::write(\u0026vuln_patterns_path, updated_content)?;\n    } else {\n        std::fs::write(\u0026vuln_patterns_path, yaml_content)?;\n    }\n    \n    println!(\"📝 パターンファイルに追記: {}\", vuln_patterns_path.display());\n    Ok(())\n}","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":8}},{"line":190,"address":[],"length":0,"stats":{"Line":8}},{"line":191,"address":[],"length":0,"stats":{"Line":8}},{"line":193,"address":[],"length":0,"stats":{"Line":14}},{"line":194,"address":[],"length":0,"stats":{"Line":6}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":26}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":10}},{"line":211,"address":[],"length":0,"stats":{"Line":10}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":217,"address":[],"length":0,"stats":{"Line":6}},{"line":219,"address":[],"length":0,"stats":{"Line":6}},{"line":220,"address":[],"length":0,"stats":{"Line":2}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":6}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":8}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":4}},{"line":241,"address":[],"length":0,"stats":{"Line":16}},{"line":242,"address":[],"length":0,"stats":{"Line":4}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":249,"address":[],"length":0,"stats":{"Line":6}},{"line":250,"address":[],"length":0,"stats":{"Line":4}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":257,"address":[],"length":0,"stats":{"Line":6}},{"line":258,"address":[],"length":0,"stats":{"Line":6}}],"covered":35,"coverable":125},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","prompts","analysis.rs"],"content":"use crate::response::VulnType;\nuse std::collections::HashMap;\n\npub const SYS_PROMPT_TEMPLATE: \u0026str = r#\"\nあなたはセキュリティ研究者として、コードの脆弱性を分析します。特に以下に注目してください：\n- 入力値の検証とサニタイズ\n- 認証・認可\n- データの取り扱いと漏洩\n- コマンドインジェクションの可能性\n- パストラバーサルの脆弱性\n- その他セキュリティ上重要なパターン\n\"#;\n\npub const INITIAL_ANALYSIS_PROMPT_TEMPLATE: \u0026str = r#\"\n与えられたコードをセキュリティ脆弱性の観点から分析してください。特に以下を考慮してください：\n- ユーザー入力の取り扱いと検証\n- 認証・認可の仕組み\n- データのサニタイズやエスケープ\n- ファイルシステム操作\n- ネットワークリクエストとレスポンス\n- コマンド実行\n- データベースクエリ\n\"#;\n\npub const ANALYSIS_APPROACH_TEMPLATE: \u0026str = r#\"\n以下の手順で分析を進めてください：\n1. エントリポイントとユーザーが制御可能な入力を特定する\n2. アプリケーション内のデータフローを追跡する\n3. セキュリティ上重要な操作を調査する\n4. 既存の防御策を回避する手法（バイパス）を検討する\n5. 潜在的な脆弱性の影響を評価する\n\"#;\n\npub const GUIDELINES_TEMPLATE: \u0026str = r#\"\n以下のガイドラインを遵守してください：\n1. 実際に悪用可能な脆弱性に絞って分析する\n2. 該当するコード箇所や行番号を具体的に示す\n3. アプリケーション全体の文脈を考慮する\n4. コードの可視性や分析の深さに応じて信頼度を評価する\n5. より良い分析のために追加情報が必要な場合はリクエストする\n6. 必ず日本語で応答してください\n\"#;\n\npub mod vuln_specific {\n    use super::*;\n\n    pub struct VulnTypeInfo {\n        pub prompt: String,\n        pub bypasses: Vec\u003cString\u003e,\n    }\n\n    pub fn get_vuln_specific_info() -\u003e HashMap\u003cVulnType, VulnTypeInfo\u003e {\n        let mut map = HashMap::new();\n\n        map.insert(\n            VulnType::LFI,\n            VulnTypeInfo {\n                prompt: \"Analyze for Local File Inclusion vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"Path traversal sequences(../../)\".to_string(),\n                    \"URL encoding\".to_string(),\n                    \"Null byte injection\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::RCE,\n            VulnTypeInfo {\n                prompt: \"Analyze for Remote Code Execution vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"Shell metacharacters for command injection\".to_string(),\n                    \"Python execution vectors\".to_string(),\n                    \"Deserialization attacks\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::SSRF,\n            VulnTypeInfo {\n                prompt: \"Analyze for Server-Side Request Forgery vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"DNS rebinding\".to_string(),\n                    \"IP address encoding tricks\".to_string(),\n                    \"Redirect chain\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::AFO,\n            VulnTypeInfo {\n                prompt: \"Analyze for Arbitrary File Operation vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"Directory traversal sequences\".to_string(),\n                    \"Following symbolic links\".to_string(),\n                    \"Race conditions\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::SQLI,\n            VulnTypeInfo {\n                prompt: \"Analyze for SQL Injection vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"UNION-based injection\".to_string(),\n                    \"Boolean-based blind injection\".to_string(),\n                    \"Time-based blind injection\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::XSS,\n            VulnTypeInfo {\n                prompt: \"Analyze for Cross-Site Scripting vulnerabilities...\".to_string(),\n                bypasses: vec![\n                    \"HTML entity encoding bypass\".to_string(),\n                    \"JavaScript template injection\".to_string(),\n                    \"DOM-based XSS vectors\".to_string(),\n                ],\n            },\n        );\n\n        map.insert(\n            VulnType::IDOR,\n            VulnTypeInfo {\n                prompt: \"Analyze for Insecure Direct Object Reference vulnerabilities...\"\n                    .to_string(),\n                bypasses: vec![\n                    \"Parameter tampering\".to_string(),\n                    \"Horizontal privilege escalation\".to_string(),\n                    \"Predictable resource paths\".to_string(),\n                ],\n            },\n        );\n\n        map\n    }\n}\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":60},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","prompts","evaluator.rs"],"content":"pub const EVALUATOR_PROMPT_TEMPLATE: \u0026str = r#\"あなたは、脆弱性分析レポートを評価するセキュリティ専門家です。\nこのレポートは、SQLインジェクション（SQLI）、クロスサイトスクリプティング（XSS）、リモートコード実行（RCE）の脆弱性が含まれていることが知られているPythonウェブアプリケーションの脆弱性を特定することを目的としています。\n\n以下の観点からレポートを評価してください：\n1. 正しく特定された脆弱性（SQLI、XSS、RCE）\n2. 誤検知（存在しない脆弱性が報告されている場合）\n3. 分析の質（影響評価、根本原因の説明、緩和策の提案）\n4. 検証用コードの質（明確な手順、例となるリクエスト、期待される結果）\n\n評価対象のレポート：\n{report}\n\"#;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","prompts","mod.rs"],"content":"mod analysis;\nmod evaluator;\n\npub use analysis::*;\npub use evaluator::EVALUATOR_PROMPT_TEMPLATE;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","repo.rs"],"content":"use anyhow::Result;\nuse crate::security_patterns::SecurityRiskPatterns;\nuse std::{\n    fs::{read_dir, read_to_string, File},\n    io::{BufRead, BufReader, Result as IoResult},\n    path::{Path, PathBuf},\n};\n#[derive(Default)]\npub struct LanguageExclusions {\n    pub file_patterns: Vec\u003cString\u003e,\n}\n\npub struct RepoOps {\n    repo_path: PathBuf,\n    gitignore_patterns: Vec\u003cString\u003e,\n    language_exclusions: LanguageExclusions,\n    supported_extensions: Vec\u003cString\u003e,\n    code_parser: crate::parser::CodeParser,\n    parser_initialized: bool,\n}\n\nimpl RepoOps {\n    pub fn new(repo_path: PathBuf) -\u003e Self {\n        let gitignore_patterns = Self::read_gitignore(\u0026repo_path).unwrap_or_default();\n\n        let language_exclusions = LanguageExclusions {\n            file_patterns: vec![\"test_\".to_string(), \"conftest\".to_string()],\n        };\n\n        let code_parser = crate::parser::CodeParser::new().unwrap();\n        let supported_extensions = vec![\n            \"py\".to_string(),\n            \"js\".to_string(),\n            \"jsx\".to_string(),\n            \"ts\".to_string(),\n            \"tsx\".to_string(),\n            \"rs\".to_string(),\n            \"go\".to_string(),\n            \"java\".to_string(),\n            \"rb\".to_string(),\n        ];\n\n        Self {\n            repo_path,\n            gitignore_patterns,\n            language_exclusions,\n            supported_extensions,\n            code_parser,\n            parser_initialized: false,\n        }\n    }\n\n    pub fn collect_context_for_security_pattern(\n        \u0026mut self,\n        file_path: \u0026std::path::Path,\n    ) -\u003e anyhow::Result\u003ccrate::parser::Context\u003e {\n        self.code_parser.build_context_from_file(file_path)\n    }\n\n    fn read_gitignore(repo_path: \u0026Path) -\u003e IoResult\u003cVec\u003cString\u003e\u003e {\n        let gitignore_path = repo_path.join(\".gitignore\");\n        if !gitignore_path.exists() {\n            return Ok(Vec::new());\n        }\n\n        let file = File::open(gitignore_path)?;\n        let reader = BufReader::new(file);\n        let mut patterns = Vec::new();\n\n        for line in reader.lines() {\n            let line = line?;\n            let trimmed = line.trim();\n            if !trimmed.is_empty() \u0026\u0026 !trimmed.starts_with('#') {\n                patterns.push(trimmed.to_string());\n            };\n        }\n\n        Ok(patterns)\n    }\n\n    #[allow(clippy::only_used_in_recursion)]\n    fn visit_dirs(\u0026self, dir: \u0026Path, cb: \u0026mut dyn FnMut(\u0026Path)) -\u003e std::io::Result\u003c()\u003e {\n        if dir.is_dir() {\n            for entry in read_dir(dir)? {\n                let entry = entry?;\n                let path = entry.path();\n                if path.is_dir() {\n                    self.visit_dirs(\u0026path, cb)?;\n                } else {\n                    cb(\u0026path);\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn should_exclude_path(\u0026self, path: \u0026Path) -\u003e bool {\n        if let Ok(relative_path) = path.strip_prefix(\u0026self.repo_path) {\n            let relative_str = relative_path.to_string_lossy();\n\n            for pattern in \u0026self.gitignore_patterns {\n                if Self::matches_gitignore_pattern(\u0026relative_str, pattern) {\n                    return true;\n                }\n            }\n\n            if let Some(file_name) = path.file_name() {\n                let file_name = file_name.to_string_lossy().to_lowercase();\n                if self\n                    .language_exclusions\n                    .file_patterns\n                    .iter()\n                    .any(|pattern| file_name.contains(pattern))\n                {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n\n    /// Determine if a path matches a .gitignore style pattern.\n    ///\n    /// The function is public so that integration tests can verify the\n    /// behaviour of pattern matching.\n    pub fn matches_gitignore_pattern(path: \u0026str, pattern: \u0026str) -\u003e bool {\n        let pattern = pattern.trim_start_matches('/');\n        let path = path.trim_start_matches('/');\n\n        if let Some(stripped) = pattern.strip_prefix('*') {\n            path.ends_with(stripped)\n        } else if let Some(stripped) = pattern.strip_suffix('*') {\n            path.starts_with(stripped)\n        } else if !pattern.contains('/') {\n            if path == pattern {\n                true\n            } else {\n                path.split('/')\n                    .any(|segment| segment == pattern)\n            }\n        } else {\n            path == pattern || path.starts_with(\u0026format!(\"{}/\", pattern))\n        }\n    }\n\n    pub fn get_relevant_files(\u0026self) -\u003e Vec\u003cPathBuf\u003e {\n        let mut files = Vec::new();\n\n        let mut callback = |path: \u0026Path| {\n            if let Some(ext) = path.extension() {\n                let ext_str = ext.to_string_lossy().to_lowercase();\n                if !self.supported_extensions.contains(\u0026ext_str) {\n                    return;\n                }\n\n                if self.should_exclude_path(path) {\n                    return;\n                }\n\n                files.push(path.to_path_buf());\n            }\n        };\n\n        if let Err(e) = self.visit_dirs(\u0026self.repo_path, \u0026mut callback) {\n            eprintln!(\"ディレクトリの走査中にエラーが発生しました: {}\", e);\n        }\n\n        files\n    }\n\n    pub fn get_network_related_files(\u0026self, files: \u0026[PathBuf]) -\u003e Vec\u003cPathBuf\u003e {\n        let mut network_files = Vec::new();\n        for file_path in files {\n            if let Ok(content) = read_to_string(file_path) {\n                let ext = file_path\n                    .extension()\n                    .and_then(|e| e.to_str())\n                    .unwrap_or(\"\");\n                let lang = crate::security_patterns::Language::from_extension(ext);\n                let patterns = SecurityRiskPatterns::new(lang);\n                if patterns.matches(\u0026content) {\n                    network_files.push(file_path.clone());\n                }\n            }\n        }\n\n        network_files\n    }\n\n    pub fn get_files_to_analyze(\u0026self, analyze_path: Option\u003cPathBuf\u003e) -\u003e Result\u003cVec\u003cPathBuf\u003e\u003e {\n        let path_to_analyze = analyze_path.unwrap_or_else(|| self.repo_path.clone());\n\n        if path_to_analyze.is_file() {\n            if let Some(ext) = path_to_analyze.extension() {\n                let ext_str = ext.to_string_lossy().to_lowercase();\n                if self.supported_extensions.contains(\u0026ext_str) {\n                    return Ok(vec![path_to_analyze]);\n                }\n            }\n            Ok(vec![])\n        } else if path_to_analyze.is_dir() {\n            let mut files = Vec::new();\n            let mut callback = |path: \u0026Path| {\n                if let Some(ext) = path.extension() {\n                    let ext_str = ext.to_string_lossy().to_lowercase();\n                    if self.supported_extensions.contains(\u0026ext_str) {\n                        files.push(path.to_path_buf());\n                    }\n                }\n            };\n\n            self.visit_dirs(\u0026path_to_analyze, \u0026mut callback)?;\n            Ok(files)\n        } else {\n            anyhow::bail!(\n                \"指定された解析パスが存在しません: {}\",\n                path_to_analyze.display()\n            )\n        }\n    }\n\n    pub fn parse_repo_files(\u0026mut self, analyze_path: Option\u003cPathBuf\u003e) -\u003e Result\u003c()\u003e {\n        let files = self.get_files_to_analyze(analyze_path)?;\n        for file in \u0026files {\n            self.code_parser.add_file(file)?;\n        }\n        self.parser_initialized = true;\n\n        Ok(())\n    }\n\n    pub fn find_definition_in_repo(\n        \u0026mut self,\n        name: \u0026str,\n        source_file: \u0026Path,\n    ) -\u003e anyhow::Result\u003cOption\u003c(PathBuf, crate::parser::Definition)\u003e\u003e {\n        if !self.parser_initialized {\n            self.parse_repo_files(None)?;\n        }\n\n        self.code_parser.find_definition(name, source_file)\n    }\n\n    pub fn find_references_in_repo(\n        \u0026mut self,\n        name: \u0026str,\n    ) -\u003e anyhow::Result\u003cVec\u003c(PathBuf, crate::parser::Definition)\u003e\u003e {\n        if !self.parser_initialized {\n            self.parse_repo_files(None)?;\n        }\n        self.code_parser.find_references(name)\n    }\n    pub fn add_file_to_parser(\u0026mut self, path: \u0026std::path::Path) -\u003e anyhow::Result\u003c()\u003e {\n        self.code_parser.add_file(path)\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":4}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":34,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":10}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":20}},{"line":127,"address":[],"length":0,"stats":{"Line":20}},{"line":128,"address":[],"length":0,"stats":{"Line":20}},{"line":130,"address":[],"length":0,"stats":{"Line":26}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":20}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":14}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":6}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":6}},{"line":204,"address":[],"length":0,"stats":{"Line":8}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}}],"covered":59,"coverable":124},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","repo_clone.rs"],"content":"use git2::{Cred, Error, FetchOptions, RemoteCallbacks, Repository};\nuse std::env;\nuse std::path::Path;\n\n/// GitHubリポジトリをcloneする\n///\n/// # 引数\n/// - repo: \"owner/repo\" 形式のGitHubリポジトリ名\n/// - dest: clone先ディレクトリ\n///\n/// # 戻り値\n/// - Ok(()) 成功\n/// - Err(Error) 失敗\npub fn clone_github_repo(repo: \u0026str, dest: \u0026Path) -\u003e Result\u003c(), Error\u003e {\n    // 既存ディレクトリがあればエラー\n    if dest.exists() {\n        return Err(Error::from_str(\"Destination directory already exists\"));\n    }\n\n    // GitHubリポジトリURL組み立て\n    let url = format!(\"https://github.com/{}.git\", repo);\n\n    // GITHUB_TOKENがあれば認証付き\n    let token = env::var(\"GITHUB_TOKEN\").ok();\n\n    let mut callbacks = RemoteCallbacks::new();\n    if let Some(ref token) = token {\n        callbacks.credentials(move |_url, _username_from_url, _allowed_types| {\n            Cred::userpass_plaintext(\"x-access-token\", token)\n        });\n    }\n\n    let mut fetch_options = FetchOptions::new();\n    if token.is_some() {\n        fetch_options.remote_callbacks(callbacks);\n    }\n\n    // 空リポジトリ作成\n    let repo = Repository::init(dest)?;\n    // origin remote 作成\n    let mut remote = repo.remote(\"origin\", \u0026url)?;\n\n    // fetch\n    remote.fetch(\n        \u0026[\"refs/heads/*:refs/remotes/origin/*\"],\n        Some(\u0026mut fetch_options),\n        None,\n    )?;\n\n    // HEAD をセット\n    let fetch_head = repo.find_reference(\"FETCH_HEAD\")?;\n    let fetch_commit = fetch_head.peel_to_commit()?;\n    repo.branch(\"master\", \u0026fetch_commit, true)?;\n    repo.set_head(\"refs/heads/master\")?;\n    repo.checkout_head(None)?;\n\n    Ok(())\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","response.rs"],"content":"use serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\n#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]\npub enum VulnType {\n    LFI,\n    RCE,\n    SSRF,\n    AFO,\n    SQLI,\n    XSS,\n    IDOR,\n    Other(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ContextCode {\n    pub name: String,\n    pub reason: String,\n    pub code_line: String,\n    pub path: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Response {\n    pub scratchpad: String,\n    pub analysis: String,\n    pub poc: String,\n    pub confidence_score: i32,\n    pub vulnerability_types: Vec\u003cVulnType\u003e,\n    pub context_code: Vec\u003cContextCode\u003e,\n}\n\npub fn response_json_schema() -\u003e serde_json::Value {\n    json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"scratchpad\": { \"type\": \"string\" },\n            \"analysis\": { \"type\": \"string\" },\n            \"poc\": { \"type\": \"string\" },\n            \"confidence_score\": { \"type\": \"integer\" },\n            \"vulnerability_types\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"LFI\", \"RCE\", \"SSRF\", \"AFO\", \"SQLI\", \"XSS\", \"IDOR\"]\n                }\n            },\n            \"context_code\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"name\": { \"type\": \"string\" },\n                        \"reason\": { \"type\": \"string\" },\n                        \"code_line\": { \"type\": \"string\" },\n                        \"path\": { \"type\": \"string\" }\n                    },\n                    \"required\": [\"name\", \"reason\", \"code_line\", \"path\"]\n                }\n            }\n        },\n        \"required\": [\"scratchpad\", \"analysis\", \"poc\", \"confidence_score\", \"vulnerability_types\", \"context_code\"]\n    })\n}\n\nimpl Response {\n    pub fn normalize_confidence_score(score: i32) -\u003e i32 {\n        if score \u003e 0 \u0026\u0026 score \u003c= 10 {\n            score * 10\n        } else {\n            score\n        }\n    }\n\n    pub fn print_readable(\u0026self) {\n        println!(\"\\n📝 解析レポート\");\n        println!(\"{}\", \"=\".repeat(80));\n\n        let confidence_icon = match self.confidence_score {\n            90..=100 =\u003e \"🔴 高\",\n            70..=89 =\u003e \"🟠 中高\",\n            50..=69 =\u003e \"🟡 中\",\n            30..=49 =\u003e \"🟢 中低\",\n            _ =\u003e \"🔵 低\",\n        };\n        println!(\n            \"\\n🎯 信頼度スコア: {} ({})\",\n            self.confidence_score, confidence_icon\n        );\n\n        if !self.vulnerability_types.is_empty() {\n            println!(\"\\n⚠ 検出された脆弱性タイプ:\");\n            for vuln_type in \u0026self.vulnerability_types {\n                println!(\"  - {:?}\", vuln_type);\n            }\n        }\n\n        println!(\"\\n🔍 解析結果:\");\n        println!(\"{}\", \"-\".repeat(80));\n        println!(\"{}\", self.analysis);\n\n        if !self.poc.is_empty() {\n            println!(\"\\n🔨 PoC(概念実証コード):\");\n            println!(\"{}\", \"-\".repeat(80));\n            println!(\"{}\", self.poc);\n        }\n\n        if !self.context_code.is_empty() {\n            println!(\"\\n📄 関連コードコンテキスト:\");\n            println!(\"{}\", \"-\".repeat(80));\n            for context in \u0026self.context_code {\n                println!(\"関数名: {}\", context.name);\n                println!(\"理由: {}\", context.reason);\n                println!(\"コード: {}\", context.code_line);\n                println!(\"パス: {}\", context.path);\n                println!();\n            }\n        }\n\n        if !self.scratchpad.is_empty() {\n            println!(\"\\n📓 解析ノート:\");\n            println!(\"{}\", \"-\".repeat(80));\n            println!(\"{}\", self.scratchpad);\n        }\n\n        println!();\n    }\n\n    pub fn to_markdown(\u0026self) -\u003e String {\n        let mut md = String::new();\n        md.push_str(\"# 解析レポート\\n\\n\");\n\n        let confidence_badge = match self.confidence_score {\n            90..=100 =\u003e \"![高信頼度](https://img.shields.io/badge/信頼度-高-red)\",\n            70..=89 =\u003e \"![中高信頼度](https://img.shields.io/badge/信頼度-中高-orange)\",\n            50..=69 =\u003e \"![中信頼度](https://img.shields.io/badge/信頼度-中-yellow)\",\n            30..=49 =\u003e \"![中低信頼度](https://img.shields.io/badge/信頼度-中低-green)\",\n            _ =\u003e \"![低信頼度](https://img.shields.io/badge/信頼度-低-blue)\",\n        };\n        md.push_str(\u0026format!(\n            \"{} **信頼度スコア: {}**\\n\\n\",\n            confidence_badge, self.confidence_score\n        ));\n\n        if !self.vulnerability_types.is_empty() {\n            md.push_str(\"## 脆弱性タイプ\\n\\n\");\n            for vuln_type in \u0026self.vulnerability_types {\n                md.push_str(\u0026format!(\"- `{:?}`\\n\", vuln_type));\n            }\n            md.push('\\n');\n        }\n\n        md.push_str(\"## 解析結果\\n\\n\");\n        md.push_str(\u0026self.analysis);\n        md.push_str(\"\\n\\n\");\n\n        if !self.poc.is_empty() {\n            md.push_str(\"## PoC（概念実証コード）\\n\\n\");\n            md.push_str(\"```text\\n\");\n            md.push_str(\u0026self.poc);\n            md.push_str(\"\\n```\\n\\n\");\n        }\n\n        if !self.context_code.is_empty() {\n            md.push_str(\"## 関連コードコンテキスト\\n\\n\");\n            for context in \u0026self.context_code {\n                md.push_str(\u0026format!(\"### 関数名: {}\\n\", context.name));\n                md.push_str(\u0026format!(\"- 理由: {}\\n\", context.reason));\n                md.push_str(\u0026format!(\"- パス: {}\\n\", context.path));\n                md.push_str(\"```rust\\n\");\n                md.push_str(\u0026context.code_line);\n                md.push_str(\"\\n```\\n\\n\");\n            }\n        }\n\n        if !self.scratchpad.is_empty() {\n            md.push_str(\"## 解析ノート\\n\\n\");\n            md.push_str(\u0026self.scratchpad);\n            md.push_str(\"\\n\\n\");\n        }\n\n        md\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct FileAnalysisResult {\n    pub file_path: PathBuf,\n    pub response: Response,\n}\n\n#[derive(Debug, Clone, Default)]\npub struct AnalysisSummary {\n    pub results: Vec\u003cFileAnalysisResult\u003e,\n}\n\nimpl AnalysisSummary {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn add_result(\u0026mut self, file_path: PathBuf, response: Response) {\n        self.results.push(FileAnalysisResult {\n            file_path,\n            response,\n        });\n    }\n\n    pub fn sort_by_confidence(\u0026mut self) {\n        self.results.sort_by(|a, b| {\n            b.response\n                .confidence_score\n                .cmp(\u0026a.response.confidence_score)\n        });\n    }\n\n    pub fn filter_by_min_confidence(\u0026self, min_score: i32) -\u003e Self {\n        Self {\n            results: self\n                .results\n                .iter()\n                .filter(|r| r.response.confidence_score \u003e= min_score)\n                .cloned()\n                .collect(),\n        }\n    }\n\n    pub fn filter_by_vuln_types(\u0026self, vuln_types: \u0026[VulnType]) -\u003e Self {\n        Self {\n            results: self\n                .results\n                .iter()\n                .filter(|r| {\n                    r.response\n                        .vulnerability_types\n                        .iter()\n                        .any(|vt| vuln_types.contains(vt))\n                })\n                .cloned()\n                .collect(),\n        }\n    }\n\n    pub fn to_markdown(\u0026self) -\u003e String {\n        let mut md = String::new();\n        md.push_str(\"# 脆弱性解析サマリーレポート\\n\\n\");\n\n        md.push_str(\"## 概要\\n\\n\");\n        md.push_str(\"| ファイル | 脆弱性タイプ | 信頼度 | 重要度 |\\n\");\n        md.push_str(\"|---------|------------|--------|--------|\\n\");\n\n        for result in \u0026self.results {\n            if result.response.confidence_score \u003e 0 {\n                let confidence_level = match result.response.confidence_score {\n                    90..=100 =\u003e \"🔴 高\",\n                    70..=89 =\u003e \"🟠 中高\",\n                    50..=69 =\u003e \"🟡 中\",\n                    30..=49 =\u003e \"🟢 中低\",\n                    _ =\u003e \"🔵 低\",\n                };\n\n                let vuln_types = result\n                    .response\n                    .vulnerability_types\n                    .iter()\n                    .map(|vt| format!(\"{:?}\", vt))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n\n                md.push_str(\u0026format!(\n                    \"| [{}]({}.md) | {} | {} | {} |\\n\",\n                    result\n                        .file_path\n                        .file_name()\n                        .unwrap_or_default()\n                        .to_string_lossy(),\n                    result\n                        .file_path\n                        .file_name()\n                        .unwrap_or_default()\n                        .to_string_lossy(),\n                    vuln_types,\n                    result.response.confidence_score,\n                    confidence_level\n                ));\n            }\n        }\n\n        md.push_str(\"\\n## 脆弱性タイプ別集計\\n\\n\");\n\n        let mut type_count: HashMap\u003c\u0026VulnType, i32\u003e = HashMap::new();\n        for result in \u0026self.results {\n            for vuln_type in \u0026result.response.vulnerability_types {\n                *type_count.entry(vuln_type).or_insert(0) += 1;\n            }\n        }\n\n        md.push_str(\"| 脆弱性タイプ | 件数 |\\n\");\n        md.push_str(\"|------------|------|\\n\");\n\n        for (vuln_type, count) in type_count.iter() {\n            md.push_str(\u0026format!(\"| {:?} | {} |\\n\", vuln_type, count));\n        }\n\n        md\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":14}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":8}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":10}},{"line":202,"address":[],"length":0,"stats":{"Line":10}},{"line":205,"address":[],"length":0,"stats":{"Line":22}},{"line":206,"address":[],"length":0,"stats":{"Line":22}},{"line":207,"address":[],"length":0,"stats":{"Line":22}},{"line":208,"address":[],"length":0,"stats":{"Line":22}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":12}},{"line":214,"address":[],"length":0,"stats":{"Line":10}},{"line":215,"address":[],"length":0,"stats":{"Line":10}},{"line":216,"address":[],"length":0,"stats":{"Line":10}},{"line":220,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}}],"covered":64,"coverable":162},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","src","security_patterns.rs"],"content":"use regex::Regex;\nuse serde::Deserialize;\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::PathBuf;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Language {\n    Python,\n    JavaScript,\n    Rust,\n    TypeScript,\n    Java,\n    Go,\n    Ruby,\n    Other,\n}\n\nimpl Language {\n    pub fn from_extension(ext: \u0026str) -\u003e Self {\n        match ext {\n            \"py\" =\u003e Language::Python,\n            \"js\" =\u003e Language::JavaScript,\n            \"rs\" =\u003e Language::Rust,\n            \"ts\" =\u003e Language::TypeScript,\n            \"java\" =\u003e Language::Java,\n            \"go\" =\u003e Language::Go,\n            \"rb\" =\u003e Language::Ruby,\n            _ =\u003e Language::Other,\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum PatternType {\n    Source,\n    Sink,\n    Validate,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct PatternConfig {\n    pub pattern: String,\n    pub description: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct LanguagePatterns {\n    pub sources: Option\u003cVec\u003cPatternConfig\u003e\u003e,\n    pub sinks: Option\u003cVec\u003cPatternConfig\u003e\u003e,\n    pub validate: Option\u003cVec\u003cPatternConfig\u003e\u003e,\n}\n\npub struct SecurityRiskPatterns {\n    source_patterns: Vec\u003cRegex\u003e,\n    sink_patterns: Vec\u003cRegex\u003e,\n    validate_patterns: Vec\u003cRegex\u003e,\n    pattern_type_map: HashMap\u003cString, PatternType\u003e,\n}\n\nimpl SecurityRiskPatterns {\n    pub fn new(language: Language) -\u003e Self {\n        let pattern_map = Self::load_patterns();\n        let lang_patterns = pattern_map\n            .get(\u0026language)\n            .or_else(|| pattern_map.get(\u0026Language::Other))\n            .unwrap();\n\n        let mut source_patterns = Vec::new();\n        let mut sink_patterns = Vec::new(); \n        let mut validate_patterns = Vec::new();\n        let mut pattern_type_map = HashMap::new();\n\n        if let Some(sources) = \u0026lang_patterns.sources {\n            for config in sources {\n                let regex = Regex::new(\u0026config.pattern).unwrap();\n                pattern_type_map.insert(config.pattern.clone(), PatternType::Source);\n                source_patterns.push(regex);\n            }\n        }\n\n        if let Some(sinks) = \u0026lang_patterns.sinks {\n            for config in sinks {\n                let regex = Regex::new(\u0026config.pattern).unwrap();\n                pattern_type_map.insert(config.pattern.clone(), PatternType::Sink);\n                sink_patterns.push(regex);\n            }\n        }\n\n        if let Some(validates) = \u0026lang_patterns.validate {\n            for config in validates {\n                let regex = Regex::new(\u0026config.pattern).unwrap();\n                pattern_type_map.insert(config.pattern.clone(), PatternType::Validate);\n                validate_patterns.push(regex);\n            }\n        }\n\n        Self { \n            source_patterns,\n            sink_patterns, \n            validate_patterns,\n            pattern_type_map,\n        }\n    }\n\n    pub fn matches(\u0026self, content: \u0026str) -\u003e bool {\n        self.source_patterns.iter().any(|pattern| pattern.is_match(content))\n            || self.sink_patterns.iter().any(|pattern| pattern.is_match(content))\n            || self.validate_patterns.iter().any(|pattern| pattern.is_match(content))\n    }\n\n    /// パターンの種類を取得する。\n    pub fn get_pattern_type(\u0026self, content: \u0026str) -\u003e Option\u003cPatternType\u003e {\n        for (pattern_str, pattern_type) in \u0026self.pattern_type_map {\n            let regex = Regex::new(pattern_str).ok()?;\n            if regex.is_match(content) {\n                return Some(pattern_type.clone());\n            }\n        }\n        None\n    }\n\n    /// 言語ごとのパターン定義を読み込む\n    fn load_patterns() -\u003e HashMap\u003cLanguage, LanguagePatterns\u003e {\n        use Language::*;\n\n        let manifest_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        let yaml_path = manifest_dir\n            .join(\"security_patterns\")\n            .join(\"patterns.yml\");\n        let content = fs::read_to_string(\u0026yaml_path)\n            .unwrap_or_else(|_| panic!(\"failed to read {}\", yaml_path.display()));\n        let raw_map: HashMap\u003cString, LanguagePatterns\u003e =\n            serde_yaml::from_str(\u0026content).expect(\"failed to parse patterns.yml\");\n\n        let mut map = HashMap::new();\n        for (lang, patterns) in raw_map {\n            let key = match lang.as_str() {\n                \"Python\" =\u003e Python,\n                \"JavaScript\" =\u003e JavaScript,\n                \"Rust\" =\u003e Rust,\n                \"TypeScript\" =\u003e TypeScript,\n                \"Java\" =\u003e Java,\n                \"Go\" =\u003e Go,\n                \"Ruby\" =\u003e Ruby,\n                \"Other\" =\u003e Other,\n                _ =\u003e continue,\n            };\n            map.insert(key, patterns);\n        }\n\n        map\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":65},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","analyzer_test.rs"],"content":"#[allow(unused_imports)]\nuse std::path::PathBuf;\n#[allow(unused_imports)]\nuse tempfile::NamedTempFile;\n#[allow(unused_imports)]\nuse vulnhuntrs::analyzer::analyze_file;\n#[allow(unused_imports)]\nuse vulnhuntrs::response::{ContextCode, VulnType};\n\n#[cfg(feature = \"snapshot-test\")]\n#[tokio::test]\nasync fn test_analyze_empty_file() -\u003e anyhow::Result\u003c()\u003e {\n    let temp_file = NamedTempFile::new()?;\n\n    let result = analyze_file(\n        \u0026PathBuf::from(temp_file.path()),\n        \"gpt-4o-mini\",\n        \u0026[PathBuf::from(temp_file.path())],\n        0,\n        \u0026vulnhuntrs::parser::Context {\n            definitions: vec![],\n        },\n        0,\n    )\n    .await?;\n\n    assert_eq!(result.scratchpad, String::new());\n    assert_eq!(result.analysis, String::new());\n    assert_eq!(result.poc, String::new());\n    assert_eq!(result.confidence_score, 0);\n    assert!(result.vulnerability_types.is_empty());\n    assert!(result.context_code.is_empty());\n\n    Ok(())\n}\n\n#[cfg(feature = \"snapshot-test\")]\n#[tokio::test]\nasync fn test_analyze_hardcoded_password() -\u003e anyhow::Result\u003c()\u003e {\n    let temp_file = NamedTempFile::new()?;\n    std::fs::write(\n        temp_file.path(),\n        r#\"\nfn main() {\n    let password = \"hardcoded_password\";\n    println!(\"{}\", password);\n}\n\"#,\n    )?;\n\n    let result = analyze_file(\n        \u0026PathBuf::from(temp_file.path()),\n        \"gpt-4o-mini\",\n        \u0026[PathBuf::from(temp_file.path())],\n        0,\n        \u0026vulnhuntrs::parser::Context {\n            definitions: vec![],\n        },\n        0,\n    )\n    .await?;\n\n    assert!(!result.analysis.is_empty(), \"Analysis should not be empty\");\n    assert!(\n        result.confidence_score \u003e 0,\n        \"Confidence score should be positive\"\n    );\n    assert!(\n        !result.vulnerability_types.is_empty(),\n        \"Should detect vulnerabilities\"\n    );\n    assert!(\n        !result.context_code.is_empty(),\n        \"Should include context code\"\n    );\n\n    Ok(())\n}\n\n#[cfg(feature = \"snapshot-test\")]\n#[tokio::test]\nasync fn test_analyze_authentication_function() -\u003e anyhow::Result\u003c()\u003e {\n    let temp_file = NamedTempFile::new()?;\n    std::fs::write(\n        temp_file.path(),\n        r#\"\nfn authenticate(input: \u0026str) -\u003e bool {\n    let password = \"hardcoded_password\";\n    input == password\n}\n\nfn main() {\n    let user_input = \"test\";\n    if authenticate(user_input) {\n        println!(\"Authenticated!\");\n    }\n}\n\"#,\n    )?;\n\n    let result = analyze_file(\n        \u0026PathBuf::from(temp_file.path()),\n        \"gpt-4o-mini\",\n        \u0026[PathBuf::from(temp_file.path())],\n        0,\n        \u0026vulnhuntrs::parser::Context {\n            definitions: vec![],\n        },\n        0,\n    )\n    .await?;\n\n    assert!(!result.analysis.is_empty(), \"Analysis should not be empty\");\n    assert!(\n        result.confidence_score \u003e= 0,\n        \"Confidence score should be positive\"\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","analyzer_unit_test.rs"],"content":"use std::path::PathBuf;\nuse tempfile::NamedTempFile;\nuse vulnhuntrs::parser::{Context, Definition};\nuse vulnhuntrs::response::Response;\nuse std::io::Write;\n\n// Mock functions for testing\n#[tokio::test]\nasync fn test_analyze_empty_file() -\u003e anyhow::Result\u003c()\u003e {\n    // Create empty temporary file\n    let temp_file = NamedTempFile::new()?;\n    let file_path = temp_file.path().to_path_buf();\n    \n    // Create empty context\n    let context = Context {\n        definitions: vec![],\n    };\n    \n    // Test with mock model (this would require actual API key in real scenario)\n    // For unit test, we'll test the empty file handling specifically\n    let result = analyze_empty_file_logic(\u0026file_path).await?;\n    \n    assert_eq!(result.scratchpad, \"\");\n    assert_eq!(result.analysis, \"\");\n    assert_eq!(result.poc, \"\");\n    assert_eq!(result.confidence_score, 0);\n    assert_eq!(result.vulnerability_types.len(), 0);\n    assert_eq!(result.context_code.len(), 0);\n    \n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_analyze_file_with_basic_content() -\u003e anyhow::Result\u003c()\u003e {\n    // Create temporary file with basic content\n    let mut temp_file = NamedTempFile::new()?;\n    writeln!(temp_file, \"print('Hello, World!')\")?;\n    let file_path = temp_file.path().to_path_buf();\n    \n    // Create context with a mock definition\n    let context = Context {\n        definitions: vec![Definition {\n            name: \"test_function\".to_string(),\n            source: \"def test_function(): pass\".to_string(),\n            start_byte: 0,\n            end_byte: 25,\n        }],\n    };\n    \n    // Test basic file processing logic (without actual LLM call)\n    let content = std::fs::read_to_string(\u0026file_path)?;\n    assert!(!content.is_empty());\n    assert!(content.contains(\"Hello, World!\"));\n    \n    Ok(())\n}\n\n#[test]\nfn test_context_text_generation() {\n    let context = Context {\n        definitions: vec![\n            Definition {\n                name: \"vulnerable_function\".to_string(),\n                source: \"def vulnerable_function(user_input):\\n    os.system(user_input)\".to_string(),\n                start_byte: 0,\n                end_byte: 50,\n            },\n            Definition {\n                name: \"safe_function\".to_string(),\n                source: \"def safe_function(user_input):\\n    return user_input.strip()\".to_string(),\n                start_byte: 60,\n                end_byte: 110,\n            },\n        ],\n    };\n    \n    let mut context_text = String::new();\n    if !context.definitions.is_empty() {\n        context_text.push_str(\"\\nContext Definitions:\\n\");\n        for def in \u0026context.definitions {\n            context_text.push_str(\u0026format!(\n                \"\\nFunction/Definition: {}\\nCode:\\n{}\\n\",\n                def.name, def.source\n            ));\n        }\n    }\n    \n    assert!(context_text.contains(\"vulnerable_function\"));\n    assert!(context_text.contains(\"safe_function\"));\n    assert!(context_text.contains(\"os.system\"));\n    assert!(context_text.contains(\"Context Definitions:\"));\n}\n\n// Simulate the empty file handling logic from analyzer.rs\nasync fn analyze_empty_file_logic(file_path: \u0026PathBuf) -\u003e anyhow::Result\u003cResponse\u003e {\n    let content = std::fs::read_to_string(file_path)?;\n    if content.is_empty() {\n        return Ok(Response {\n            scratchpad: String::new(),\n            analysis: String::new(),\n            poc: String::new(),\n            confidence_score: 0,\n            vulnerability_types: vec![],\n            context_code: vec![],\n        });\n    }\n    \n    // For non-empty files, return a mock response\n    Ok(Response {\n        scratchpad: \"File processed\".to_string(),\n        analysis: \"Basic analysis performed\".to_string(),\n        poc: \"\".to_string(),\n        confidence_score: 5,\n        vulnerability_types: vec![],\n        context_code: vec![],\n    })\n}\n\n#[test]\nfn test_parse_json_response_valid() {\n    let json_content = r#\"{\n        \"scratchpad\": \"Test scratchpad\",\n        \"analysis\": \"Test analysis\",\n        \"poc\": \"Test PoC\",\n        \"confidence_score\": 8,\n        \"vulnerability_types\": [],\n        \"context_code\": []\n    }\"#;\n    \n    let result: Result\u003cResponse, _\u003e = serde_json::from_str(json_content);\n    assert!(result.is_ok());\n    \n    let response = result.unwrap();\n    assert_eq!(response.scratchpad, \"Test scratchpad\");\n    assert_eq!(response.analysis, \"Test analysis\");\n    assert_eq!(response.confidence_score, 8);\n}\n\n#[test]\nfn test_parse_json_response_invalid() {\n    let invalid_json = r#\"{ invalid json content\"#;\n    \n    let result: Result\u003cResponse, _\u003e = serde_json::from_str(invalid_json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_file_path_display() {\n    let file_path = PathBuf::from(\"/test/path/vulnerable.py\");\n    let display_str = format!(\"File: {}\", file_path.display());\n    assert!(display_str.contains(\"vulnerable.py\"));\n    assert!(display_str.contains(\"/test/path/\"));\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","main_unit_test.rs"],"content":"use std::path::PathBuf;\nuse vulnhuntrs::response::{AnalysisSummary, VulnType, Response};\nuse vulnhuntrs::response::FileAnalysisResult;\n\n#[test]\nfn test_vuln_type_parsing() {\n    // Test vulnerability type parsing logic similar to main.rs\n    let types_str = \"LFI,RCE,SSRF,IDOR\";\n    let vuln_types: Vec\u003cVulnType\u003e = types_str\n        .split(',')\n        .map(|s| match s.trim() {\n            \"LFI\" =\u003e VulnType::LFI,\n            \"RCE\" =\u003e VulnType::RCE,\n            \"SSRF\" =\u003e VulnType::SSRF,\n            \"AFO\" =\u003e VulnType::AFO,\n            \"SQLI\" =\u003e VulnType::SQLI,\n            \"XSS\" =\u003e VulnType::XSS,\n            \"IDOR\" =\u003e VulnType::IDOR,\n            other =\u003e VulnType::Other(other.to_string()),\n        })\n        .collect();\n    \n    assert_eq!(vuln_types.len(), 4);\n    assert_eq!(vuln_types[0], VulnType::LFI);\n    assert_eq!(vuln_types[1], VulnType::RCE);\n    assert_eq!(vuln_types[2], VulnType::SSRF);\n    assert_eq!(vuln_types[3], VulnType::IDOR);\n}\n\n#[test]\nfn test_vuln_type_parsing_with_unknown_type() {\n    let types_str = \"LFI,UNKNOWN_TYPE,RCE\";\n    let vuln_types: Vec\u003cVulnType\u003e = types_str\n        .split(',')\n        .map(|s| match s.trim() {\n            \"LFI\" =\u003e VulnType::LFI,\n            \"RCE\" =\u003e VulnType::RCE,\n            \"SSRF\" =\u003e VulnType::SSRF,\n            \"AFO\" =\u003e VulnType::AFO,\n            \"SQLI\" =\u003e VulnType::SQLI,\n            \"XSS\" =\u003e VulnType::XSS,\n            \"IDOR\" =\u003e VulnType::IDOR,\n            other =\u003e VulnType::Other(other.to_string()),\n        })\n        .collect();\n    \n    assert_eq!(vuln_types.len(), 3);\n    assert_eq!(vuln_types[0], VulnType::LFI);\n    assert_eq!(vuln_types[1], VulnType::Other(\"UNKNOWN_TYPE\".to_string()));\n    assert_eq!(vuln_types[2], VulnType::RCE);\n}\n\n#[test]\nfn test_analysis_summary_creation() {\n    let mut summary = AnalysisSummary::new();\n    \n    // Create mock responses\n    let response1 = Response {\n        scratchpad: \"Test scratchpad 1\".to_string(),\n        analysis: \"Test analysis 1\".to_string(),\n        poc: \"Test PoC 1\".to_string(),\n        confidence_score: 8,\n        vulnerability_types: vec![VulnType::RCE],\n        context_code: vec![],\n    };\n    \n    let response2 = Response {\n        scratchpad: \"Test scratchpad 2\".to_string(),\n        analysis: \"Test analysis 2\".to_string(),\n        poc: \"Test PoC 2\".to_string(),\n        confidence_score: 6,\n        vulnerability_types: vec![VulnType::SQLI],\n        context_code: vec![],\n    };\n    \n    // Add results to summary\n    summary.add_result(PathBuf::from(\"/test/file1.py\"), response1);\n    summary.add_result(PathBuf::from(\"/test/file2.py\"), response2);\n    \n    assert_eq!(summary.results.len(), 2);\n    assert_eq!(summary.results[0].response.confidence_score, 8);\n    assert_eq!(summary.results[1].response.confidence_score, 6);\n}\n\n#[test]\nfn test_analysis_summary_filtering_by_confidence() {\n    let mut summary = AnalysisSummary::new();\n    \n    // Create responses with different confidence scores\n    let high_confidence = Response {\n        scratchpad: \"High confidence\".to_string(),\n        analysis: \"High confidence analysis\".to_string(),\n        poc: \"High confidence PoC\".to_string(),\n        confidence_score: 9,\n        vulnerability_types: vec![VulnType::RCE],\n        context_code: vec![],\n    };\n    \n    let low_confidence = Response {\n        scratchpad: \"Low confidence\".to_string(),\n        analysis: \"Low confidence analysis\".to_string(),\n        poc: \"Low confidence PoC\".to_string(),\n        confidence_score: 3,\n        vulnerability_types: vec![VulnType::XSS],\n        context_code: vec![],\n    };\n    \n    summary.add_result(PathBuf::from(\"/test/high.py\"), high_confidence);\n    summary.add_result(PathBuf::from(\"/test/low.py\"), low_confidence);\n    \n    // Filter by minimum confidence 5\n    let filtered = summary.filter_by_min_confidence(5);\n    \n    assert_eq!(filtered.results.len(), 1);\n    assert_eq!(filtered.results[0].response.confidence_score, 9);\n}\n\n#[test]\nfn test_analysis_summary_filtering_by_vuln_types() {\n    let mut summary = AnalysisSummary::new();\n    \n    let rce_response = Response {\n        scratchpad: \"RCE vulnerability\".to_string(),\n        analysis: \"RCE analysis\".to_string(),\n        poc: \"RCE PoC\".to_string(),\n        confidence_score: 8,\n        vulnerability_types: vec![VulnType::RCE],\n        context_code: vec![],\n    };\n    \n    let sqli_response = Response {\n        scratchpad: \"SQLI vulnerability\".to_string(),\n        analysis: \"SQLI analysis\".to_string(),\n        poc: \"SQLI PoC\".to_string(),\n        confidence_score: 7,\n        vulnerability_types: vec![VulnType::SQLI],\n        context_code: vec![],\n    };\n    \n    let xss_response = Response {\n        scratchpad: \"XSS vulnerability\".to_string(),\n        analysis: \"XSS analysis\".to_string(),\n        poc: \"XSS PoC\".to_string(),\n        confidence_score: 6,\n        vulnerability_types: vec![VulnType::XSS],\n        context_code: vec![],\n    };\n    \n    summary.add_result(PathBuf::from(\"/test/rce.py\"), rce_response);\n    summary.add_result(PathBuf::from(\"/test/sqli.py\"), sqli_response);\n    summary.add_result(PathBuf::from(\"/test/xss.py\"), xss_response);\n    \n    // Filter by specific vulnerability types\n    let filter_types = vec![VulnType::RCE, VulnType::SQLI];\n    let filtered = summary.filter_by_vuln_types(\u0026filter_types);\n    \n    assert_eq!(filtered.results.len(), 2);\n    assert!(filtered.results.iter().any(|r| r.response.vulnerability_types.contains(\u0026VulnType::RCE)));\n    assert!(filtered.results.iter().any(|r| r.response.vulnerability_types.contains(\u0026VulnType::SQLI)));\n    assert!(!filtered.results.iter().any(|r| r.response.vulnerability_types.contains(\u0026VulnType::XSS)));\n}\n\n#[test]\nfn test_analysis_summary_sorting_by_confidence() {\n    let mut summary = AnalysisSummary::new();\n    \n    // Add results in random order\n    let responses = [\n        (PathBuf::from(\"/test/medium.py\"), 5),\n        (PathBuf::from(\"/test/high.py\"), 9),\n        (PathBuf::from(\"/test/low.py\"), 2),\n        (PathBuf::from(\"/test/very_high.py\"), 10),\n    ];\n    \n    for (path, confidence) in responses {\n        let response = Response {\n            scratchpad: format!(\"Confidence {}\", confidence),\n            analysis: format!(\"Analysis with confidence {}\", confidence),\n            poc: format!(\"PoC {}\", confidence),\n            confidence_score: confidence,\n            vulnerability_types: vec![VulnType::RCE],\n            context_code: vec![],\n        };\n        summary.add_result(path, response);\n    }\n    \n    summary.sort_by_confidence();\n    \n    // Should be sorted in descending order by confidence\n    assert_eq!(summary.results[0].response.confidence_score, 10);\n    assert_eq!(summary.results[1].response.confidence_score, 9);\n    assert_eq!(summary.results[2].response.confidence_score, 5);\n    assert_eq!(summary.results[3].response.confidence_score, 2);\n}\n\n#[test]\nfn test_pathbuf_from_string() {\n    // Test path handling logic\n    let path_str = \"/tmp/test/vulnerable.py\";\n    let path = PathBuf::from(path_str);\n    \n    assert_eq!(path.to_string_lossy(), path_str);\n    assert!(path.is_absolute());\n    assert_eq!(path.extension().unwrap(), \"py\");\n}\n\n#[test]\nfn test_model_default_value() {\n    // Test that the default model is correctly set\n    let default_model = \"o4-mini\";\n    assert_eq!(default_model, \"o4-mini\");\n}\n\n#[test]\nfn test_verbosity_levels() {\n    // Test verbosity level handling\n    let verbosity_levels = [0u8, 1u8, 2u8, 3u8];\n    \n    for level in verbosity_levels {\n        match level {\n            0 =\u003e assert_eq!(level, 0), // No verbose output\n            1 =\u003e assert_eq!(level, 1), // Basic verbose output\n            2 =\u003e assert_eq!(level, 2), // More verbose output\n            _ =\u003e assert!(level \u003e= 3),  // Maximum verbosity\n        }\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","pattern_generator_test.rs"],"content":"use std::fs;\nuse std::path::PathBuf;\nuse tempfile::TempDir;\nuse vulnhuntrs::pattern_generator::{write_patterns_to_file, PatternClassification};\nuse vulnhuntrs::security_patterns::Language;\n\nfn create_test_python_file(dir: \u0026TempDir) -\u003e PathBuf {\n    let file_path = dir.path().join(\"test.py\");\n    let content = r#\"\nimport os\nimport subprocess\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\ndef get_user_input():\n    return request.args.get('input', '')\n\ndef execute_command(cmd):\n    return subprocess.run(cmd, shell=True, capture_output=True)\n\ndef write_to_file(filename, data):\n    with open(filename, 'w') as f:\n        f.write(data)\n\ndef validate_input(data):\n    import re\n    return re.match(r'^[a-zA-Z0-9]+$', data) is not None\n\ndef hash_password(password):\n    import hashlib\n    return hashlib.sha256(password.encode()).hexdigest()\n\"#;\n    fs::write(\u0026file_path, content).unwrap();\n    file_path\n}\n\nfn create_test_rust_file(dir: \u0026TempDir) -\u003e PathBuf {\n    let file_path = dir.path().join(\"test.rs\");\n    let content = r#\"\nuse std::process::Command;\nuse std::fs;\n\nfn get_user_data() -\u003e String {\n    std::env::args().nth(1).unwrap_or_default()\n}\n\nfn execute_shell_command(cmd: \u0026str) -\u003e String {\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(cmd)\n        .output()\n        .expect(\"Failed to execute\");\n    String::from_utf8_lossy(\u0026output.stdout).to_string()\n}\n\nfn read_file_contents(path: \u0026str) -\u003e Result\u003cString, std::io::Error\u003e {\n    fs::read_to_string(path)\n}\n\nfn sanitize_input(input: \u0026str) -\u003e String {\n    input.chars().filter(|c| c.is_alphanumeric()).collect()\n}\n\"#;\n    fs::write(\u0026file_path, content).unwrap();\n    file_path\n}\n\n// Note: LLM integration tests are commented out as they require real API keys\n// These would be integration tests that need actual LLM responses\n// \n// #[tokio::test]\n// async fn test_pattern_generation_python() {\n//     let temp_dir = TempDir::new().unwrap();\n//     create_test_python_file(\u0026temp_dir);\n//     \n//     let result = generate_custom_patterns(\u0026temp_dir.path().to_path_buf(), \"test-model\").await;\n//     assert!(result.is_ok());\n//     assert!(temp_dir.path().join(\"vuln-patterns.yml\").exists());\n// }\n//\n// #[tokio::test]\n// async fn test_pattern_generation_rust() {\n//     let temp_dir = TempDir::new().unwrap();\n//     create_test_rust_file(\u0026temp_dir);\n//     \n//     let result = generate_custom_patterns(\u0026temp_dir.path().to_path_buf(), \"test-model\").await;\n//     assert!(result.is_ok());\n//     assert!(temp_dir.path().join(\"vuln-patterns.yml\").exists());\n// }\n\n#[test]\nfn test_yaml_pattern_format() {\n    let temp_dir = TempDir::new().unwrap();\n    \n    let patterns = vec![\n        PatternClassification {\n            function_name: \"test_sink\".to_string(),\n            pattern_type: Some(\"sinks\".to_string()),\n            pattern: \"\\\\\\\\btest_sink\\\\\\\\s*\\\\\\\\(\".to_string(),\n            description: \"Test sink function\".to_string(),\n            reasoning: \"Test reasoning for sink\".to_string(),\n        },\n        PatternClassification {\n            function_name: \"test_source\".to_string(),\n            pattern_type: Some(\"sources\".to_string()),\n            pattern: \"\\\\\\\\btest_source\\\\\\\\s*\\\\\\\\(\".to_string(),\n            description: \"Test source function\".to_string(),\n            reasoning: \"Test reasoning for source\".to_string(),\n        },\n        PatternClassification {\n            function_name: \"test_validate\".to_string(),\n            pattern_type: Some(\"validate\".to_string()),\n            pattern: \"\\\\\\\\btest_validate\\\\\\\\s*\\\\\\\\(\".to_string(),\n            description: \"Test validation function\".to_string(),\n            reasoning: \"Test reasoning for validation\".to_string(),\n        },\n    ];\n    \n    let result = write_patterns_to_file(\u0026temp_dir.path().to_path_buf(), Language::Python, \u0026patterns);\n    assert!(result.is_ok());\n    \n    let yaml_path = temp_dir.path().join(\"vuln-patterns.yml\");\n    assert!(yaml_path.exists());\n    \n    let content = fs::read_to_string(\u0026yaml_path).unwrap();\n    assert!(content.contains(\"Python:\"));\n    assert!(content.contains(\"sources:\"));\n    assert!(content.contains(\"sinks:\"));\n    assert!(content.contains(\"validate:\"));\n    assert!(content.contains(\"test_sink\"));\n    assert!(content.contains(\"test_source\"));\n    assert!(content.contains(\"test_validate\"));\n}\n\n// Integration test that doesn't require API calls\n#[test]\nfn test_file_discovery() {\n    let temp_dir = TempDir::new().unwrap();\n    create_test_python_file(\u0026temp_dir);\n    create_test_rust_file(\u0026temp_dir);\n    \n    let repo = vulnhuntrs::repo::RepoOps::new(temp_dir.path().to_path_buf());\n    let files = repo.get_files_to_analyze(None).unwrap();\n    \n    assert_eq!(files.len(), 2);\n    assert!(files.iter().any(|f| f.file_name().unwrap() == \"test.py\"));\n    assert!(files.iter().any(|f| f.file_name().unwrap() == \"test.rs\"));\n}\n\n#[test]\nfn test_definition_extraction() {\n    let temp_dir = TempDir::new().unwrap();\n    create_test_python_file(\u0026temp_dir);\n    \n    let file_path = temp_dir.path().join(\"test.py\");\n    let mut parser = vulnhuntrs::parser::CodeParser::new().unwrap();\n    parser.add_file(\u0026file_path).unwrap();\n    \n    let context = parser.build_context_from_file(\u0026file_path).unwrap();\n    \n    // Should extract function definitions\n    assert!(!context.definitions.is_empty());\n    \n    // Check if expected functions are found\n    let function_names: Vec\u003c\u0026str\u003e = context.definitions.iter()\n        .map(|def| def.name.as_str())\n        .collect();\n    \n    assert!(function_names.contains(\u0026\"get_user_input\"));\n    assert!(function_names.contains(\u0026\"execute_command\"));\n    assert!(function_names.contains(\u0026\"write_to_file\"));\n    assert!(function_names.contains(\u0026\"validate_input\"));\n    assert!(function_names.contains(\u0026\"hash_password\"));\n}\n\n#[test]\nfn test_yaml_append_functionality() {\n    let temp_dir = TempDir::new().unwrap();\n    let yaml_path = temp_dir.path().join(\"vuln-patterns.yml\");\n    \n    // Write initial content\n    fs::write(\u0026yaml_path, \"Go:\\n  sinks:\\n    - pattern: \\\"existing_pattern\\\"\\n      description: \\\"Existing pattern\\\"\\n\").unwrap();\n    \n    let patterns = vec![\n        PatternClassification {\n            function_name: \"new_function\".to_string(),\n            pattern_type: Some(\"sinks\".to_string()),\n            pattern: \"\\\\\\\\bnew_function\\\\\\\\s*\\\\\\\\(\".to_string(),\n            description: \"New function pattern\".to_string(),\n            reasoning: \"Test reasoning\".to_string(),\n        },\n    ];\n    \n    let result = write_patterns_to_file(\u0026temp_dir.path().to_path_buf(), Language::Python, \u0026patterns);\n    assert!(result.is_ok());\n    \n    let content = fs::read_to_string(\u0026yaml_path).unwrap();\n    assert!(content.contains(\"Go:\"));\n    assert!(content.contains(\"existing_pattern\"));\n    assert!(content.contains(\"Python:\"));\n    assert!(content.contains(\"new_function\"));\n}\n\n#[test]\nfn test_empty_patterns_handling() {\n    let temp_dir = TempDir::new().unwrap();\n    \n    let patterns = vec![\n        PatternClassification {\n            function_name: \"non_security_function\".to_string(),\n            pattern_type: None,\n            pattern: \"\".to_string(),\n            description: \"\".to_string(),\n            reasoning: \"Not a security pattern\".to_string(),\n        },\n    ];\n    \n    let result = write_patterns_to_file(\u0026temp_dir.path().to_path_buf(), Language::Python, \u0026patterns);\n    assert!(result.is_ok());\n    \n    let yaml_path = temp_dir.path().join(\"vuln-patterns.yml\");\n    let content = fs::read_to_string(\u0026yaml_path).unwrap();\n    \n    // Should only contain the language header since no valid patterns were provided\n    assert_eq!(content.trim(), \"Python:\");\n}\n\n#[test]\nfn test_language_filtering() {\n    let temp_dir = TempDir::new().unwrap();\n    \n    let patterns = vec![\n        PatternClassification {\n            function_name: \"test_function\".to_string(),\n            pattern_type: Some(\"sinks\".to_string()),\n            pattern: \"test_pattern\".to_string(),\n            description: \"Test description\".to_string(),\n            reasoning: \"Test reasoning\".to_string(),\n        },\n    ];\n    \n    // Test that Other language is skipped\n    let result = write_patterns_to_file(\u0026temp_dir.path().to_path_buf(), Language::Other, \u0026patterns);\n    assert!(result.is_ok());\n    \n    let yaml_path = temp_dir.path().join(\"vuln-patterns.yml\");\n    assert!(!yaml_path.exists());\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","repo_test.rs"],"content":"use tempfile::tempdir;\nuse vulnhuntrs::repo::RepoOps;\n\n#[test]\nfn test_ruby_files_are_recognized() -\u003e anyhow::Result\u003c()\u003e {\n    let dir = tempdir()?;\n    let file_path = dir.path().join(\"test.rb\");\n    std::fs::write(\u0026file_path, \"puts 'hello'\")?;\n\n    let repo = RepoOps::new(dir.path().to_path_buf());\n    let files = repo.get_relevant_files();\n\n    assert!(files.contains(\u0026file_path));\n    Ok(())\n}\n\n#[test]\nfn test_matches_gitignore_leading_star() {\n    assert!(RepoOps::matches_gitignore_pattern(\"error.log\", \"*.log\"));\n    assert!(RepoOps::matches_gitignore_pattern(\"logs/error.log\", \"*.log\"));\n    assert!(!RepoOps::matches_gitignore_pattern(\"error.txt\", \"*.log\"));\n}\n\n#[test]\nfn test_matches_gitignore_trailing_star() {\n    assert!(RepoOps::matches_gitignore_pattern(\"build/output.o\", \"build/*\"));\n    assert!(RepoOps::matches_gitignore_pattern(\"build/sub/obj.o\", \"build/*\"));\n    assert!(!RepoOps::matches_gitignore_pattern(\"target/output.o\", \"build/*\"));\n}\n\n#[test]\nfn test_matches_gitignore_exact_match() {\n    assert!(RepoOps::matches_gitignore_pattern(\"src/main.rs\", \"src/main.rs\"));\n    assert!(!RepoOps::matches_gitignore_pattern(\"src/lib.rs\", \"src/main.rs\"));\n}\n\n#[test]\nfn test_matches_gitignore_nested_directory() {\n    assert!(RepoOps::matches_gitignore_pattern(\n        \"app/node_modules/package.json\",\n        \"node_modules\"\n    ));\n    assert!(!RepoOps::matches_gitignore_pattern(\n        \"app/modules/package.json\",\n        \"node_modules\"\n    ));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tests","response_unit_test.rs"],"content":"use std::path::PathBuf;\nuse vulnhuntrs::response::{Response, VulnType, ContextCode, AnalysisSummary, response_json_schema};\nuse serde_json::{json, Value};\n\n#[test]\nfn test_vuln_type_serialization() {\n    let vuln_types = vec![\n        VulnType::LFI,\n        VulnType::RCE,\n        VulnType::SSRF,\n        VulnType::AFO,\n        VulnType::SQLI,\n        VulnType::XSS,\n        VulnType::IDOR,\n        VulnType::Other(\"Custom\".to_string()),\n    ];\n    \n    let serialized = serde_json::to_string(\u0026vuln_types).unwrap();\n    let deserialized: Vec\u003cVulnType\u003e = serde_json::from_str(\u0026serialized).unwrap();\n    \n    assert_eq!(vuln_types, deserialized);\n}\n\n#[test]\nfn test_vuln_type_equality() {\n    assert_eq!(VulnType::LFI, VulnType::LFI);\n    assert_eq!(VulnType::Other(\"test\".to_string()), VulnType::Other(\"test\".to_string()));\n    assert_ne!(VulnType::LFI, VulnType::RCE);\n    assert_ne!(VulnType::Other(\"test1\".to_string()), VulnType::Other(\"test2\".to_string()));\n}\n\n#[test]\nfn test_context_code_creation() {\n    let context = ContextCode {\n        name: \"vulnerable_function\".to_string(),\n        reason: \"Uses unsafe eval() function\".to_string(),\n        code_line: \"eval(user_input)\".to_string(),\n        path: \"/src/vulnerable.py\".to_string(),\n    };\n    \n    assert_eq!(context.name, \"vulnerable_function\");\n    assert_eq!(context.reason, \"Uses unsafe eval() function\");\n    assert_eq!(context.code_line, \"eval(user_input)\");\n    assert_eq!(context.path, \"/src/vulnerable.py\");\n}\n\n#[test]\nfn test_response_creation() {\n    let response = Response {\n        scratchpad: \"Analysis notes\".to_string(),\n        analysis: \"Found RCE vulnerability\".to_string(),\n        poc: \"curl -X POST -d 'cmd=ls' /vulnerable-endpoint\".to_string(),\n        confidence_score: 9,\n        vulnerability_types: vec![VulnType::RCE],\n        context_code: vec![ContextCode {\n            name: \"process_command\".to_string(),\n            reason: \"Direct command execution\".to_string(),\n            code_line: \"os.system(command)\".to_string(),\n            path: \"/src/handlers.py\".to_string(),\n        }],\n    };\n    \n    assert_eq!(response.confidence_score, 9);\n    assert_eq!(response.vulnerability_types.len(), 1);\n    assert_eq!(response.context_code.len(), 1);\n    assert!(response.analysis.contains(\"RCE\"));\n}\n\n#[test]\nfn test_response_serialization() {\n    let response = Response {\n        scratchpad: \"Test scratchpad\".to_string(),\n        analysis: \"Test analysis\".to_string(),\n        poc: \"Test PoC\".to_string(),\n        confidence_score: 7,\n        vulnerability_types: vec![VulnType::SQLI, VulnType::XSS],\n        context_code: vec![],\n    };\n    \n    let serialized = serde_json::to_string(\u0026response).unwrap();\n    let deserialized: Response = serde_json::from_str(\u0026serialized).unwrap();\n    \n    assert_eq!(response.confidence_score, deserialized.confidence_score);\n    assert_eq!(response.vulnerability_types, deserialized.vulnerability_types);\n}\n\n#[test]\nfn test_response_json_schema() {\n    let schema = response_json_schema();\n    \n    // Verify schema structure\n    assert_eq!(schema[\"type\"], \"object\");\n    \n    let properties = \u0026schema[\"properties\"];\n    assert!(properties[\"scratchpad\"][\"type\"] == \"string\");\n    assert!(properties[\"analysis\"][\"type\"] == \"string\");\n    assert!(properties[\"poc\"][\"type\"] == \"string\");\n    assert!(properties[\"confidence_score\"][\"type\"] == \"integer\");\n    \n    // Check vulnerability types array schema\n    let vuln_types = \u0026properties[\"vulnerability_types\"];\n    assert_eq!(vuln_types[\"type\"], \"array\");\n    assert!(vuln_types[\"items\"][\"enum\"].as_array().unwrap().contains(\u0026json!(\"RCE\")));\n    assert!(vuln_types[\"items\"][\"enum\"].as_array().unwrap().contains(\u0026json!(\"SQLI\")));\n}\n\n#[test]\nfn test_analysis_summary_default() {\n    let summary = AnalysisSummary::default();\n    assert_eq!(summary.results.len(), 0);\n}\n\n#[test]\nfn test_analysis_summary_new() {\n    let summary = AnalysisSummary::new();\n    assert_eq!(summary.results.len(), 0);\n}\n\n#[test]\nfn test_markdown_generation() {\n    let response = Response {\n        scratchpad: \"Test scratchpad\".to_string(),\n        analysis: \"This is a test analysis with **bold** text\".to_string(),\n        poc: \"echo 'test'\".to_string(),\n        confidence_score: 8,\n        vulnerability_types: vec![VulnType::RCE, VulnType::SQLI],\n        context_code: vec![ContextCode {\n            name: \"test_function\".to_string(),\n            reason: \"Test reason\".to_string(),\n            code_line: \"test_code()\".to_string(),\n            path: \"/test/path.py\".to_string(),\n        }],\n    };\n    \n    let markdown = response.to_markdown();\n    \n    // Verify markdown contains expected sections\n    assert!(markdown.contains(\"# 解析レポート\"));\n    assert!(markdown.contains(\"信頼度スコア: 8\"));\n    assert!(markdown.contains(\"## 脆弱性タイプ\"));\n    assert!(markdown.contains(\"RCE\"));\n    assert!(markdown.contains(\"SQLI\"));\n    assert!(markdown.contains(\"## 解析結果\"));\n    assert!(markdown.contains(\"This is a test analysis\"));\n    assert!(markdown.contains(\"## PoC（概念実証コード）\"));\n    assert!(markdown.contains(\"echo 'test'\"));\n    assert!(markdown.contains(\"## 関連コードコンテキスト\"));\n}\n\n#[test]\nfn test_confidence_score_validation() {\n    // Test various confidence scores\n    let scores = [0, 1, 5, 10, -1, 15];\n    \n    for score in scores {\n        let response = Response {\n            scratchpad: String::new(),\n            analysis: String::new(),\n            poc: String::new(),\n            confidence_score: score,\n            vulnerability_types: vec![],\n            context_code: vec![],\n        };\n        \n        // Confidence score should be stored as-is (validation is handled elsewhere)\n        assert_eq!(response.confidence_score, score);\n    }\n}\n\n#[test]\nfn test_empty_response() {\n    let response = Response {\n        scratchpad: String::new(),\n        analysis: String::new(),\n        poc: String::new(),\n        confidence_score: 0,\n        vulnerability_types: vec![],\n        context_code: vec![],\n    };\n    \n    assert!(response.scratchpad.is_empty());\n    assert!(response.analysis.is_empty());\n    assert!(response.poc.is_empty());\n    assert_eq!(response.confidence_score, 0);\n    assert!(response.vulnerability_types.is_empty());\n    assert!(response.context_code.is_empty());\n}\n\n#[test]\nfn test_context_code_serialization() {\n    let context = ContextCode {\n        name: \"test_func\".to_string(),\n        reason: \"test reason\".to_string(),\n        code_line: \"print('test')\".to_string(),\n        path: \"/path/to/file.py\".to_string(),\n    };\n    \n    let serialized = serde_json::to_string(\u0026context).unwrap();\n    let deserialized: ContextCode = serde_json::from_str(\u0026serialized).unwrap();\n    \n    assert_eq!(context.name, deserialized.name);\n    assert_eq!(context.reason, deserialized.reason);\n    assert_eq!(context.code_line, deserialized.code_line);\n    assert_eq!(context.path, deserialized.path);\n}\n\n#[test]\nfn test_response_with_multiple_context_codes() {\n    let response = Response {\n        scratchpad: \"Multiple contexts\".to_string(),\n        analysis: \"Analysis with multiple context codes\".to_string(),\n        poc: \"PoC code\".to_string(),\n        confidence_score: 6,\n        vulnerability_types: vec![VulnType::XSS],\n        context_code: vec![\n            ContextCode {\n                name: \"func1\".to_string(),\n                reason: \"reason1\".to_string(),\n                code_line: \"code1\".to_string(),\n                path: \"/path1.py\".to_string(),\n            },\n            ContextCode {\n                name: \"func2\".to_string(),\n                reason: \"reason2\".to_string(),\n                code_line: \"code2\".to_string(),\n                path: \"/path2.py\".to_string(),\n            },\n        ],\n    };\n    \n    assert_eq!(response.context_code.len(), 2);\n    assert_eq!(response.context_code[0].name, \"func1\");\n    assert_eq!(response.context_code[1].name, \"func2\");\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-go","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config.std(\"c11\").include(src_dir);\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-go\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-go","bindings","rust","lib.rs"],"content":"//! This crate provides Go language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! func add(a, b int) int {\n//!     return a + b\n//! }\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_go::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading Go parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_go() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_go) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading Go parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-java","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config.std(\"c11\").include(src_dir);\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-java\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-java","bindings","rust","lib.rs"],"content":"//! This crate provides Java language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! class Test {\n//!     int double(int x) {\n//!         return x * 2;\n//!     }\n//! }\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_java::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading Java parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_java() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_java) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading Java parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-javascript","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config\n        .std(\"c11\")\n        .include(src_dir)\n        .flag_if_supported(\"-Wno-unused-parameter\");\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    let scanner_path = src_dir.join(\"scanner.c\");\n    c_config.file(\u0026scanner_path);\n    println!(\"cargo:rerun-if-changed={}\", scanner_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-javascript\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-javascript","bindings","rust","lib.rs"],"content":"//! This crate provides JavaScript language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! function double(x) {\n//!     return x * 2;\n//! }\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_javascript::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading JavaScript parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_javascript() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_javascript) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHT_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The syntax highlighting query for languages injected into this one.\npub const INJECTIONS_QUERY: \u0026str = include_str!(\"../../queries/injections.scm\");\n\n/// The syntax highlighting query for JSX.\npub const JSX_HIGHLIGHT_QUERY: \u0026str = include_str!(\"../../queries/highlights-jsx.scm\");\n\n/// The local-variable syntax highlighting query for this language.\npub const LOCALS_QUERY: \u0026str = include_str!(\"../../queries/locals.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading JavaScript parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-python","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config\n        .std(\"c11\")\n        .include(src_dir)\n        .flag_if_supported(\"-Wno-unused-value\");\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    let scanner_path = src_dir.join(\"scanner.c\");\n    c_config.file(\u0026scanner_path);\n    println!(\"cargo:rerun-if-changed={}\", scanner_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-python\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-python","bindings","rust","lib.rs"],"content":"//! This crate provides Python language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//!     def double(x):\n//!         return x * 2\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_python::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading Python parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_python() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_python) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading Python parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-ruby","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config\n        .std(\"c11\")\n        .include(src_dir)\n        .flag_if_supported(\"-Wno-unused-value\");\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    let scanner_path = src_dir.join(\"scanner.c\");\n    c_config.file(\u0026scanner_path);\n    println!(\"cargo:rerun-if-changed={}\", scanner_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-ruby\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-ruby","bindings","rust","lib.rs"],"content":"//! This crate provides Ruby language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! def hello(name)\n//!  puts \"Hello, #{name}!\"\n//! end\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_ruby::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading Ruby parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_ruby() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_ruby) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The local-variable syntax highlighting query for this language.\npub const LOCALS_QUERY: \u0026str = include_str!(\"../../queries/locals.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading Ruby parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-rust","bindings","rust","build.rs"],"content":"fn main() {\n    let src_dir = std::path::Path::new(\"src\");\n\n    let mut c_config = cc::Build::new();\n    c_config.std(\"c11\").include(src_dir);\n\n    #[cfg(target_env = \"msvc\")]\n    c_config.flag(\"-utf-8\");\n\n    let parser_path = src_dir.join(\"parser.c\");\n    c_config.file(\u0026parser_path);\n    println!(\"cargo:rerun-if-changed={}\", parser_path.to_str().unwrap());\n\n    let scanner_path = src_dir.join(\"scanner.c\");\n    c_config.file(\u0026scanner_path);\n    println!(\"cargo:rerun-if-changed={}\", scanner_path.to_str().unwrap());\n\n    c_config.compile(\"tree-sitter-rust\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-rust","bindings","rust","lib.rs"],"content":"//! This crate provides Rust language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE][] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! fn double(x: i32) -\u003e i32 {\n//!     x * 2\n//! }\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_rust::LANGUAGE;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading Rust parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_rust() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_rust) };\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: \u0026str = include_str!(\"../../src/node-types.json\");\n\n/// The syntax highlighting query for this language.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The injections query for this language.\npub const INJECTIONS_QUERY: \u0026str = include_str!(\"../../queries/injections.scm\");\n\n/// The symbol tagging query for this language.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE.into())\n            .expect(\"Error loading Rust parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-rust","examples","ast.rs"],"content":"// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 \u003cLICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0\u003e or the MIT license\n// \u003cLICENSE-MIT or http://opensource.org/licenses/MIT\u003e, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n// The Rust abstract syntax tree.\n\npub use self::PathParameters::*;\npub use self::TyParamBound::*;\npub use self::UnsafeSource::*;\npub use symbol::{Ident, Symbol as Name};\npub use util::parser::ExprPrecedence;\npub use util::ThinVec;\n\nuse abi::Abi;\nuse codemap::{respan, Spanned};\nuse ext::hygiene::{Mark, SyntaxContext};\nuse print::pprust;\nuse ptr::P;\nuse rustc_data_structures::indexed_vec;\nuse symbol::{keywords, Symbol};\nuse syntax_pos::{Span, DUMMY_SP};\nuse tokenstream::{ThinTokenStream, TokenStream};\n\nuse serialize::{self, Decoder, Encoder};\nuse std::collections::HashSet;\nuse std::fmt;\nuse std::rc::Rc;\nuse std::u32;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\npub struct Lifetime {\n    pub id: NodeId,\n    pub span: Span,\n    pub ident: Ident,\n}\n\nimpl fmt::Debug for Lifetime {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(\n            f,\n            \"lifetime({}: {})\",\n            self.id,\n            pprust::lifetime_to_string(self)\n        )\n    }\n}\n\n/// A lifetime definition, e.g. `'a: 'b+'c+'d`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct LifetimeDef {\n    pub attrs: ThinVec\u003cAttribute\u003e,\n    pub lifetime: Lifetime,\n    pub bounds: Vec\u003cLifetime\u003e,\n}\n\n/// A \"Path\" is essentially Rust's notion of a name.\n///\n/// It's represented as a sequence of identifiers,\n/// along with a bunch of supporting information.\n///\n/// E.g. `std::cmp::PartialEq`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub struct Path {\n    pub span: Span,\n    /// The segments in the path: the things separated by `::`.\n    /// Global paths begin with `keywords::CrateRoot`.\n    pub segments: Vec\u003cPathSegment\u003e,\n}\n\nimpl\u003c'a\u003e PartialEq\u003c\u0026'a str\u003e for Path {\n    fn eq(\u0026self, string: \u0026\u0026'a str) -\u003e bool {\n        self.segments.len() == 1 \u0026\u0026 self.segments[0].identifier.name == *string\n    }\n}\n\nimpl fmt::Debug for Path {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"path({})\", pprust::path_to_string(self))\n    }\n}\n\nimpl fmt::Display for Path {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", pprust::path_to_string(self))\n    }\n}\n\nimpl Path {\n    // convert a span and an identifier to the corresponding\n    // 1-segment path\n    pub fn from_ident(s: Span, identifier: Ident) -\u003e Path {\n        Path {\n            span: s,\n            segments: vec![PathSegment::from_ident(identifier, s)],\n        }\n    }\n\n    // Add starting \"crate root\" segment to all paths except those that\n    // already have it or start with `self`, `super`, `Self` or `$crate`.\n    pub fn default_to_global(mut self) -\u003e Path {\n        if !self.is_global() {\n            let ident = self.segments[0].identifier;\n            if !::parse::token::Ident(ident).is_path_segment_keyword()\n                || ident.name == keywords::Crate.name()\n            {\n                self.segments.insert(0, PathSegment::crate_root(self.span));\n            }\n        }\n        self\n    }\n\n    pub fn is_global(\u0026self) -\u003e bool {\n        !self.segments.is_empty() \u0026\u0026 self.segments[0].identifier.name == keywords::CrateRoot.name()\n    }\n}\n\n/// A segment of a path: an identifier, an optional lifetime, and a set of types.\n///\n/// E.g. `std`, `String` or `Box\u003cT\u003e`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct PathSegment {\n    /// The identifier portion of this path segment.\n    pub identifier: Ident,\n    /// Span of the segment identifier.\n    pub span: Span,\n\n    /// Type/lifetime parameters attached to this path. They come in\n    /// two flavors: `Path\u003cA,B,C\u003e` and `Path(A,B) -\u003e C`.\n    /// `None` means that no parameter list is supplied (`Path`),\n    /// `Some` means that parameter list is supplied (`Path\u003cX, Y\u003e`)\n    /// but it can be empty (`Path\u003c\u003e`).\n    /// `P` is used as a size optimization for the common case with no parameters.\n    pub parameters: Option\u003cP\u003cPathParameters\u003e\u003e,\n}\n\nimpl PathSegment {\n    pub fn from_ident(ident: Ident, span: Span) -\u003e Self {\n        PathSegment {\n            identifier: ident,\n            span: span,\n            parameters: None,\n        }\n    }\n    pub fn crate_root(span: Span) -\u003e Self {\n        PathSegment {\n            identifier: Ident {\n                ctxt: span.ctxt(),\n                ..keywords::CrateRoot.ident()\n            },\n            span,\n            parameters: None,\n        }\n    }\n}\n\n/// Parameters of a path segment.\n///\n/// E.g. `\u003cA, B\u003e` as in `Foo\u003cA, B\u003e` or `(A, B)` as in `Foo(A, B)`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum PathParameters {\n    /// The `\u003c'a, A,B,C\u003e` in `foo::bar::baz::\u003c'a, A,B,C\u003e`\n    AngleBracketed(AngleBracketedParameterData),\n    /// The `(A,B)` and `C` in `Foo(A,B) -\u003e C`\n    Parenthesized(ParenthesizedParameterData),\n}\n\nimpl PathParameters {\n    pub fn span(\u0026self) -\u003e Span {\n        match *self {\n            AngleBracketed(ref data) =\u003e data.span,\n            Parenthesized(ref data) =\u003e data.span,\n        }\n    }\n}\n\n/// A path like `Foo\u003c'a, T\u003e`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Default)]\npub struct AngleBracketedParameterData {\n    /// Overall span\n    pub span: Span,\n    /// The lifetime parameters for this path segment.\n    pub lifetimes: Vec\u003cLifetime\u003e,\n    /// The type parameters for this path segment, if present.\n    pub types: Vec\u003cP\u003cTy\u003e\u003e,\n    /// Bindings (equality constraints) on associated types, if present.\n    ///\n    /// E.g., `Foo\u003cA=Bar\u003e`.\n    pub bindings: Vec\u003cTypeBinding\u003e,\n}\n\nimpl Into\u003cOption\u003cP\u003cPathParameters\u003e\u003e\u003e for AngleBracketedParameterData {\n    fn into(self) -\u003e Option\u003cP\u003cPathParameters\u003e\u003e {\n        Some(P(PathParameters::AngleBracketed(self)))\n    }\n}\n\nimpl Into\u003cOption\u003cP\u003cPathParameters\u003e\u003e\u003e for ParenthesizedParameterData {\n    fn into(self) -\u003e Option\u003cP\u003cPathParameters\u003e\u003e {\n        Some(P(PathParameters::Parenthesized(self)))\n    }\n}\n\n/// A path like `Foo(A,B) -\u003e C`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct ParenthesizedParameterData {\n    /// Overall span\n    pub span: Span,\n\n    /// `(A,B)`\n    pub inputs: Vec\u003cP\u003cTy\u003e\u003e,\n\n    /// `C`\n    pub output: Option\u003cP\u003cTy\u003e\u003e,\n}\n\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Debug)]\npub struct NodeId(u32);\n\nimpl NodeId {\n    pub fn new(x: usize) -\u003e NodeId {\n        assert!(x \u003c (u32::MAX as usize));\n        NodeId(x as u32)\n    }\n\n    pub fn from_u32(x: u32) -\u003e NodeId {\n        NodeId(x)\n    }\n\n    pub fn as_usize(\u0026self) -\u003e usize {\n        self.0 as usize\n    }\n\n    pub fn as_u32(\u0026self) -\u003e u32 {\n        self.0\n    }\n\n    pub fn placeholder_from_mark(mark: Mark) -\u003e Self {\n        NodeId(mark.as_u32())\n    }\n\n    pub fn placeholder_to_mark(self) -\u003e Mark {\n        Mark::from_u32(self.0)\n    }\n}\n\nimpl fmt::Display for NodeId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(\u0026self.0, f)\n    }\n}\n\nimpl serialize::UseSpecializedEncodable for NodeId {\n    fn default_encode\u003cS: Encoder\u003e(\u0026self, s: \u0026mut S) -\u003e Result\u003c(), S::Error\u003e {\n        s.emit_u32(self.0)\n    }\n}\n\nimpl serialize::UseSpecializedDecodable for NodeId {\n    fn default_decode\u003cD: Decoder\u003e(d: \u0026mut D) -\u003e Result\u003cNodeId, D::Error\u003e {\n        d.read_u32().map(NodeId)\n    }\n}\n\nimpl indexed_vec::Idx for NodeId {\n    fn new(idx: usize) -\u003e Self {\n        NodeId::new(idx)\n    }\n\n    fn index(self) -\u003e usize {\n        self.as_usize()\n    }\n}\n\n/// Node id used to represent the root of the crate.\npub const CRATE_NODE_ID: NodeId = NodeId(0);\n\n/// When parsing and doing expansions, we initially give all AST nodes this AST\n/// node value. Then later, in the renumber pass, we renumber them to have\n/// small, positive ids.\npub const DUMMY_NODE_ID: NodeId = NodeId(!0);\n\n/// The AST represents all type param bounds as types.\n/// typeck::collect::compute_bounds matches these against\n/// the \"special\" built-in traits (see middle::lang_items) and\n/// detects Copy, Send and Sync.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum TyParamBound {\n    TraitTyParamBound(PolyTraitRef, TraitBoundModifier),\n    RegionTyParamBound(Lifetime),\n}\n\n/// A modifier on a bound, currently this is only used for `?Sized`, where the\n/// modifier is `Maybe`. Negative bounds should also be handled here.\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum TraitBoundModifier {\n    None,\n    Maybe,\n}\n\npub type TyParamBounds = Vec\u003cTyParamBound\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct TyParam {\n    pub attrs: ThinVec\u003cAttribute\u003e,\n    pub ident: Ident,\n    pub id: NodeId,\n    pub bounds: TyParamBounds,\n    pub default: Option\u003cP\u003cTy\u003e\u003e,\n    pub span: Span,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum GenericParam {\n    Lifetime(LifetimeDef),\n    Type(TyParam),\n}\n\nimpl GenericParam {\n    pub fn is_lifetime_param(\u0026self) -\u003e bool {\n        match *self {\n            GenericParam::Lifetime(_) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn is_type_param(\u0026self) -\u003e bool {\n        match *self {\n            GenericParam::Type(_) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n/// Represents lifetime, type and const parameters attached to a declaration of\n/// a function, enum, trait, etc.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Generics {\n    pub params: Vec\u003cGenericParam\u003e,\n    pub where_clause: WhereClause,\n    pub span: Span,\n}\n\nimpl Generics {\n    pub fn is_lt_parameterized(\u0026self) -\u003e bool {\n        self.params.iter().any(|param| param.is_lifetime_param())\n    }\n\n    pub fn is_type_parameterized(\u0026self) -\u003e bool {\n        self.params.iter().any(|param| param.is_type_param())\n    }\n\n    pub fn is_parameterized(\u0026self) -\u003e bool {\n        !self.params.is_empty()\n    }\n\n    pub fn span_for_name(\u0026self, name: \u0026str) -\u003e Option\u003cSpan\u003e {\n        for param in \u0026self.params {\n            if let GenericParam::Type(ref t) = *param {\n                if t.ident.name == name {\n                    return Some(t.span);\n                }\n            }\n        }\n        None\n    }\n}\n\nimpl Default for Generics {\n    /// Creates an instance of `Generics`.\n    fn default() -\u003e Generics {\n        Generics {\n            params: Vec::new(),\n            where_clause: WhereClause {\n                id: DUMMY_NODE_ID,\n                predicates: Vec::new(),\n                span: DUMMY_SP,\n            },\n            span: DUMMY_SP,\n        }\n    }\n}\n\n/// A `where` clause in a definition\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct WhereClause {\n    pub id: NodeId,\n    pub predicates: Vec\u003cWherePredicate\u003e,\n    pub span: Span,\n}\n\n/// A single predicate in a `where` clause\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum WherePredicate {\n    /// A type binding, e.g. `for\u003c'c\u003e Foo: Send+Clone+'c`\n    BoundPredicate(WhereBoundPredicate),\n    /// A lifetime predicate, e.g. `'a: 'b+'c`\n    RegionPredicate(WhereRegionPredicate),\n    /// An equality predicate (unsupported)\n    EqPredicate(WhereEqPredicate),\n}\n\n/// A type bound.\n///\n/// E.g. `for\u003c'c\u003e Foo: Send+Clone+'c`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct WhereBoundPredicate {\n    pub span: Span,\n    /// Any generics from a `for` binding\n    pub bound_generic_params: Vec\u003cGenericParam\u003e,\n    /// The type being bounded\n    pub bounded_ty: P\u003cTy\u003e,\n    /// Trait and lifetime bounds (`Clone+Send+'static`)\n    pub bounds: TyParamBounds,\n}\n\n/// A lifetime predicate.\n///\n/// E.g. `'a: 'b+'c`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct WhereRegionPredicate {\n    pub span: Span,\n    pub lifetime: Lifetime,\n    pub bounds: Vec\u003cLifetime\u003e,\n}\n\n/// An equality predicate (unsupported).\n///\n/// E.g. `T=int`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct WhereEqPredicate {\n    pub id: NodeId,\n    pub span: Span,\n    pub lhs_ty: P\u003cTy\u003e,\n    pub rhs_ty: P\u003cTy\u003e,\n}\n\n/// The set of MetaItems that define the compilation environment of the crate,\n/// used to drive conditional compilation\npub type CrateConfig = HashSet\u003c(Name, Option\u003cSymbol\u003e)\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Crate {\n    pub module: Mod,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub span: Span,\n}\n\n/// A spanned compile-time attribute list item.\npub type NestedMetaItem = Spanned\u003cNestedMetaItemKind\u003e;\n\n/// Possible values inside of compile-time attribute lists.\n///\n/// E.g. the '..' in `#[name(..)]`.\n#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialEq)]\npub enum NestedMetaItemKind {\n    /// A full MetaItem, for recursive meta items.\n    MetaItem(MetaItem),\n    /// A literal.\n    ///\n    /// E.g. \"foo\", 64, true\n    Literal(Lit),\n}\n\n/// A spanned compile-time attribute item.\n///\n/// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct MetaItem {\n    pub name: Name,\n    pub node: MetaItemKind,\n    pub span: Span,\n}\n\n/// A compile-time attribute item.\n///\n/// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum MetaItemKind {\n    /// Word meta item.\n    ///\n    /// E.g. `test` as in `#[test]`\n    Word,\n    /// List meta item.\n    ///\n    /// E.g. `derive(..)` as in `#[derive(..)]`\n    List(Vec\u003cNestedMetaItem\u003e),\n    /// Name value meta item.\n    ///\n    /// E.g. `feature = \"foo\"` as in `#[feature = \"foo\"]`\n    NameValue(Lit),\n}\n\n/// A Block (`{ .. }`).\n///\n/// E.g. `{ .. }` as in `fn foo() { .. }`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Block {\n    /// Statements in a block\n    pub stmts: Vec\u003cStmt\u003e,\n    pub id: NodeId,\n    /// Distinguishes between `unsafe { ... }` and `{ ... }`\n    pub rules: BlockCheckMode,\n    pub span: Span,\n    pub recovered: bool,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub struct Pat {\n    pub id: NodeId,\n    pub node: PatKind,\n    pub span: Span,\n}\n\nimpl fmt::Debug for Pat {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"pat({}: {})\", self.id, pprust::pat_to_string(self))\n    }\n}\n\nimpl Pat {\n    pub(super) fn to_ty(\u0026self) -\u003e Option\u003cP\u003cTy\u003e\u003e {\n        let node = match \u0026self.node {\n            PatKind::Wild =\u003e TyKind::Infer,\n            PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None) =\u003e {\n                TyKind::Path(None, Path::from_ident(ident.span, ident.node))\n            }\n            PatKind::Path(qself, path) =\u003e TyKind::Path(qself.clone(), path.clone()),\n            PatKind::Mac(mac) =\u003e TyKind::Mac(mac.clone()),\n            PatKind::Ref(pat, mutbl) =\u003e pat\n                .to_ty()\n                .map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n            PatKind::Slice(pats, None, _) if pats.len() == 1 =\u003e {\n                pats[0].to_ty().map(TyKind::Slice)?\n            }\n            PatKind::Tuple(pats, None) =\u003e {\n                let mut tys = Vec::new();\n                for pat in pats {\n                    tys.push(pat.to_ty()?);\n                }\n                TyKind::Tup(tys)\n            }\n            _ =\u003e return None,\n        };\n\n        Some(P(Ty {\n            node,\n            id: self.id,\n            span: self.span,\n        }))\n    }\n\n    pub fn walk\u003cF\u003e(\u0026self, it: \u0026mut F) -\u003e bool\n    where\n        F: FnMut(\u0026Pat) -\u003e bool,\n    {\n        if !it(self) {\n            return false;\n        }\n\n        match self.node {\n            PatKind::Ident(_, _, Some(ref p)) =\u003e p.walk(it),\n            PatKind::Struct(_, ref fields, _) =\u003e fields.iter().all(|field| field.node.pat.walk(it)),\n            PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) =\u003e {\n                s.iter().all(|p| p.walk(it))\n            }\n            PatKind::Box(ref s) | PatKind::Ref(ref s, _) =\u003e s.walk(it),\n            PatKind::Slice(ref before, ref slice, ref after) =\u003e {\n                before.iter().all(|p| p.walk(it))\n                    \u0026\u0026 slice.iter().all(|p| p.walk(it))\n                    \u0026\u0026 after.iter().all(|p| p.walk(it))\n            }\n            PatKind::Wild\n            | PatKind::Lit(_)\n            | PatKind::Range(..)\n            | PatKind::Ident(..)\n            | PatKind::Path(..)\n            | PatKind::Mac(_) =\u003e true,\n        }\n    }\n}\n\n/// A single field in a struct pattern\n///\n/// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n/// are treated the same as` x: x, y: ref y, z: ref mut z`,\n/// except is_shorthand is true\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct FieldPat {\n    /// The identifier for the field\n    pub ident: Ident,\n    /// The pattern the field is destructured to\n    pub pat: P\u003cPat\u003e,\n    pub is_shorthand: bool,\n    pub attrs: ThinVec\u003cAttribute\u003e,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum BindingMode {\n    ByRef(Mutability),\n    ByValue(Mutability),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum RangeEnd {\n    Included(RangeSyntax),\n    Excluded,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum RangeSyntax {\n    DotDotDot,\n    DotDotEq,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum PatKind {\n    /// Represents a wildcard pattern (`_`)\n    Wild,\n\n    /// A `PatKind::Ident` may either be a new bound variable (`ref mut binding @ OPT_SUBPATTERN`),\n    /// or a unit struct/variant pattern, or a const pattern (in the last two cases the third\n    /// field must be `None`). Disambiguation cannot be done with parser alone, so it happens\n    /// during name resolution.\n    Ident(BindingMode, SpannedIdent, Option\u003cP\u003cPat\u003e\u003e),\n\n    /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n    /// The `bool` is `true` in the presence of a `..`.\n    Struct(Path, Vec\u003cSpanned\u003cFieldPat\u003e\u003e, bool),\n\n    /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n    /// If the `..` pattern fragment is present, then `Option\u003cusize\u003e` denotes its position.\n    /// 0 \u003c= position \u003c= subpats.len()\n    TupleStruct(Path, Vec\u003cP\u003cPat\u003e\u003e, Option\u003cusize\u003e),\n\n    /// A possibly qualified path pattern.\n    /// Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants\n    /// or associated constants. Qualified path patterns `\u003cA\u003e::B::C`/`\u003cA as Trait\u003e::B::C` can\n    /// only legally refer to associated constants.\n    Path(Option\u003cQSelf\u003e, Path),\n\n    /// A tuple pattern `(a, b)`.\n    /// If the `..` pattern fragment is present, then `Option\u003cusize\u003e` denotes its position.\n    /// 0 \u003c= position \u003c= subpats.len()\n    Tuple(Vec\u003cP\u003cPat\u003e\u003e, Option\u003cusize\u003e),\n    /// A `box` pattern\n    Box(P\u003cPat\u003e),\n    /// A reference pattern, e.g. `\u0026mut (a, b)`\n    Ref(P\u003cPat\u003e, Mutability),\n    /// A literal\n    Lit(P\u003cExpr\u003e),\n    /// A range pattern, e.g. `1...2`, `1..=2` or `1..2`\n    Range(P\u003cExpr\u003e, P\u003cExpr\u003e, RangeEnd),\n    /// `[a, b, ..i, y, z]` is represented as:\n    ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n    Slice(Vec\u003cP\u003cPat\u003e\u003e, Option\u003cP\u003cPat\u003e\u003e, Vec\u003cP\u003cPat\u003e\u003e),\n    /// A macro pattern; pre-expansion\n    Mac(Mac),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum Mutability {\n    Mutable,\n    Immutable,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum BinOpKind {\n    /// The `+` operator (addition)\n    Add,\n    /// The `-` operator (subtraction)\n    Sub,\n    /// The `*` operator (multiplication)\n    Mul,\n    /// The `/` operator (division)\n    Div,\n    /// The `%` operator (modulus)\n    Rem,\n    /// The `\u0026\u0026` operator (logical and)\n    And,\n    /// The `||` operator (logical or)\n    Or,\n    /// The `^` operator (bitwise xor)\n    BitXor,\n    /// The `\u0026` operator (bitwise and)\n    BitAnd,\n    /// The `|` operator (bitwise or)\n    BitOr,\n    /// The `\u003c\u003c` operator (shift left)\n    Shl,\n    /// The `\u003e\u003e` operator (shift right)\n    Shr,\n    /// The `==` operator (equality)\n    Eq,\n    /// The `\u003c` operator (less than)\n    Lt,\n    /// The `\u003c=` operator (less than or equal to)\n    Le,\n    /// The `!=` operator (not equal to)\n    Ne,\n    /// The `\u003e=` operator (greater than or equal to)\n    Ge,\n    /// The `\u003e` operator (greater than)\n    Gt,\n}\n\nimpl BinOpKind {\n    pub fn to_string(\u0026self) -\u003e \u0026'static str {\n        use self::BinOpKind::*;\n        match *self {\n            Add =\u003e \"+\",\n            Sub =\u003e \"-\",\n            Mul =\u003e \"*\",\n            Div =\u003e \"/\",\n            Rem =\u003e \"%\",\n            And =\u003e \"\u0026\u0026\",\n            Or =\u003e \"||\",\n            BitXor =\u003e \"^\",\n            BitAnd =\u003e \"\u0026\",\n            BitOr =\u003e \"|\",\n            Shl =\u003e \"\u003c\u003c\",\n            Shr =\u003e \"\u003e\u003e\",\n            Eq =\u003e \"==\",\n            Lt =\u003e \"\u003c\",\n            Le =\u003e \"\u003c=\",\n            Ne =\u003e \"!=\",\n            Ge =\u003e \"\u003e=\",\n            Gt =\u003e \"\u003e\",\n        }\n    }\n    pub fn lazy(\u0026self) -\u003e bool {\n        match *self {\n            BinOpKind::And | BinOpKind::Or =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn is_shift(\u0026self) -\u003e bool {\n        match *self {\n            BinOpKind::Shl | BinOpKind::Shr =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn is_comparison(\u0026self) -\u003e bool {\n        use self::BinOpKind::*;\n        match *self {\n            Eq | Lt | Le | Ne | Gt | Ge =\u003e true,\n            And | Or | Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr =\u003e false,\n        }\n    }\n\n    /// Returns `true` if the binary operator takes its arguments by value\n    pub fn is_by_value(\u0026self) -\u003e bool {\n        !self.is_comparison()\n    }\n}\n\npub type BinOp = Spanned\u003cBinOpKind\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum UnOp {\n    /// The `*` operator for dereferencing\n    Deref,\n    /// The `!` operator for logical inversion\n    Not,\n    /// The `-` operator for negation\n    Neg,\n}\n\nimpl UnOp {\n    /// Returns `true` if the unary operator takes its argument by value\n    pub fn is_by_value(u: UnOp) -\u003e bool {\n        match u {\n            UnOp::Neg | UnOp::Not =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn to_string(op: UnOp) -\u003e \u0026'static str {\n        match op {\n            UnOp::Deref =\u003e \"*\",\n            UnOp::Not =\u003e \"!\",\n            UnOp::Neg =\u003e \"-\",\n        }\n    }\n}\n\n/// A statement\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub struct Stmt {\n    pub id: NodeId,\n    pub node: StmtKind,\n    pub span: Span,\n}\n\nimpl Stmt {\n    pub fn add_trailing_semicolon(mut self) -\u003e Self {\n        self.node = match self.node {\n            StmtKind::Expr(expr) =\u003e StmtKind::Semi(expr),\n            StmtKind::Mac(mac) =\u003e {\n                StmtKind::Mac(mac.map(|(mac, _style, attrs)| (mac, MacStmtStyle::Semicolon, attrs)))\n            }\n            node =\u003e node,\n        };\n        self\n    }\n\n    pub fn is_item(\u0026self) -\u003e bool {\n        match self.node {\n            StmtKind::Local(_) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl fmt::Debug for Stmt {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(\n            f,\n            \"stmt({}: {})\",\n            self.id.to_string(),\n            pprust::stmt_to_string(self)\n        )\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub enum StmtKind {\n    /// A local (let) binding.\n    Local(P\u003cLocal\u003e),\n\n    /// An item definition.\n    Item(P\u003cItem\u003e),\n\n    /// Expr without trailing semi-colon.\n    Expr(P\u003cExpr\u003e),\n    /// Expr with a trailing semi-colon.\n    Semi(P\u003cExpr\u003e),\n    /// Macro.\n    Mac(P\u003c(Mac, MacStmtStyle, ThinVec\u003cAttribute\u003e)\u003e),\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum MacStmtStyle {\n    /// The macro statement had a trailing semicolon, e.g. `foo! { ... };`\n    /// `foo!(...);`, `foo![...];`\n    Semicolon,\n    /// The macro statement had braces; e.g. foo! { ... }\n    Braces,\n    /// The macro statement had parentheses or brackets and no semicolon; e.g.\n    /// `foo!(...)`. All of these will end up being converted into macro\n    /// expressions.\n    NoBraces,\n}\n\n/// Local represents a `let` statement, e.g., `let \u003cpat\u003e:\u003cty\u003e = \u003cexpr\u003e;`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Local {\n    pub pat: P\u003cPat\u003e,\n    pub ty: Option\u003cP\u003cTy\u003e\u003e,\n    /// Initializer expression to set the value, if any\n    pub init: Option\u003cP\u003cExpr\u003e\u003e,\n    pub id: NodeId,\n    pub span: Span,\n    pub attrs: ThinVec\u003cAttribute\u003e,\n}\n\n/// An arm of a 'match'.\n///\n/// E.g. `0...10 =\u003e { println!(\"match!\") }` as in\n///\n/// ```\n/// match 123 {\n///     0...10 =\u003e { println!(\"match!\") },\n///     _ =\u003e { println!(\"no match!\") },\n/// }\n/// ```\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Arm {\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub pats: Vec\u003cP\u003cPat\u003e\u003e,\n    pub guard: Option\u003cP\u003cExpr\u003e\u003e,\n    pub body: P\u003cExpr\u003e,\n    pub beginning_vert: Option\u003cSpan\u003e, // For RFC 1925 feature gate\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Field {\n    pub ident: SpannedIdent,\n    pub expr: P\u003cExpr\u003e,\n    pub span: Span,\n    pub is_shorthand: bool,\n    pub attrs: ThinVec\u003cAttribute\u003e,\n}\n\npub type SpannedIdent = Spanned\u003cIdent\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum BlockCheckMode {\n    Default,\n    Unsafe(UnsafeSource),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum UnsafeSource {\n    CompilerGenerated,\n    UserProvided,\n}\n\n/// An expression\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub struct Expr {\n    pub id: NodeId,\n    pub node: ExprKind,\n    pub span: Span,\n    pub attrs: ThinVec\u003cAttribute\u003e,\n}\n\nimpl Expr {\n    /// Wether this expression would be valid somewhere that expects a value, for example, an `if`\n    /// condition.\n    pub fn returns(\u0026self) -\u003e bool {\n        if let ExprKind::Block(ref block) = self.node {\n            match block.stmts.last().map(|last_stmt| \u0026last_stmt.node) {\n                // implicit return\n                Some(\u0026StmtKind::Expr(_)) =\u003e true,\n                Some(\u0026StmtKind::Semi(ref expr)) =\u003e {\n                    if let ExprKind::Ret(_) = expr.node {\n                        // last statement is explicit return\n                        true\n                    } else {\n                        false\n                    }\n                }\n                // This is a block that doesn't end in either an implicit or explicit return\n                _ =\u003e false,\n            }\n        } else {\n            // This is not a block, it is a value\n            true\n        }\n    }\n\n    fn to_bound(\u0026self) -\u003e Option\u003cTyParamBound\u003e {\n        match \u0026self.node {\n            ExprKind::Path(None, path) =\u003e Some(TraitTyParamBound(\n                PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n                TraitBoundModifier::None,\n            )),\n            _ =\u003e None,\n        }\n    }\n\n    pub(super) fn to_ty(\u0026self) -\u003e Option\u003cP\u003cTy\u003e\u003e {\n        let node = match \u0026self.node {\n            ExprKind::Path(qself, path) =\u003e TyKind::Path(qself.clone(), path.clone()),\n            ExprKind::Mac(mac) =\u003e TyKind::Mac(mac.clone()),\n            ExprKind::Paren(expr) =\u003e expr.to_ty().map(TyKind::Paren)?,\n            ExprKind::AddrOf(mutbl, expr) =\u003e expr\n                .to_ty()\n                .map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n            ExprKind::Repeat(expr, expr_len) =\u003e {\n                expr.to_ty().map(|ty| TyKind::Array(ty, expr_len.clone()))?\n            }\n            ExprKind::Array(exprs) if exprs.len() == 1 =\u003e exprs[0].to_ty().map(TyKind::Slice)?,\n            ExprKind::Tup(exprs) =\u003e {\n                let mut tys = Vec::new();\n                for expr in exprs {\n                    tys.push(expr.to_ty()?);\n                }\n                TyKind::Tup(tys)\n            }\n            ExprKind::Binary(binop, lhs, rhs) if binop.node == BinOpKind::Add =\u003e {\n                if let (Some(lhs), Some(rhs)) = (lhs.to_bound(), rhs.to_bound()) {\n                    TyKind::TraitObject(vec![lhs, rhs], TraitObjectSyntax::None)\n                } else {\n                    return None;\n                }\n            }\n            _ =\u003e return None,\n        };\n\n        Some(P(Ty {\n            node,\n            id: self.id,\n            span: self.span,\n        }))\n    }\n\n    pub fn precedence(\u0026self) -\u003e ExprPrecedence {\n        match self.node {\n            ExprKind::Box(_) =\u003e ExprPrecedence::Box,\n            ExprKind::InPlace(..) =\u003e ExprPrecedence::InPlace,\n            ExprKind::Array(_) =\u003e ExprPrecedence::Array,\n            ExprKind::Call(..) =\u003e ExprPrecedence::Call,\n            ExprKind::MethodCall(..) =\u003e ExprPrecedence::MethodCall,\n            ExprKind::Tup(_) =\u003e ExprPrecedence::Tup,\n            ExprKind::Binary(op, ..) =\u003e ExprPrecedence::Binary(op.node),\n            ExprKind::Unary(..) =\u003e ExprPrecedence::Unary,\n            ExprKind::Lit(_) =\u003e ExprPrecedence::Lit,\n            ExprKind::Type(..) | ExprKind::Cast(..) =\u003e ExprPrecedence::Cast,\n            ExprKind::If(..) =\u003e ExprPrecedence::If,\n            ExprKind::IfLet(..) =\u003e ExprPrecedence::IfLet,\n            ExprKind::While(..) =\u003e ExprPrecedence::While,\n            ExprKind::WhileLet(..) =\u003e ExprPrecedence::WhileLet,\n            ExprKind::ForLoop(..) =\u003e ExprPrecedence::ForLoop,\n            ExprKind::Loop(..) =\u003e ExprPrecedence::Loop,\n            ExprKind::Match(..) =\u003e ExprPrecedence::Match,\n            ExprKind::Closure(..) =\u003e ExprPrecedence::Closure,\n            ExprKind::Block(..) =\u003e ExprPrecedence::Block,\n            ExprKind::Catch(..) =\u003e ExprPrecedence::Catch,\n            ExprKind::Assign(..) =\u003e ExprPrecedence::Assign,\n            ExprKind::AssignOp(..) =\u003e ExprPrecedence::AssignOp,\n            ExprKind::Field(..) =\u003e ExprPrecedence::Field,\n            ExprKind::TupField(..) =\u003e ExprPrecedence::TupField,\n            ExprKind::Index(..) =\u003e ExprPrecedence::Index,\n            ExprKind::Range(..) =\u003e ExprPrecedence::Range,\n            ExprKind::Path(..) =\u003e ExprPrecedence::Path,\n            ExprKind::AddrOf(..) =\u003e ExprPrecedence::AddrOf,\n            ExprKind::Break(..) =\u003e ExprPrecedence::Break,\n            ExprKind::Continue(..) =\u003e ExprPrecedence::Continue,\n            ExprKind::Ret(..) =\u003e ExprPrecedence::Ret,\n            ExprKind::InlineAsm(..) =\u003e ExprPrecedence::InlineAsm,\n            ExprKind::Mac(..) =\u003e ExprPrecedence::Mac,\n            ExprKind::Struct(..) =\u003e ExprPrecedence::Struct,\n            ExprKind::Repeat(..) =\u003e ExprPrecedence::Repeat,\n            ExprKind::Paren(..) =\u003e ExprPrecedence::Paren,\n            ExprKind::Try(..) =\u003e ExprPrecedence::Try,\n            ExprKind::Yield(..) =\u003e ExprPrecedence::Yield,\n        }\n    }\n}\n\nimpl fmt::Debug for Expr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"expr({}: {})\", self.id, pprust::expr_to_string(self))\n    }\n}\n\n/// Limit types of a range (inclusive or exclusive)\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum RangeLimits {\n    /// Inclusive at the beginning, exclusive at the end\n    HalfOpen,\n    /// Inclusive at the beginning and end\n    Closed,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum ExprKind {\n    /// A `box x` expression.\n    Box(P\u003cExpr\u003e),\n    /// First expr is the place; second expr is the value.\n    InPlace(P\u003cExpr\u003e, P\u003cExpr\u003e),\n    /// An array (`[a, b, c, d]`)\n    Array(Vec\u003cP\u003cExpr\u003e\u003e),\n    /// A function call\n    ///\n    /// The first field resolves to the function itself,\n    /// and the second field is the list of arguments.\n    /// This also represents calling the constructor of\n    /// tuple-like ADTs such as tuple structs and enum variants.\n    Call(P\u003cExpr\u003e, Vec\u003cP\u003cExpr\u003e\u003e),\n    /// A method call (`x.foo::\u003c'static, Bar, Baz\u003e(a, b, c, d)`)\n    ///\n    /// The `PathSegment` represents the method name and its generic arguments\n    /// (within the angle brackets).\n    /// The first element of the vector of `Expr`s is the expression that evaluates\n    /// to the object on which the method is being called on (the receiver),\n    /// and the remaining elements are the rest of the arguments.\n    /// Thus, `x.foo::\u003cBar, Baz\u003e(a, b, c, d)` is represented as\n    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n    MethodCall(PathSegment, Vec\u003cP\u003cExpr\u003e\u003e),\n    /// A tuple (`(a, b, c ,d)`)\n    Tup(Vec\u003cP\u003cExpr\u003e\u003e),\n    /// A binary operation (For example: `a + b`, `a * b`)\n    Binary(BinOp, P\u003cExpr\u003e, P\u003cExpr\u003e),\n    /// A unary operation (For example: `!x`, `*x`)\n    Unary(UnOp, P\u003cExpr\u003e),\n    /// A literal (For example: `1`, `\"foo\"`)\n    Lit(P\u003cLit\u003e),\n    /// A cast (`foo as f64`)\n    Cast(P\u003cExpr\u003e, P\u003cTy\u003e),\n    Type(P\u003cExpr\u003e, P\u003cTy\u003e),\n    /// An `if` block, with an optional else block\n    ///\n    /// `if expr { block } else { expr }`\n    If(P\u003cExpr\u003e, P\u003cBlock\u003e, Option\u003cP\u003cExpr\u003e\u003e),\n    /// An `if let` expression with an optional else block\n    ///\n    /// `if let pat = expr { block } else { expr }`\n    ///\n    /// This is desugared to a `match` expression.\n    IfLet(P\u003cPat\u003e, P\u003cExpr\u003e, P\u003cBlock\u003e, Option\u003cP\u003cExpr\u003e\u003e),\n    /// A while loop, with an optional label\n    ///\n    /// `'label: while expr { block }`\n    While(P\u003cExpr\u003e, P\u003cBlock\u003e, Option\u003cSpannedIdent\u003e),\n    /// A while-let loop, with an optional label\n    ///\n    /// `'label: while let pat = expr { block }`\n    ///\n    /// This is desugared to a combination of `loop` and `match` expressions.\n    WhileLet(P\u003cPat\u003e, P\u003cExpr\u003e, P\u003cBlock\u003e, Option\u003cSpannedIdent\u003e),\n    /// A for loop, with an optional label\n    ///\n    /// `'label: for pat in expr { block }`\n    ///\n    /// This is desugared to a combination of `loop` and `match` expressions.\n    ForLoop(P\u003cPat\u003e, P\u003cExpr\u003e, P\u003cBlock\u003e, Option\u003cSpannedIdent\u003e),\n    /// Conditionless loop (can be exited with break, continue, or return)\n    ///\n    /// `'label: loop { block }`\n    Loop(P\u003cBlock\u003e, Option\u003cSpannedIdent\u003e),\n    /// A `match` block.\n    Match(P\u003cExpr\u003e, Vec\u003cArm\u003e),\n    /// A closure (for example, `move |a, b, c| a + b + c`)\n    ///\n    /// The final span is the span of the argument block `|...|`\n    Closure(CaptureBy, P\u003cFnDecl\u003e, P\u003cExpr\u003e, Span),\n    /// A block (`{ ... }`)\n    Block(P\u003cBlock\u003e),\n    /// A catch block (`catch { ... }`)\n    Catch(P\u003cBlock\u003e),\n\n    /// An assignment (`a = foo()`)\n    Assign(P\u003cExpr\u003e, P\u003cExpr\u003e),\n    /// An assignment with an operator\n    ///\n    /// For example, `a += 1`.\n    AssignOp(BinOp, P\u003cExpr\u003e, P\u003cExpr\u003e),\n    /// Access of a named struct field (`obj.foo`)\n    Field(P\u003cExpr\u003e, SpannedIdent),\n    /// Access of an unnamed field of a struct or tuple-struct\n    ///\n    /// For example, `foo.0`.\n    TupField(P\u003cExpr\u003e, Spanned\u003cusize\u003e),\n    /// An indexing operation (`foo[2]`)\n    Index(P\u003cExpr\u003e, P\u003cExpr\u003e),\n    /// A range (`1..2`, `1..`, `..2`, `1...2`, `1...`, `...2`)\n    Range(Option\u003cP\u003cExpr\u003e\u003e, Option\u003cP\u003cExpr\u003e\u003e, RangeLimits),\n\n    /// Variable reference, possibly containing `::` and/or type\n    /// parameters, e.g. foo::bar::\u003cbaz\u003e.\n    ///\n    /// Optionally \"qualified\",\n    /// E.g. `\u003cVec\u003cT\u003e as SomeTrait\u003e::SomeType`.\n    Path(Option\u003cQSelf\u003e, Path),\n\n    /// A referencing operation (`\u0026a` or `\u0026mut a`)\n    AddrOf(Mutability, P\u003cExpr\u003e),\n    /// A `break`, with an optional label to break, and an optional expression\n    Break(Option\u003cSpannedIdent\u003e, Option\u003cP\u003cExpr\u003e\u003e),\n    /// A `continue`, with an optional label\n    Continue(Option\u003cSpannedIdent\u003e),\n    /// A `return`, with an optional value to be returned\n    Ret(Option\u003cP\u003cExpr\u003e\u003e),\n\n    /// Output of the `asm!()` macro\n    InlineAsm(P\u003cInlineAsm\u003e),\n\n    /// A macro invocation; pre-expansion\n    Mac(Mac),\n\n    /// A struct literal expression.\n    ///\n    /// For example, `Foo {x: 1, y: 2}`, or\n    /// `Foo {x: 1, .. base}`, where `base` is the `Option\u003cExpr\u003e`.\n    Struct(Path, Vec\u003cField\u003e, Option\u003cP\u003cExpr\u003e\u003e),\n\n    /// An array literal constructed from one repeated element.\n    ///\n    /// For example, `[1; 5]`. The first expression is the element\n    /// to be repeated; the second is the number of times to repeat it.\n    Repeat(P\u003cExpr\u003e, P\u003cExpr\u003e),\n\n    /// No-op: used solely so we can pretty-print faithfully\n    Paren(P\u003cExpr\u003e),\n\n    /// `expr?`\n    Try(P\u003cExpr\u003e),\n\n    /// A `yield`, with an optional value to be yielded\n    Yield(Option\u003cP\u003cExpr\u003e\u003e),\n}\n\n/// The explicit Self type in a \"qualified path\". The actual\n/// path, including the trait and the associated item, is stored\n/// separately. `position` represents the index of the associated\n/// item qualified with this Self type.\n///\n/// ```ignore (only-for-syntax-highlight)\n/// \u003cVec\u003cT\u003e as a::b::Trait\u003e::AssociatedItem\n///  ^~~~~     ~~~~~~~~~~~~~~^\n///  ty        position = 3\n///\n/// \u003cVec\u003cT\u003e\u003e::AssociatedItem\n///  ^~~~~    ^\n///  ty       position = 0\n/// ```\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct QSelf {\n    pub ty: P\u003cTy\u003e,\n    pub position: usize,\n}\n\n/// A capture clause\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum CaptureBy {\n    Value,\n    Ref,\n}\n\npub type Mac = Spanned\u003cMac_\u003e;\n\n/// Represents a macro invocation. The Path indicates which macro\n/// is being invoked, and the vector of token-trees contains the source\n/// of the macro invocation.\n///\n/// NB: the additional ident for a macro_rules-style macro is actually\n/// stored in the enclosing item. Oog.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Mac_ {\n    pub path: Path,\n    pub tts: ThinTokenStream,\n}\n\nimpl Mac_ {\n    pub fn stream(\u0026self) -\u003e TokenStream {\n        self.tts.clone().into()\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct MacroDef {\n    pub tokens: ThinTokenStream,\n    pub legacy: bool,\n}\n\nimpl MacroDef {\n    pub fn stream(\u0026self) -\u003e TokenStream {\n        self.tokens.clone().into()\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum StrStyle {\n    /// A regular string, like `\"foo\"`\n    Cooked,\n    /// A raw string, like `r##\"foo\"##`\n    ///\n    /// The uint is the number of `#` symbols used\n    Raw(usize),\n}\n\n/// A literal\npub type Lit = Spanned\u003cLitKind\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum LitIntType {\n    Signed(IntTy),\n    Unsigned(UintTy),\n    Unsuffixed,\n}\n\n/// Literal kind.\n///\n/// E.g. `\"foo\"`, `42`, `12.34` or `bool`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum LitKind {\n    /// A string literal (`\"foo\"`)\n    Str(Symbol, StrStyle),\n    /// A byte string (`b\"foo\"`)\n    ByteStr(Rc\u003cVec\u003cu8\u003e\u003e),\n    /// A byte char (`b'f'`)\n    Byte(u8),\n    /// A character literal (`'a'`)\n    Char(char),\n    /// An integer literal (`1`)\n    Int(u128, LitIntType),\n    /// A float literal (`1f64` or `1E10f64`)\n    Float(Symbol, FloatTy),\n    /// A float literal without a suffix (`1.0 or 1.0E10`)\n    FloatUnsuffixed(Symbol),\n    /// A boolean literal\n    Bool(bool),\n}\n\nimpl LitKind {\n    /// Returns true if this literal is a string and false otherwise.\n    pub fn is_str(\u0026self) -\u003e bool {\n        match *self {\n            LitKind::Str(..) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    /// Returns true if this literal has no suffix. Note: this will return true\n    /// for literals with prefixes such as raw strings and byte strings.\n    pub fn is_unsuffixed(\u0026self) -\u003e bool {\n        match *self {\n            // unsuffixed variants\n            LitKind::Str(..)\n            | LitKind::ByteStr(..)\n            | LitKind::Byte(..)\n            | LitKind::Char(..)\n            | LitKind::Int(_, LitIntType::Unsuffixed)\n            | LitKind::FloatUnsuffixed(..)\n            | LitKind::Bool(..) =\u003e true,\n            // suffixed variants\n            LitKind::Int(_, LitIntType::Signed(..))\n            | LitKind::Int(_, LitIntType::Unsigned(..))\n            | LitKind::Float(..) =\u003e false,\n        }\n    }\n\n    /// Returns true if this literal has a suffix.\n    pub fn is_suffixed(\u0026self) -\u003e bool {\n        !self.is_unsuffixed()\n    }\n}\n\n// NB: If you change this, you'll probably want to change the corresponding\n// type structure in middle/ty.rs as well.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct MutTy {\n    pub ty: P\u003cTy\u003e,\n    pub mutbl: Mutability,\n}\n\n/// Represents a method's signature in a trait declaration,\n/// or in an implementation.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct MethodSig {\n    pub unsafety: Unsafety,\n    pub constness: Spanned\u003cConstness\u003e,\n    pub abi: Abi,\n    pub decl: P\u003cFnDecl\u003e,\n}\n\n/// Represents an item declaration within a trait declaration,\n/// possibly including a default implementation. A trait item is\n/// either required (meaning it doesn't have an implementation, just a\n/// signature) or provided (meaning it has a default implementation).\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct TraitItem {\n    pub id: NodeId,\n    pub ident: Ident,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub generics: Generics,\n    pub node: TraitItemKind,\n    pub span: Span,\n    /// See `Item::tokens` for what this is\n    pub tokens: Option\u003cTokenStream\u003e,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum TraitItemKind {\n    Const(P\u003cTy\u003e, Option\u003cP\u003cExpr\u003e\u003e),\n    Method(MethodSig, Option\u003cP\u003cBlock\u003e\u003e),\n    Type(TyParamBounds, Option\u003cP\u003cTy\u003e\u003e),\n    Macro(Mac),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct ImplItem {\n    pub id: NodeId,\n    pub ident: Ident,\n    pub vis: Visibility,\n    pub defaultness: Defaultness,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub generics: Generics,\n    pub node: ImplItemKind,\n    pub span: Span,\n    /// See `Item::tokens` for what this is\n    pub tokens: Option\u003cTokenStream\u003e,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum ImplItemKind {\n    Const(P\u003cTy\u003e, P\u003cExpr\u003e),\n    Method(MethodSig, P\u003cBlock\u003e),\n    Type(P\u003cTy\u003e),\n    Macro(Mac),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, PartialOrd, Ord)]\npub enum IntTy {\n    Isize,\n    I8,\n    I16,\n    I32,\n    I64,\n    I128,\n}\n\nimpl fmt::Debug for IntTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}\n\nimpl fmt::Display for IntTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.ty_to_string())\n    }\n}\n\nimpl IntTy {\n    pub fn ty_to_string(\u0026self) -\u003e \u0026'static str {\n        match *self {\n            IntTy::Isize =\u003e \"isize\",\n            IntTy::I8 =\u003e \"i8\",\n            IntTy::I16 =\u003e \"i16\",\n            IntTy::I32 =\u003e \"i32\",\n            IntTy::I64 =\u003e \"i64\",\n            IntTy::I128 =\u003e \"i128\",\n        }\n    }\n\n    pub fn val_to_string(\u0026self, val: i128) -\u003e String {\n        // cast to a u128 so we can correctly print INT128_MIN. All integral types\n        // are parsed as u128, so we wouldn't want to print an extra negative\n        // sign.\n        format!(\"{}{}\", val as u128, self.ty_to_string())\n    }\n\n    pub fn bit_width(\u0026self) -\u003e Option\u003cusize\u003e {\n        Some(match *self {\n            IntTy::Isize =\u003e return None,\n            IntTy::I8 =\u003e 8,\n            IntTy::I16 =\u003e 16,\n            IntTy::I32 =\u003e 32,\n            IntTy::I64 =\u003e 64,\n            IntTy::I128 =\u003e 128,\n        })\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, PartialOrd, Ord)]\npub enum UintTy {\n    Usize,\n    U8,\n    U16,\n    U32,\n    U64,\n    U128,\n}\n\nimpl UintTy {\n    pub fn ty_to_string(\u0026self) -\u003e \u0026'static str {\n        match *self {\n            UintTy::Usize =\u003e \"usize\",\n            UintTy::U8 =\u003e \"u8\",\n            UintTy::U16 =\u003e \"u16\",\n            UintTy::U32 =\u003e \"u32\",\n            UintTy::U64 =\u003e \"u64\",\n            UintTy::U128 =\u003e \"u128\",\n        }\n    }\n\n    pub fn val_to_string(\u0026self, val: u128) -\u003e String {\n        format!(\"{}{}\", val, self.ty_to_string())\n    }\n\n    pub fn bit_width(\u0026self) -\u003e Option\u003cusize\u003e {\n        Some(match *self {\n            UintTy::Usize =\u003e return None,\n            UintTy::U8 =\u003e 8,\n            UintTy::U16 =\u003e 16,\n            UintTy::U32 =\u003e 32,\n            UintTy::U64 =\u003e 64,\n            UintTy::U128 =\u003e 128,\n        })\n    }\n}\n\nimpl fmt::Debug for UintTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}\n\nimpl fmt::Display for UintTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.ty_to_string())\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, PartialOrd, Ord)]\npub enum FloatTy {\n    F32,\n    F64,\n}\n\nimpl fmt::Debug for FloatTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}\n\nimpl fmt::Display for FloatTy {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.ty_to_string())\n    }\n}\n\nimpl FloatTy {\n    pub fn ty_to_string(\u0026self) -\u003e \u0026'static str {\n        match *self {\n            FloatTy::F32 =\u003e \"f32\",\n            FloatTy::F64 =\u003e \"f64\",\n        }\n    }\n\n    pub fn bit_width(\u0026self) -\u003e usize {\n        match *self {\n            FloatTy::F32 =\u003e 32,\n            FloatTy::F64 =\u003e 64,\n        }\n    }\n}\n\n// Bind a type to an associated type: `A=Foo`.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct TypeBinding {\n    pub id: NodeId,\n    pub ident: Ident,\n    pub ty: P\u003cTy\u003e,\n    pub span: Span,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub struct Ty {\n    pub id: NodeId,\n    pub node: TyKind,\n    pub span: Span,\n}\n\nimpl fmt::Debug for Ty {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"type({})\", pprust::ty_to_string(self))\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct BareFnTy {\n    pub unsafety: Unsafety,\n    pub abi: Abi,\n    pub generic_params: Vec\u003cGenericParam\u003e,\n    pub decl: P\u003cFnDecl\u003e,\n}\n\n/// The different kinds of types recognized by the compiler\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum TyKind {\n    /// A variable-length slice (`[T]`)\n    Slice(P\u003cTy\u003e),\n    /// A fixed length array (`[T; n]`)\n    Array(P\u003cTy\u003e, P\u003cExpr\u003e),\n    /// A raw pointer (`*const T` or `*mut T`)\n    Ptr(MutTy),\n    /// A reference (`\u0026'a T` or `\u0026'a mut T`)\n    Rptr(Option\u003cLifetime\u003e, MutTy),\n    /// A bare function (e.g. `fn(usize) -\u003e bool`)\n    BareFn(P\u003cBareFnTy\u003e),\n    /// The never type (`!`)\n    Never,\n    /// A tuple (`(A, B, C, D,...)`)\n    Tup(Vec\u003cP\u003cTy\u003e\u003e),\n    /// A path (`module::module::...::Type`), optionally\n    /// \"qualified\", e.g. `\u003cVec\u003cT\u003e as SomeTrait\u003e::SomeType`.\n    ///\n    /// Type parameters are stored in the Path itself\n    Path(Option\u003cQSelf\u003e, Path),\n    /// A trait object type `Bound1 + Bound2 + Bound3`\n    /// where `Bound` is a trait or a lifetime.\n    TraitObject(TyParamBounds, TraitObjectSyntax),\n    /// An `impl Bound1 + Bound2 + Bound3` type\n    /// where `Bound` is a trait or a lifetime.\n    ImplTrait(TyParamBounds),\n    /// No-op; kept solely so that we can pretty-print faithfully\n    Paren(P\u003cTy\u003e),\n    /// Unused for now\n    Typeof(P\u003cExpr\u003e),\n    /// TyKind::Infer means the type should be inferred instead of it having been\n    /// specified. This can appear anywhere in a type.\n    Infer,\n    /// Inferred type of a `self` or `\u0026self` argument in a method.\n    ImplicitSelf,\n    // A macro in the type position.\n    Mac(Mac),\n    /// Placeholder for a kind that has failed to be defined.\n    Err,\n}\n\n/// Syntax used to declare a trait object.\n#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum TraitObjectSyntax {\n    Dyn,\n    None,\n}\n\n/// Inline assembly dialect.\n///\n/// E.g. `\"intel\"` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum AsmDialect {\n    Att,\n    Intel,\n}\n\n/// Inline assembly.\n///\n/// E.g. `\"={eax}\"(result)` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct InlineAsmOutput {\n    pub constraint: Symbol,\n    pub expr: P\u003cExpr\u003e,\n    pub is_rw: bool,\n    pub is_indirect: bool,\n}\n\n/// Inline assembly.\n///\n/// E.g. `asm!(\"NOP\");`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct InlineAsm {\n    pub asm: Symbol,\n    pub asm_str_style: StrStyle,\n    pub outputs: Vec\u003cInlineAsmOutput\u003e,\n    pub inputs: Vec\u003c(Symbol, P\u003cExpr\u003e)\u003e,\n    pub clobbers: Vec\u003cSymbol\u003e,\n    pub volatile: bool,\n    pub alignstack: bool,\n    pub dialect: AsmDialect,\n    pub ctxt: SyntaxContext,\n}\n\n/// An argument in a function header.\n///\n/// E.g. `bar: usize` as in `fn foo(bar: usize)`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Arg {\n    pub ty: P\u003cTy\u003e,\n    pub pat: P\u003cPat\u003e,\n    pub id: NodeId,\n}\n\n/// Alternative representation for `Arg`s describing `self` parameter of methods.\n///\n/// E.g. `\u0026mut self` as in `fn foo(\u0026mut self)`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum SelfKind {\n    /// `self`, `mut self`\n    Value(Mutability),\n    /// `\u0026'lt self`, `\u0026'lt mut self`\n    Region(Option\u003cLifetime\u003e, Mutability),\n    /// `self: TYPE`, `mut self: TYPE`\n    Explicit(P\u003cTy\u003e, Mutability),\n}\n\npub type ExplicitSelf = Spanned\u003cSelfKind\u003e;\n\nimpl Arg {\n    pub fn to_self(\u0026self) -\u003e Option\u003cExplicitSelf\u003e {\n        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n            if ident.node.name == keywords::SelfValue.name() {\n                return match self.ty.node {\n                    TyKind::ImplicitSelf =\u003e Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n                    TyKind::Rptr(lt, MutTy { ref ty, mutbl })\n                        if ty.node == TyKind::ImplicitSelf =\u003e\n                    {\n                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                    }\n                    _ =\u003e Some(respan(\n                        self.pat.span.to(self.ty.span),\n                        SelfKind::Explicit(self.ty.clone(), mutbl),\n                    )),\n                };\n            }\n        }\n        None\n    }\n\n    pub fn is_self(\u0026self) -\u003e bool {\n        if let PatKind::Ident(_, ident, _) = self.pat.node {\n            ident.node.name == keywords::SelfValue.name()\n        } else {\n            false\n        }\n    }\n\n    pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -\u003e Arg {\n        let span = eself.span.to(eself_ident.span);\n        let infer_ty = P(Ty {\n            id: DUMMY_NODE_ID,\n            node: TyKind::ImplicitSelf,\n            span,\n        });\n        let arg = |mutbl, ty| Arg {\n            pat: P(Pat {\n                id: DUMMY_NODE_ID,\n                node: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n                span,\n            }),\n            ty,\n            id: DUMMY_NODE_ID,\n        };\n        match eself.node {\n            SelfKind::Explicit(ty, mutbl) =\u003e arg(mutbl, ty),\n            SelfKind::Value(mutbl) =\u003e arg(mutbl, infer_ty),\n            SelfKind::Region(lt, mutbl) =\u003e arg(\n                Mutability::Immutable,\n                P(Ty {\n                    id: DUMMY_NODE_ID,\n                    node: TyKind::Rptr(\n                        lt,\n                        MutTy {\n                            ty: infer_ty,\n                            mutbl: mutbl,\n                        },\n                    ),\n                    span,\n                }),\n            ),\n        }\n    }\n}\n\n/// Header (not the body) of a function declaration.\n///\n/// E.g. `fn foo(bar: baz)`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct FnDecl {\n    pub inputs: Vec\u003cArg\u003e,\n    pub output: FunctionRetTy,\n    pub variadic: bool,\n}\n\nimpl FnDecl {\n    pub fn get_self(\u0026self) -\u003e Option\u003cExplicitSelf\u003e {\n        self.inputs.get(0).and_then(Arg::to_self)\n    }\n    pub fn has_self(\u0026self) -\u003e bool {\n        self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n    }\n}\n\n/// Is the trait definition an auto trait?\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum IsAuto {\n    Yes,\n    No,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum Unsafety {\n    Unsafe,\n    Normal,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum Constness {\n    Const,\n    NotConst,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum Defaultness {\n    Default,\n    Final,\n}\n\nimpl fmt::Display for Unsafety {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(\n            match *self {\n                Unsafety::Normal =\u003e \"normal\",\n                Unsafety::Unsafe =\u003e \"unsafe\",\n            },\n            f,\n        )\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\npub enum ImplPolarity {\n    /// `impl Trait for Type`\n    Positive,\n    /// `impl !Trait for Type`\n    Negative,\n}\n\nimpl fmt::Debug for ImplPolarity {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match *self {\n            ImplPolarity::Positive =\u003e \"positive\".fmt(f),\n            ImplPolarity::Negative =\u003e \"negative\".fmt(f),\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum FunctionRetTy {\n    /// Return type is not specified.\n    ///\n    /// Functions default to `()` and\n    /// closures default to inference. Span points to where return\n    /// type would be inserted.\n    Default(Span),\n    /// Everything else\n    Ty(P\u003cTy\u003e),\n}\n\nimpl FunctionRetTy {\n    pub fn span(\u0026self) -\u003e Span {\n        match *self {\n            FunctionRetTy::Default(span) =\u003e span,\n            FunctionRetTy::Ty(ref ty) =\u003e ty.span,\n        }\n    }\n}\n\n/// Module declaration.\n///\n/// E.g. `mod foo;` or `mod foo { .. }`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Mod {\n    /// A span from the first token past `{` to the last token until `}`.\n    /// For `mod foo;`, the inner span ranges from the first token\n    /// to the last token in the external file.\n    pub inner: Span,\n    pub items: Vec\u003cP\u003cItem\u003e\u003e,\n}\n\n/// Foreign module declaration.\n///\n/// E.g. `extern { .. }` or `extern C { .. }`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct ForeignMod {\n    pub abi: Abi,\n    pub items: Vec\u003cForeignItem\u003e,\n}\n\n/// Global inline assembly\n///\n/// aka module-level assembly or file-scoped assembly\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub struct GlobalAsm {\n    pub asm: Symbol,\n    pub ctxt: SyntaxContext,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct EnumDef {\n    pub variants: Vec\u003cVariant\u003e,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Variant_ {\n    pub name: Ident,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub data: VariantData,\n    /// Explicit discriminant, e.g. `Foo = 1`\n    pub disr_expr: Option\u003cP\u003cExpr\u003e\u003e,\n}\n\npub type Variant = Spanned\u003cVariant_\u003e;\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum UseTreeKind {\n    Simple(Ident),\n    Glob,\n    Nested(Vec\u003c(UseTree, NodeId)\u003e),\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct UseTree {\n    pub kind: UseTreeKind,\n    pub prefix: Path,\n    pub span: Span,\n}\n\n/// Distinguishes between Attributes that decorate items and Attributes that\n/// are contained as statements within items. These two cases need to be\n/// distinguished for pretty-printing.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub enum AttrStyle {\n    Outer,\n    Inner,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\npub struct AttrId(pub usize);\n\n/// Meta-data associated with an item\n/// Doc-comments are promoted to attributes that have is_sugared_doc = true\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Attribute {\n    pub id: AttrId,\n    pub style: AttrStyle,\n    pub path: Path,\n    pub tokens: TokenStream,\n    pub is_sugared_doc: bool,\n    pub span: Span,\n}\n\n/// TraitRef's appear in impls.\n///\n/// resolve maps each TraitRef's ref_id to its defining trait; that's all\n/// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n/// If this impl is an ItemKind::Impl, the impl_id is redundant (it could be the\n/// same as the impl's node id).\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct TraitRef {\n    pub path: Path,\n    pub ref_id: NodeId,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct PolyTraitRef {\n    /// The `'a` in `\u003c'a\u003e Foo\u003c\u0026'a T\u003e`\n    pub bound_generic_params: Vec\u003cGenericParam\u003e,\n\n    /// The `Foo\u003c\u0026'a T\u003e` in `\u003c'a\u003e Foo\u003c\u0026'a T\u003e`\n    pub trait_ref: TraitRef,\n\n    pub span: Span,\n}\n\nimpl PolyTraitRef {\n    pub fn new(generic_params: Vec\u003cGenericParam\u003e, path: Path, span: Span) -\u003e Self {\n        PolyTraitRef {\n            bound_generic_params: generic_params,\n            trait_ref: TraitRef {\n                path: path,\n                ref_id: DUMMY_NODE_ID,\n            },\n            span,\n        }\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum CrateSugar {\n    /// Source is `pub(crate)`\n    PubCrate,\n\n    /// Source is (just) `crate`\n    JustCrate,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum Visibility {\n    Public,\n    Crate(Span, CrateSugar),\n    Restricted { path: P\u003cPath\u003e, id: NodeId },\n    Inherited,\n}\n\n/// Field of a struct.\n///\n/// E.g. `bar: usize` as in `struct Foo { bar: usize }`\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct StructField {\n    pub span: Span,\n    pub ident: Option\u003cIdent\u003e,\n    pub vis: Visibility,\n    pub id: NodeId,\n    pub ty: P\u003cTy\u003e,\n    pub attrs: Vec\u003cAttribute\u003e,\n}\n\n/// Fields and Ids of enum variants and structs\n///\n/// For enum variants: `NodeId` represents both an Id of the variant itself (relevant for all\n/// variant kinds) and an Id of the variant's constructor (not relevant for `Struct`-variants).\n/// One shared Id can be successfully used for these two purposes.\n/// Id of the whole enum lives in `Item`.\n///\n/// For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually\n/// used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of\n/// the variant itself\" from enum variants.\n/// Id of the whole struct lives in `Item`.\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum VariantData {\n    /// Struct variant.\n    ///\n    /// E.g. `Bar { .. }` as in `enum Foo { Bar { .. } }`\n    Struct(Vec\u003cStructField\u003e, NodeId),\n    /// Tuple variant.\n    ///\n    /// E.g. `Bar(..)` as in `enum Foo { Bar(..) }`\n    Tuple(Vec\u003cStructField\u003e, NodeId),\n    /// Unit variant.\n    ///\n    /// E.g. `Bar = ..` as in `enum Foo { Bar = .. }`\n    Unit(NodeId),\n}\n\nimpl VariantData {\n    pub fn fields(\u0026self) -\u003e \u0026[StructField] {\n        match *self {\n            VariantData::Struct(ref fields, _) | VariantData::Tuple(ref fields, _) =\u003e fields,\n            _ =\u003e \u0026[],\n        }\n    }\n    pub fn id(\u0026self) -\u003e NodeId {\n        match *self {\n            VariantData::Struct(_, id) | VariantData::Tuple(_, id) | VariantData::Unit(id) =\u003e id,\n        }\n    }\n    pub fn is_struct(\u0026self) -\u003e bool {\n        if let VariantData::Struct(..) = *self {\n            true\n        } else {\n            false\n        }\n    }\n    pub fn is_tuple(\u0026self) -\u003e bool {\n        if let VariantData::Tuple(..) = *self {\n            true\n        } else {\n            false\n        }\n    }\n    pub fn is_unit(\u0026self) -\u003e bool {\n        if let VariantData::Unit(..) = *self {\n            true\n        } else {\n            false\n        }\n    }\n}\n\n/// An item\n///\n/// The name might be a dummy name in case of anonymous items\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct Item {\n    pub ident: Ident,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub id: NodeId,\n    pub node: ItemKind,\n    pub vis: Visibility,\n    pub span: Span,\n\n    /// Original tokens this item was parsed from. This isn't necessarily\n    /// available for all items, although over time more and more items should\n    /// have this be `Some`. Right now this is primarily used for procedural\n    /// macros, notably custom attributes.\n    ///\n    /// Note that the tokens here do not include the outer attributes, but will\n    /// include inner attributes.\n    pub tokens: Option\u003cTokenStream\u003e,\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum ItemKind {\n    /// An `extern crate` item, with optional original crate name.\n    ///\n    /// E.g. `extern crate foo` or `extern crate foo_bar as foo`\n    ExternCrate(Option\u003cName\u003e),\n    /// A use declaration (`use` or `pub use`) item.\n    ///\n    /// E.g. `use foo;`, `use foo::bar;` or `use foo::bar as FooBar;`\n    Use(P\u003cUseTree\u003e),\n    /// A static item (`static` or `pub static`).\n    ///\n    /// E.g. `static FOO: i32 = 42;` or `static FOO: \u0026'static str = \"bar\";`\n    Static(P\u003cTy\u003e, Mutability, P\u003cExpr\u003e),\n    /// A constant item (`const` or `pub const`).\n    ///\n    /// E.g. `const FOO: i32 = 42;`\n    Const(P\u003cTy\u003e, P\u003cExpr\u003e),\n    /// A function declaration (`fn` or `pub fn`).\n    ///\n    /// E.g. `fn foo(bar: usize) -\u003e usize { .. }`\n    Fn(\n        P\u003cFnDecl\u003e,\n        Unsafety,\n        Spanned\u003cConstness\u003e,\n        Abi,\n        Generics,\n        P\u003cBlock\u003e,\n    ),\n    /// A module declaration (`mod` or `pub mod`).\n    ///\n    /// E.g. `mod foo;` or `mod foo { .. }`\n    Mod(Mod),\n    /// An external module (`extern` or `pub extern`).\n    ///\n    /// E.g. `extern {}` or `extern \"C\" {}`\n    ForeignMod(ForeignMod),\n    /// Module-level inline assembly (from `global_asm!()`)\n    GlobalAsm(P\u003cGlobalAsm\u003e),\n    /// A type alias (`type` or `pub type`).\n    ///\n    /// E.g. `type Foo = Bar\u003cu8\u003e;`\n    Ty(P\u003cTy\u003e, Generics),\n    /// An enum definition (`enum` or `pub enum`).\n    ///\n    /// E.g. `enum Foo\u003cA, B\u003e { C\u003cA\u003e, D\u003cB\u003e }`\n    Enum(EnumDef, Generics),\n    /// A struct definition (`struct` or `pub struct`).\n    ///\n    /// E.g. `struct Foo\u003cA\u003e { x: A }`\n    Struct(VariantData, Generics),\n    /// A union definition (`union` or `pub union`).\n    ///\n    /// E.g. `union Foo\u003cA, B\u003e { x: A, y: B }`\n    Union(VariantData, Generics),\n    /// A Trait declaration (`trait` or `pub trait`).\n    ///\n    /// E.g. `trait Foo { .. }`, `trait Foo\u003cT\u003e { .. }` or `auto trait Foo {}`\n    Trait(IsAuto, Unsafety, Generics, TyParamBounds, Vec\u003cTraitItem\u003e),\n    /// Trait alias\n    ///\n    /// E.g. `trait Foo = Bar + Quux;`\n    TraitAlias(Generics, TyParamBounds),\n    /// An implementation.\n    ///\n    /// E.g. `impl\u003cA\u003e Foo\u003cA\u003e { .. }` or `impl\u003cA\u003e Trait for Foo\u003cA\u003e { .. }`\n    Impl(\n        Unsafety,\n        ImplPolarity,\n        Defaultness,\n        Generics,\n        Option\u003cTraitRef\u003e, // (optional) trait this impl implements\n        P\u003cTy\u003e,            // self\n        Vec\u003cImplItem\u003e,\n    ),\n    /// A macro invocation.\n    ///\n    /// E.g. `macro_rules! foo { .. }` or `foo!(..)`\n    Mac(Mac),\n\n    /// A macro definition.\n    MacroDef(MacroDef),\n}\n\nimpl ItemKind {\n    pub fn descriptive_variant(\u0026self) -\u003e \u0026str {\n        match *self {\n            ItemKind::ExternCrate(..) =\u003e \"extern crate\",\n            ItemKind::Use(..) =\u003e \"use\",\n            ItemKind::Static(..) =\u003e \"static item\",\n            ItemKind::Const(..) =\u003e \"constant item\",\n            ItemKind::Fn(..) =\u003e \"function\",\n            ItemKind::Mod(..) =\u003e \"module\",\n            ItemKind::ForeignMod(..) =\u003e \"foreign module\",\n            ItemKind::GlobalAsm(..) =\u003e \"global asm\",\n            ItemKind::Ty(..) =\u003e \"type alias\",\n            ItemKind::Enum(..) =\u003e \"enum\",\n            ItemKind::Struct(..) =\u003e \"struct\",\n            ItemKind::Union(..) =\u003e \"union\",\n            ItemKind::Trait(..) =\u003e \"trait\",\n            ItemKind::TraitAlias(..) =\u003e \"trait alias\",\n            ItemKind::Mac(..) | ItemKind::MacroDef(..) | ItemKind::Impl(..) =\u003e \"item\",\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub struct ForeignItem {\n    pub ident: Ident,\n    pub attrs: Vec\u003cAttribute\u003e,\n    pub node: ForeignItemKind,\n    pub id: NodeId,\n    pub span: Span,\n    pub vis: Visibility,\n}\n\n/// An item within an `extern` block\n#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\npub enum ForeignItemKind {\n    /// A foreign function\n    Fn(P\u003cFnDecl\u003e, Generics),\n    /// A foreign static item (`static ext: u8`), with optional mutability\n    /// (the boolean is true when mutable)\n    Static(P\u003cTy\u003e, bool),\n    /// A foreign type\n    Ty,\n}\n\nimpl ForeignItemKind {\n    pub fn descriptive_variant(\u0026self) -\u003e \u0026str {\n        match *self {\n            ForeignItemKind::Fn(..) =\u003e \"foreign function\",\n            ForeignItemKind::Static(..) =\u003e \"foreign static item\",\n            ForeignItemKind::Ty =\u003e \"foreign type\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serialize;\n\n    // are ASTs encodable?\n    #[test]\n    fn check_asts_encodable() {\n        fn assert_encodable\u003cT: serialize::Encodable\u003e() {}\n        assert_encodable::\u003cCrate\u003e();\n    }\n}\n","traces":[{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-rust","examples","weird-exprs.rs"],"content":"//@ run-pass\n\n#![feature(coroutines)]\n\n#![allow(non_camel_case_types)]\n#![allow(dead_code)]\n#![allow(redundant_semicolons)]\n#![allow(unreachable_code)]\n#![allow(unused_braces, unused_must_use, unused_parens)]\n#![allow(uncommon_codepoints, confusable_idents)]\n#![allow(unused_imports)]\n#![allow(unreachable_patterns)]\n\n#![recursion_limit = \"256\"]\n\nextern crate core;\nuse std::cell::Cell;\nuse std::mem::swap;\nuse std::ops::Deref;\n\n// Just a grab bag of stuff that you wouldn't want to actually write.\n\nfn strange() -\u003e bool { let _x: bool = return true; }\n\nfn funny() {\n    fn f(_x: ()) { }\n    f(return);\n}\n\nfn what() {\n    fn the(x: \u0026Cell\u003cbool\u003e) {\n        return while !x.get() { x.set(true); };\n    }\n    let i = \u0026Cell::new(false);\n    let dont = {||the(i)};\n    dont();\n    assert!((i.get()));\n}\n\nfn zombiejesus() {\n    loop {\n        while (return) {\n            if (return) {\n                match (return) {\n                    1 =\u003e {\n                        if (return) {\n                            return\n                        } else {\n                            return\n                        }\n                    }\n                    _ =\u003e { return }\n                };\n            } else if (return) {\n                return;\n            }\n        }\n        if (return) { break; }\n    }\n}\n\nfn notsure() {\n    let mut _x: isize;\n    let mut _y = (_x = 0) == (_x = 0);\n    let mut _z = (_x = 0) \u003c (_x = 0);\n    let _a = (_x += 0) == (_x = 0);\n    let _b = swap(\u0026mut _y, \u0026mut _z) == swap(\u0026mut _y, \u0026mut _z);\n}\n\nfn canttouchthis() -\u003e usize {\n    fn p() -\u003e bool { true }\n    let _a = (assert!((true)) == (assert!(p())));\n    let _c = (assert!((p())) == ());\n    let _b: bool = (println!(\"{}\", 0) == (return 0));\n}\n\nfn angrydome() {\n    loop { if break { } }\n    let mut i = 0;\n    loop { i += 1; if i == 1 { match (continue) { 1 =\u003e { }, _ =\u003e panic!(\"wat\") } }\n      break; }\n}\n\nfn evil_lincoln() { let _evil: () = println!(\"lincoln\"); }\n\nfn dots() {\n    assert_eq!(String::from(\"..................................................\"),\n               format!(\"{:?}\", .. .. .. .. .. .. .. .. .. .. .. .. ..\n                               .. .. .. .. .. .. .. .. .. .. .. ..));\n}\n\nfn u8(u8: u8) {\n    if u8 != 0u8 {\n        assert_eq!(8u8, {\n            macro_rules! u8 {\n                (u8) =\u003e {\n                    mod u8 {\n                        pub fn u8\u003c'u8: 'u8 + 'u8\u003e(u8: \u0026'u8 u8) -\u003e \u0026'u8 u8 {\n                            \"u8\";\n                            u8\n                        }\n                    }\n                };\n            }\n\n            u8!(u8);\n            let \u0026u8: \u0026u8 = u8::u8(\u00268u8);\n            ::u8(0u8);\n            u8\n        });\n    }\n}\n\nfn fishy() {\n    assert_eq!(String::from(\"\u003e\u003c\u003e\"),\n               String::\u003c\u003e::from::\u003c\u003e(\"\u003e\u003c\u003e\").chars::\u003c\u003e().rev::\u003c\u003e().collect::\u003cString\u003e());\n}\n\nfn union() {\n    union union\u003c'union\u003e { union: \u0026'union union\u003c'union\u003e, }\n}\n\nfn special_characters() {\n    let val = !((|(..):(_,_),(|__@_|__)|__)((\u0026*\"\\\\\",'🤔')/**/,{})=={\u0026[..=..][..];})//\n    ;\n    assert!(!val);\n}\n\nfn punch_card() -\u003e impl std::fmt::Debug {\n    ..=..=.. ..    .. .. .. ..    .. .. .. ..    .. ..=.. ..\n    ..=.. ..=..    .. .. .. ..    .. .. .. ..    ..=..=..=..\n    ..=.. ..=..    ..=.. ..=..    .. ..=..=..    .. ..=.. ..\n    ..=..=.. ..    ..=.. ..=..    ..=.. .. ..    .. ..=.. ..\n    ..=.. ..=..    ..=.. ..=..    .. ..=.. ..    .. ..=.. ..\n    ..=.. ..=..    ..=.. ..=..    .. .. ..=..    .. ..=.. ..\n    ..=.. ..=..    .. ..=..=..    ..=..=.. ..    .. ..=.. ..\n}\n\nfn r#match() {\n    let val: () = match match match match match () {\n        () =\u003e ()\n    } {\n        () =\u003e ()\n    } {\n        () =\u003e ()\n    } {\n        () =\u003e ()\n    } {\n        () =\u003e ()\n    };\n    assert_eq!(val, ());\n}\n\nfn i_yield() {\n    static || {\n        yield yield yield yield yield yield yield yield yield;\n    };\n}\n\nfn match_nested_if() {\n    let val = match () {\n        () if if if if true {true} else {false} {true} else {false} {true} else {false} =\u003e true,\n        _ =\u003e false,\n    };\n    assert!(val);\n}\n\nfn monkey_barrel() {\n    let val: () = ()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=();\n    assert_eq!(val, ());\n}\n\nfn 𝚌𝚘𝚗𝚝𝚒𝚗𝚞𝚎() {\n    type 𝚕𝚘𝚘𝚙 = i32;\n    fn 𝚋𝚛𝚎𝚊𝚔() -\u003e 𝚕𝚘𝚘𝚙 {\n        let 𝚛𝚎𝚝𝚞𝚛𝚗 = 42;\n        return 𝚛𝚎𝚝𝚞𝚛𝚗;\n    }\n    assert_eq!(loop {\n        break 𝚋𝚛𝚎𝚊𝚔 ();\n    }, 42);\n}\n\nfn function() {\n    struct foo;\n    impl Deref for foo {\n        type Target = fn() -\u003e Self;\n        fn deref(\u0026self) -\u003e \u0026Self::Target {\n            \u0026((|| foo) as _)\n        }\n    }\n    let foo = foo () ()() ()()() ()()()() ()()()()();\n}\n\nfn bathroom_stall() {\n    let mut i = 1;\n    matches!(2, _|_|_|_|_|_ if (i+=1) != (i+=1));\n    assert_eq!(i, 13);\n}\n\nfn closure_matching() {\n    let x = |_| Some(1);\n    let (|x| x) = match x(..) {\n        |_| Some(2) =\u003e |_| Some(3),\n        |_| _ =\u003e unreachable!(),\n    };\n    assert!(matches!(x(..), |_| Some(4)));\n}\n\nfn semisemisemisemisemi() {\n    ;;;;;;; ;;;;;;; ;;;    ;;; ;;\n    ;;      ;;      ;;;;  ;;;; ;;\n    ;;;;;;; ;;;;;   ;; ;;;; ;; ;;\n         ;; ;;      ;;  ;;  ;; ;;\n    ;;;;;;; ;;;;;;; ;;      ;; ;;\n}\n\nfn useful_syntax() {\n    use {{std::{{collections::{{HashMap}}}}}};\n    use ::{{{{core}, {std}}}};\n    use {{::{{core as core2}}}};\n}\n\nfn infcx() {\n    pub mod cx {\n        pub mod cx {\n            pub use super::cx;\n            pub struct Cx;\n        }\n    }\n    let _cx: cx::cx::Cx = cx::cx::cx::cx::cx::Cx;\n}\n\nfn return_already() -\u003e impl std::fmt::Debug {\n    loop {\n        return !!!!!!!\n        break !!!!!!1111\n    }\n}\n\nfn fake_macros() -\u003e impl std::fmt::Debug {\n    loop {\n        if! {\n            match! (\n                break! {\n                    return! {\n                        1337\n                    }\n                }\n            )\n\n            {}\n        }\n\n        {}\n    }\n}\n\npub fn main() {\n    strange();\n    funny();\n    what();\n    zombiejesus();\n    notsure();\n    canttouchthis();\n    angrydome();\n    evil_lincoln();\n    dots();\n    u8(8u8);\n    fishy();\n    union();\n    special_characters();\n    punch_card();\n    r#match();\n    i_yield();\n    match_nested_if();\n    monkey_barrel();\n    𝚌𝚘𝚗𝚝𝚒𝚗𝚞𝚎();\n    function();\n    bathroom_stall();\n    closure_matching();\n    semisemisemisemisemi();\n    useful_syntax();\n    infcx();\n    return_already();\n    fake_macros();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-typescript","bindings","rust","build.rs"],"content":"fn main() {\n    let root_dir = std::path::Path::new(\".\");\n    let typescript_dir = root_dir.join(\"typescript\").join(\"src\");\n    let tsx_dir = root_dir.join(\"tsx\").join(\"src\");\n    let common_dir = root_dir.join(\"common\");\n\n    let mut config = cc::Build::new();\n    config.include(\u0026typescript_dir);\n    config\n        .flag_if_supported(\"-std=c11\")\n        .flag_if_supported(\"-Wno-unused-parameter\");\n\n    for path in \u0026[\n        typescript_dir.join(\"parser.c\"),\n        typescript_dir.join(\"scanner.c\"),\n        tsx_dir.join(\"parser.c\"),\n        tsx_dir.join(\"scanner.c\"),\n    ] {\n        config.file(path);\n        println!(\"cargo:rerun-if-changed={}\", path.to_str().unwrap());\n    }\n\n    println!(\n        \"cargo:rerun-if-changed={}\",\n        common_dir.join(\"scanner.h\").to_str().unwrap()\n    );\n\n    config.compile(\"tree-sitter-typescript\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hikae","ghq","github.com","HikaruEgashira","vulnhuntrs","tree-sitter-typescript","bindings","rust","lib.rs"],"content":"//! This crate provides TypeScript and TSX language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [LANGUAGE_TYPESCRIPT] constant to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n//! ```\n//! use tree_sitter::Parser;\n//!\n//! let code = r#\"\n//! function double(x: number): number {\n//!     return x * 2;\n//! }\n//! \"#;\n//! let mut parser = Parser::new();\n//! let language = tree_sitter_typescript::LANGUAGE_TYPESCRIPT;\n//! parser\n//!     .set_language(\u0026language.into())\n//!     .expect(\"Error loading TypeScript parser\");\n//! let tree = parser.parse(code, None).unwrap();\n//! assert!(!tree.root_node().has_error());\n//! ```\n//!\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_typescript() -\u003e *const ();\n    fn tree_sitter_tsx() -\u003e *const ();\n}\n\n/// The tree-sitter [`LanguageFn`] for TypeScript.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE_TYPESCRIPT: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_typescript) };\n\n/// The tree-sitter [`LanguageFn`] for TSX.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE_TSX: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_tsx) };\n\n/// The content of the [`node-types.json`][] file for TypeScript.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const TYPESCRIPT_NODE_TYPES: \u0026str = include_str!(\"../../typescript/src/node-types.json\");\n\n/// The content of the [`node-types.json`][] file for TSX.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const TSX_NODE_TYPES: \u0026str = include_str!(\"../../tsx/src/node-types.json\");\n\n/// The syntax highlighting query for TypeScript.\npub const HIGHLIGHTS_QUERY: \u0026str = include_str!(\"../../queries/highlights.scm\");\n\n/// The local-variable syntax highlighting query for TypeScript.\npub const LOCALS_QUERY: \u0026str = include_str!(\"../../queries/locals.scm\");\n\n/// The symbol tagging query for TypeScript.\npub const TAGS_QUERY: \u0026str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_typescript_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE_TYPESCRIPT.into())\n            .expect(\"Error loading TypeScript parser\");\n    }\n\n    #[test]\n    fn test_can_load_tsx_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(\u0026super::LANGUAGE_TSX.into())\n            .expect(\"Error loading TSX parser\");\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>